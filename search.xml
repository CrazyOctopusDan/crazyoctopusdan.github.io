<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>成为一个有价值的程序员</title>
      <link href="/2023/04/28/%E6%88%90%E4%B8%BA%E4%B8%80%E4%B8%AA%E6%9C%89%E4%BB%B7%E5%80%BC%E7%9A%84%E7%A8%8B%E5%BA%8F%E5%91%98/"/>
      <url>/2023/04/28/%E6%88%90%E4%B8%BA%E4%B8%80%E4%B8%AA%E6%9C%89%E4%BB%B7%E5%80%BC%E7%9A%84%E7%A8%8B%E5%BA%8F%E5%91%98/</url>
      
        <content type="html"><![CDATA[<h1 id="MVP-最有价值的程序员"><a href="#MVP-最有价值的程序员" class="headerlink" title="MVP:最有价值的程序员"></a>MVP:最有价值的程序员</h1><p>缩写 MVP 通常代表最小可行产品，至少如果你在软件工程领域工作。但今天我想谈谈另一种 MVP：最有价值的程序员。</p><p>就像最小可行产品一样，最有价值程序员也不是一个具体的概念。相反，它是一个你为之奋斗的目标。此外，这也不是说你要成为同事中最有价值的人。相反，它是关于成为最好的自己。让我详细说明一下……</p><h2 id="年轻的我"><a href="#年轻的我" class="headerlink" title="年轻的我"></a>年轻的我</h2><p>有一天，我想起了大约 15 年前我与一位高级开发人员的谈话。我不记得当时脑子里是怎么想的了，但是我自己对几个大的 PHP 文件进行了微优化。这是在我们使用操作缓存之前的日子，所以每个请求都要对文件进行一次又一次的解析。为了优化这一点，我将所有双引号字符串改为单引号，因为我在某处读到：由于缺乏转义序列，解析这些字符串的速度提高了 11%(或类似的效果)。</p><p>所有这些都导致了一个巨大的差异，并且充满了乏味的变化。正是这位高级开发人员有幸审阅了这些文件，他责备了我一顿，因为我没有事先讨论就制造了这么大的分歧，这让他很头疼。但他对此却出奇地礼貌，他认为我在代码上使用了自动格式化器，这可能是我的可取之处，因为正如他所提到的，没有一个头脑正常的人会花时间手工做这样的事情。我接受了。</p><p>但那也是在自动格式化器普及之前，实际上我所有的代码都是手工完成的。哦，我真傻。我很清楚，当时承认这一点并不符合我的最大利益，但我确实愚蠢到浪费了几个小时来替换字符串引号和做其他繁琐的更改，反过来又浪费了我的前辈检查所有这些内容的时间。</p><p>这节课的教学方式甚至可能会有一些有趣的地方：他是否真的认为我在使用自动格式化器，或者他只是在假定我是无辜的？难道正是因为他那彬彬有礼的尖酸刻薄给我带来了耻辱，这个教训才让我印象深刻吗？无论如何，我从中吸取了教训，它帮助我迈出了成为一名更好的程序员的众多步骤之一：如果你愿意成为一个更有价值的程序员。</p><h2 id="代码与价值"><a href="#代码与价值" class="headerlink" title="代码与价值"></a>代码与价值</h2><p>我已经写了 28 年的代码了，我曾经对自己的代码感到非常自豪：我喜欢画架构图，我有严格的编码风格，遵循细致的接口指南，并且总是把性能放在我的脑海里。难怪我为我的代码感到骄傲，因为它确实是一个美丽的东西。（至少我是这么想的）</p><p>我想这对我来说可能是一种奢侈，因为我在高中之前就开始编程了。它让我在没有任何工作压力的情况下完善我的艺术，坦率地说，没有考虑真正重要的事情。我从早期的编程中学到了很多东西，但我认为我对代码本身的欣赏可能是许多年后阻碍我前进的东西。</p><p>如果你想成为一个更好的程序员，请接受这个建议：<strong>不要试图成为最好的程序员</strong>。没有人会同意成为最好的程序员意味着什么，所以这是一个徒劳的目标，追逐风气。相反，要努力成为<strong>最有价值的程序员</strong>。价值仍然是一个相当抽象的概念，但至少它可以与更具体的目标联系起来，比如业务价值。</p><p>我认为我最大的错误之一是我多年来一直相信的一个抽象的想法：<strong>代码是有价值的</strong>。它不是！代码是一种负担。一旦代码被编写出来，它就需要被审查，需要被维护，它可能需要被调试，或者重写，甚至扔掉。但是一旦它存在，它就变成了一个消耗时间的水槽。代码本身没有价值，只有价值所在。这可能是一个重言式，但它非常基本，需要重复强调：你从解决代码所解决的问题中获得价值，而不是从代码本身中获得价值。解决问题所需的代码越少越好。</p><p>想想看：如果你是一名工程师，你被雇佣来解决问题。代码可能是您的首选武器，但您不会因为交付代码而获得报酬。你的工作是解决问题。你解决的问题越多，你提供的价值就越大。您交付的代码越多，您的负担就越大……</p><p>那么，如何避免成为负担，成为一个能够解决许多问题的有价值的程序员呢？<strong>优先考虑</strong>一个好的技巧是改变思维方式：你不是在努力成为一个有价值的程序员，而是<strong>已经是</strong>一个有价值的程序员。你自己是最有价值的资产。那么你最稀缺的资源是什么？时间和精力。一天只有那么多小时，你只能集中那么多精力。不要浪费时间在代码格式上，而是帮助解决业务或项目最需要解决的问题。</p><h2 id="代码风格"><a href="#代码风格" class="headerlink" title="代码风格"></a>代码风格</h2><p>我想我本可以就此打住，但我脑子里已经有了所有这些话题，我不想浪费它们。因为这些都是大多数程序员在某些时候应该自己回答的问题，所以我们还是继续讨论吧。我们已经自然的触及了代码风格的主题。它也很好地强调了所有这一切的一个基本矛盾：许多事情同等重要，它们都值得我们关注。优先排序并不是简单地选择最重要的而放弃其他的。它是关于找到一种<strong>平衡</strong>，确保你的基本需求得到满足，这样你就可以把大部分时间花在最重要的事情上。</p><p>代码风格很重要，原因有很多：我们希望我们的代码是可读的，这样我们的同伴就可以审查它，这样我们自己也可以理解它，如果我们稍后必须回去。如果团队中的每个人都遵循自己的风格，这往往会分散代码试图实现目标的注意力。用与您习惯的不同风格编写的代码更难阅读，因为它违背了您的期望。比较一下两个人说不同的方言：他们可能都在说英语，但很难集中注意力在信息上。</p><p>但最终，你说哪种方言并不重要，只要每个人说的都一样。对于软件，这意味着在代码风格上达成一致并保持一致。在所有的细枝末节上都有无数的争论，所以我不想在这里重复。做出一个让你们作为一个团队感到快乐的选择，并坚持下去。</p><p>并确保您使用自动化来验证您的样式。没有比让机器去做更好的方法来避免浪费别人的时间了。</p><h2 id="正确性"><a href="#正确性" class="headerlink" title="正确性"></a>正确性</h2><p><strong>正确性</strong>和<strong>编程的乐趣</strong>。显而易见的是，两者都是极其重要的，而且因为更微妙的原因，两者之间可能存在无穷无尽的时间联系。确保代码正确是程序员的主要职责之一。bug 可能会影响用户，这对业务不利。更不用说，把它们弄下来也是一项费时费力的工作，没有人喜欢做，所以最好从一开始就避免它们。</p><p>所以我们的代码应该总是正确的吗？Emmmm，这要看情况。</p><p>例如，假设你正在编写一个脚本来处理存储库中的某些自动化。也许这个脚本不能处理无效的 UTF8 文件名。这很糟糕，你可以说这不是很正确。但如果你的存储库中没有任何文件会给它带来麻烦，那么它肯定足够正确了。</p><p>这与构建分发给最终用户并需要能够处理其机器上任意路径的客户端应用程序时完全不同。人们可能使用各种语言环境，迟早你会遇到一些文件名不是有效的 UTF8 编码。正确性的门槛在每种情况下可能有很大的差异。</p><p>一般来说，我认为我们编写的程序应该对所有可能合理预期的输入产生正确的结果是有意义的。也许你所在的行业中，bug 可能会造成危及生命的情况，在这种情况下，你可能对“合理预期”有非常严格的解释。但是，超出问题领域的需求通常会导致编写大量没有价值的代码。很少有人会为此感谢你。</p><h2 id="DRY"><a href="#DRY" class="headerlink" title="DRY"></a>DRY</h2><p>DRY 代表不要重复自己。与其复制粘贴代码并修改一小部分以适应不同的用例，不如编写可重用性更强的代码，并且可以用于两种用例。但这本身也会给初级程序员带来另一个陷阱。</p><p>这也像一个咒语，如果走极端，通常会导致它们被应用于适得其反的情况。DRY 的发明是为了简化可维护性。毕竟，如果您以后需要更新代码，您可能只需要在一个地方更新它，而不是查找它被复制到的所有地方，可能会遗漏一些地方。这很好，但是如果您继续用各种选项和分支扩展单个函数，使其覆盖越来越多的用例，那么该函数本身就会对可维护性造成危害。</p><p>在这种特殊情况下，最好将一个大函数拆分为几个小函数。然后，您可以将它们重新组合成更大的、特定于用例的代码，即使这样会引入一些样板文件。但在更普遍的意义上，总是尝试质疑给定指导方针的目的是什么。遵循这些准则并不是坏事，但要学会认识到什么时候是放弃它们的好时机。</p><h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><p>许多程序员的宠儿，如果没有人欣赏您的代码之美，至少您可以陶醉于节省了多少分配。我知道——我曾经替换了数百个引号，因为据说这样可以使解析它们的速度提高 11%，而这从一开始就不是瓶颈。</p><p>请注意，除非您在 Linux 内核或某些特殊的嵌入式领域工作，否则纠缠于性能是在浪费您自己的精力，并且不会提供任何真正的价值。</p><p>这并不是说性能不重要（所有这些话题都很重要），但提供良好的性能又非常关键，需要选择你的战斗。如果有必要，请优化你的关键路径。批量请求而不是向 API 或数据库发送几十或几百个请求。但如果某些东西已经足够快了，你不需要尝试进行优化。</p><h2 id="附加价值"><a href="#附加价值" class="headerlink" title="附加价值"></a>附加价值</h2><p>我们已经涵盖了很多例子来说明克制是好的。不要过度，你在成为有价值的程序员的道路上已经走了一半。但你应该把精力集中在哪里？如何增加价值？</p><p>这里是一个随机的想法列表，绝不是权威性的建议…</p><ul><li><strong>尝试理解业务对功能需求的动机</strong>：一旦您很好地理解了问题领域，您就可以提供更简单的替代方案，从而减少实现的工作量。</li><li><strong>确定未解决的问题区域</strong>：这些原因可以是技术性的，比如 bug 的常见原因，但也可以是过程相关的或组织性的，比如降低速度或团队士气的原因。你去做研究，然后提出解决方案，表现出你愿意解决这些问题。很多时候你会发现你不是第一个注意到他们的人，但这可能需要有人愿意付出努力。</li><li><strong>花时间检查同事的代码</strong>：在审查拉取请求时，试着理解他们试图解决的问题，以及他们的解决方案是否在这种情况下合理。你能想到他们可能遗漏了什么吗？这也是一个很好的知识分享机会。不要只指出他们遗漏的东西，如果这是你熟悉的系统，你还可以提供一些背景信息，解释为什么事情会变成这样。你甚至可以想到改进可维护性的方法，这样下一个人就不会再遗漏同样的东西了。</li><li><strong>沟通</strong>：确保其他人知道你正在做什么，并对其他人正在做什么有一些了解。如果别人不知道你的工作，他们也不能提供建议。你可能认为自己有一个好主意，想用一个可行的解决方案来给同事个惊喜。但在组织中，惊喜很少是好事，你不希望你的好主意干扰到别人。</li></ul><h2 id="不要忘记你自己"><a href="#不要忘记你自己" class="headerlink" title="不要忘记你自己"></a>不要忘记你自己</h2><p>感谢您一直阅读到这里。希望我能为您提供最后一个宝石，因为对于某些人来说，这可能是本文中最重要的建议：不要忘记自己。</p><p>我之前提到过，时间和精力是你最稀缺的资源。我还提到，优先考虑是找到确保基本需求得到满足的平衡点。如果你时间不够，你可能会错过截止日期，这对业务来说不好。如果你精力不足，你可能会面临燃尽的风险，这对任何人都不好，尤其是对你自己来说更不好。</p><p>但在你失去任何一种资源之前，通常会进入一个可以被识别的负面循环。如果你时间不多，会引起压力，导致你更快地消耗精力。如果你精力不足，你开始缺乏动力，并花更多的时间完成基本任务。如果你注意到这些迹象，那就非常明显表明你的基本需求没有得到满足，你需要说出来。如果你的经理必须问为什么错过了截止日期，那就太晚了。如果你不得不请病假来恢复被消耗完的精力，那肯定太晚了！</p><p>有许多方法可以防止这种负面循环或在注意到早期迹象后退出它。首先，不要过度承诺，因为这是一种确保承担更多工作而无法处理的方法。但如果你注意到一个特定的任务正在耗尽你的动力，请向同事寻求帮助，或将其放在后炉中，而不是强迫自己立即完成它。如果你觉得截止日期不合理，请提前告诉你的经理。如果你不能做到，不要打击自己。</p><p>确保你有时间为自己、家人和/或爱好。对我个人来说，阅读和尝试技术曾经是一种非常的消遣，但现在我经常发现自己写小说而不是编程[1]。我喜欢和我的妻子和儿子在一起，我可以完全满足地不去想工作或编程。</p><p>这一切都不会妨碍成为一个有价值的程序员的理念。你需要放松身心、保持健康才能快乐。只有这样，你才能保持精力，不断提高自己。快乐的程序员往往更有生产力[2]。</p><p>毕竟，你自己是最有价值的程序员，所以要照顾好自己。</p><p><a href="https://aronsilver.com/">[1] Aron Silver — an author of little renown</a></p><p><a href="https://link.springer.com/chapter/10.1007/978-1-4842-4221-6_10">[2] Happiness and the Productivity of Software Engineers</a></p><p><a href="https://arendjr.nl/2023/04/mvp-the-most-valuable-programmer">原文地址</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 译文 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>好用的Vscode</title>
      <link href="/2023/03/27/%E5%A5%BD%E7%94%A8%E7%9A%84Vscode/"/>
      <url>/2023/03/27/%E5%A5%BD%E7%94%A8%E7%9A%84Vscode/</url>
      
        <content type="html"><![CDATA[<p>用了 Vscode 好多年，从一开始开箱即用到现在慢慢地完善成为自己趁手的利器，我觉得有必要来建立一个文章长期完善更新我的武器。</p><h1 id="效率插件"><a href="#效率插件" class="headerlink" title="效率插件"></a>效率插件</h1><p>插件 yyds，一个谁都在用的工具想要变得更加适配，符合自己的插件必不可少！</p><h2 id="Chinese-Simplified-简体中文-Language-Pack-for-Visual-Studio-Code"><a href="#Chinese-Simplified-简体中文-Language-Pack-for-Visual-Studio-Code" class="headerlink" title="Chinese (Simplified) (简体中文) Language Pack for Visual Studio Code"></a>Chinese (Simplified) (简体中文) Language Pack for Visual Studio Code</h2><p>简单来说就是<a href="https://marketplace.visualstudio.com/items?itemName=MS-CEINTL.vscode-language-pack-zh-hans">汉化包</a><br>虽然英文是咱们程序员的必备选项，但是开发时候一目了然的中文也会很舒坦~</p><h2 id="Github-Copilot"><a href="#Github-Copilot" class="headerlink" title="Github Copilot"></a>Github Copilot</h2><blockquote><p>插件 Id<br>GitHub.copilot</p></blockquote><p>王炸中炸，除了收费，被小墙外，没有什么太大的缺点。</p><h2 id="Better-Comments"><a href="#Better-Comments" class="headerlink" title="Better Comments"></a>Better Comments</h2><blockquote><p>插件 Id<br>aaron-bond.better-comments</p></blockquote><p>这个真的相见恨晚，在我开发的前几年中，写注释还局限于<code>//* //</code>中，在开发的团队化越来越多时，一个好的注释能起到极大地作用（方便在回顾的时候知道当时是怎么拍脑门写的）</p><h2 id="Code-Spell-Checker"><a href="#Code-Spell-Checker" class="headerlink" title="Code Spell Checker"></a>Code Spell Checker</h2><blockquote><p>插件 Id<br>streetsidesoftware.code-spell-checker</p></blockquote><p>一个基本的拼写检查器，可以很好地处理代码和文档。<br>这个拼写检查器的目标是帮助捕捉常见的拼写错误，同时保持低误报的数量。<br>重要性不言而喻，来自祖国各地的小伙伴写的英文或许会被地方口音带跑偏，这时候就需要这个 Checker 来纠正回来。</p><h2 id="Error-Lens"><a href="#Error-Lens" class="headerlink" title="Error Lens"></a>Error Lens</h2><blockquote><p>插件 Id<br>usernamehw.errorlens</p></blockquote><p>Error Lens 通过使诊断更加突出来增强语言诊断功能，在语言生成诊断的地方突出显示整行，并在行内打印消息。<br>墙裂推荐！！！编码的小错误会被及时体现在代码后方，避免编译时候才发现小问题。</p><p>安装完毕后提示是英文，为了方便咱们中国人的阅读，有个简单的汉化方法：</p><ol><li>打开 vscode settings</li><li>搜索 typescript locale</li><li>设置为 zh-CN</li></ol><p>好了，现在享受编程吧！<img src="media/16798839902485/16798851132550.jpg" alt=""></p><h2 id="Prettier-Code-formatter"><a href="#Prettier-Code-formatter" class="headerlink" title="Prettier - Code formatter"></a>Prettier - Code formatter</h2><blockquote><p>插件 Id<br>esbenp.prettier-vscode<br>pretty 是一种支持自定义规则的代码格式化器。它通过解析代码并使用自己的规则重新打印代码来实现一致的风格，这些规则考虑到最大的行长，在必要时去格式化代码。<br>这个对于团队协作开发来说也非常重要，阅读别人的代码，如果格式不一致，看起来还是会有些费劲的。</p></blockquote><h2 id="Rainbow-Brackets"><a href="#Rainbow-Brackets" class="headerlink" title="Rainbow Brackets"></a>Rainbow Brackets</h2><blockquote><p>插件 Id<br>2gua.rainbow-brackets</p></blockquote><p>为圆形括号、方括号和弯曲括号提供彩虹色，这对于 JavaScript 的开发特别有用。<br>孤立的右括号将用红色突出显示。</p><h2 id="React-Redux-react-router-Snippets"><a href="#React-Redux-react-router-Snippets" class="headerlink" title="React/Redux/react-router Snippets"></a>React/Redux/react-router Snippets</h2><blockquote><p>插件 Id<br>discountry.react-redux-react-router-snippets<br>这种片段词展开的插件都挺好用的，只不过现在的框架是 React 语言体系下，日后在任何的体系下都可以通过<code>Snippets</code>去搜索。</p></blockquote><h2 id="Todo-Tree"><a href="#Todo-Tree" class="headerlink" title="Todo Tree"></a>Todo Tree</h2><blockquote><p>插件 Id<br>Gruntfuggly.todo-tree</p></blockquote><p>这个扩展快速搜索(使用 ripgrep)工作空间的 comment 标签，如 TODO 和 FIXME，并在活动栏的树形视图中显示它们。视图可以从活动栏中拖到资源管理器窗格中(或者其他任何您喜欢的位置)。<br>单击树中的 TODO 将打开文件，并将光标放在包含该 TODO 的行上。<br>找到的 todo 也可以在打开的文件中突出显示。<br>在代码中也可以有不少提速，例如写了一半被叫走干别的，加上<code>TODO</code>回头来做。</p><h2 id="Auto-Import"><a href="#Auto-Import" class="headerlink" title="Auto Import"></a>Auto Import</h2><blockquote><p>插件 Id<br>steoates.autoimport</p></blockquote><p>自动查找、解析并提供所有可用导入的代码操作和代码完成，使用 Typescript 和 TSX。</p><h2 id="EditorConfig-for-VS-Code"><a href="#EditorConfig-for-VS-Code" class="headerlink" title="EditorConfig for VS Code"></a>EditorConfig for VS Code</h2><blockquote><p>插件 Id<br>EditorConfig.EditorConfig</p></blockquote><p>这个插件试图用.editorconfig 文件中的设置覆盖用户/工作区设置。不需要额外的或特定于 vcode 的文件。与任何 EditorConfig 插件一样，如果没有指定 root=true, EditorConfig 将继续在项目外部寻找. EditorConfig 文件。</p><p>此存储库特定于 Visual Studio Code 的 EditorConfig 扩展。在内部，它使用 editorconfig npm 包，这是少数可用的 editorconfig 核心之一。</p><p>这个没什么好说的，提升编辑器自定义程度的插件。</p><h2 id="koroFileHeader"><a href="#koroFileHeader" class="headerlink" title="koroFileHeader"></a>koroFileHeader</h2><blockquote><p>插件 Id<br>OBKoro1.korofileheader</p></blockquote><p>这个只是有点好玩的插件：</p><blockquote><p>简介<br>VSCode 插件: 用于一键生成文件头部注释并自动更新最后编辑人和编辑时间、函数注释自动生成和参数提取。</p><ul><li>插件可以帮助用户养成良好的编码习惯，规范整个团队风格。</li><li>从 2018 年 5 月维护至今, 关闭 issue 500+ ，拥有 39.7w+的用户，VSCode 图表统计日均安装 200-500</li><li>经过多版迭代后，插件支持所有主流语言,灵活方便，文档齐全，食用简单！</li><li>觉得插件不错的话，就给个 Star⭐️ 吧~<br>主要功能:</li><li>自动生成文件头部注释，自动更新最后编辑人、最后编辑时间等。</li><li>一键生成函数注释，支持函数参数自动提取并列到注释中。</li><li>支持添加佛祖保佑永无 bug、神兽护体、甩葱少女等好玩有趣的图像注释</li><li>配置非常灵活方便，各种细节都能配置，可以量身打造适合你的注释。</li><li>支持所有主流语言, 配置文档非常详细，齐全。</li></ul></blockquote><h1 id="外观"><a href="#外观" class="headerlink" title="外观"></a>外观</h1><p>主题么喜欢的人因人而异，我就 mark 几个我喜欢的</p><h2 id="Horizon-Theme"><a href="#Horizon-Theme" class="headerlink" title="Horizon Theme"></a>Horizon Theme</h2><blockquote><p>插件 Id<br>jolaleye.horizon-theme-vscode<br>地平线，夕阳…… 下班看不见的，coding 可以看见。。。</p></blockquote><h2 id="Material-Icon-Theme"><a href="#Material-Icon-Theme" class="headerlink" title="Material Icon Theme"></a>Material Icon Theme</h2><blockquote><p>插件 Id<br>PKief.material-icon-theme</p></blockquote><p>这个很好用，根据文件的类型修改 ICON，一目了然的感觉还是很棒滴</p><h2 id="MonoLisa"><a href="#MonoLisa" class="headerlink" title="MonoLisa"></a>MonoLisa</h2><blockquote><p>是个字体</p></blockquote><p>这个字体比常规字母宽了一些，看起来会比较舒服!<br><img src="media/16798839902485/16799707718747.jpg" alt=""></p><h2 id="background"><a href="#background" class="headerlink" title="background"></a>background</h2><blockquote><p>插件 Id<br>shalldie.background</p></blockquote><p>在编辑器背景上面设置好老婆，编码愉悦+1<br><img src="media/16798839902485/16799709285082.jpg" alt=""></p>]]></content>
      
      
      
        <tags>
            
            <tag> 开发Tips </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>怎么处理React中的Errors</title>
      <link href="/2023/03/08/%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86React%E4%B8%AD%E7%9A%84Errors/"/>
      <url>/2023/03/08/%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86React%E4%B8%AD%E7%9A%84Errors/</url>
      
        <content type="html"><![CDATA[<h1 id="怎么处理-React-中的-Errors"><a href="#怎么处理-React-中的-Errors" class="headerlink" title="怎么处理 React 中的 Errors"></a>怎么处理 React 中的 Errors</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近在研究如何在 React 中捕获和处理错误，<br><code>try/catch</code>和<code>ErrorBoundary</code>的用法、模式和警告，什么时候是可行的，什么时候是不行的，以及如何用<code>ErrorBoundary</code>捕获所有错误，包括<code>async</code>错误和来自事件处理程序的错误。</p><p>我们都希望我们的应用能够稳定，能够完美地运行，并且能够满足所有可以想象到的情况，但可悲的现实是，我们都是人类(至少我是这么认为的)，我们都会犯错误，不存在没有错误的代码。无论我们多么小心，或者我们编写了多少自动化测试，测试同学多么仔细的覆盖，总会出现一些严重错误的情况。当涉及到用户体验时，重要的事情是预测这种可怕的现象（如白屏等），尽可能地明确展示出它，并以一种优雅的方式处理它，直到它真正被修复。</p><p>所以今天，让我们来看看<code>React</code>中的错误处理：如果发生错误，我们可以做什么，不同的错误捕捉方法有什么注意事项，以及如何减轻它们产生的影响。</p><hr><h2 id="为什么我们要捕获错误？"><a href="#为什么我们要捕获错误？" class="headerlink" title="为什么我们要捕获错误？"></a>为什么我们要捕获错误？</h2><p>但是首先，为什么在 React 中有一些错误捕捉解决方案是至关重要的?</p><p>答案很简单：从版本 16 开始，在 React 生命周期中抛出的错误如果没有停止，将导致整个应用程序自行卸载。在此之前，组件将被保留在屏幕上，即使是畸形或者错误的。但是现在（React16 之后），在 UI 的某个无关紧要的部分，甚至是一些您无法控制的外部库中，一个未捕获的错误可能会破坏整个页面，并为所有人呈现一个空白屏幕。</p><p>这是以前从来没有前端开发人员能带来的毁灭性打击 😅</p><hr><h2 id="回顾一下：如何在-Javascript-中捕捉错误"><a href="#回顾一下：如何在-Javascript-中捕捉错误" class="headerlink" title="回顾一下：如何在 Javascript 中捕捉错误"></a>回顾一下：如何在 Javascript 中捕捉错误</h2><p>当涉及到在常规 Javascript 中捕获这些令人讨厌的意外时，这些工具非常简单：</p><p>我们有一个很好的传统的<code>try/catch</code>语句，它的作用不言自明：<br>尝试<code>try</code>做一些事情，如果他们失败了 —— 捕获错误<code>catch</code>并做一些事情来处理它:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 如果这里产生了错误，会throw一个错误</span></span><br><span class="line">    <span class="title function_">doSomething</span>();</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="comment">// 如果错误发生了，catch它并做一些事情，而不停止应用程序</span></span><br><span class="line">    <span class="comment">// 就像服务端接口出点什么小问题</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这也适用于具有相同语法的 async 函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">&#x27;/jiekou&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="comment">// 接口报错啦</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者，如果我们要遵循古早的<code>promise</code>，同样也有专门针对它们的捕获方法。因此，如果我们用基于<code>promise</code>的 API 重写之前的获取示例，它将像这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">fetch</span>(<span class="string">&#x27;/jiekou&#x27;</span>).<span class="title function_">then</span>(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 接口成功返回</span></span><br><span class="line">  <span class="comment">// 做点什么处理</span></span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 接口报错，来兜兜底</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这是相同的概念，只有一些不同的实现，因此在本文的其余部分中，我将仅对所有错误使用<code>try/catch</code>语法。</p><h2 id="在-React-中-简单的-try-catch：如何做-以及-如何警告"><a href="#在-React-中-简单的-try-catch：如何做-以及-如何警告" class="headerlink" title="在 React 中 简单的 try/catch：如何做 以及 如何警告"></a>在 React 中 简单的 try/catch：如何做 以及 如何警告</h2><p>当捕获错误时，我们需要对此做些事情。那么，除了在某个地方记录它，我们还能做什么？或者，更确切地说：我们能为用户做什么？只要将它们留下一个空白屏幕或报错的界面就完全不是对用户友好的。</p><p>最明显，最直观的答案是在我们等待修复程序时渲染一些东西。幸运的是，我们可以在<code>catch</code>声明中做任何我们想做的事情，包括设置<code>state</code>。因此，我们可以做这样的事情：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">SomeComponent</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> [hasError, setHasError] = <span class="title function_">useState</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 可能在获取数据啥啥的</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">            <span class="comment">// 获取失败，没数据展示了~</span></span><br><span class="line">            <span class="title function_">setHasError</span>(<span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发生了错误 =&gt; 那就展示一些报错提示页</span></span><br><span class="line">    <span class="keyword">if</span> (hasError) <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">SomeErrorScreen</span> /&gt;</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 无事发生~ =&gt; 那就正常展示</span></span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">SomeComponentContent</span> &#123;<span class="attr">...dataSomething</span>&#125; /&gt;</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们发送一个请求，如果它失败-设置错误状态，如果<code>hasError</code>为<code>true</code>，那么我们呈现一个错误组件浮层，为用户提供一些额外的信息，如支持联系号码、联系我司 xxx。</p><p>这种方法非常直接，适用于简单、可预测和小部分的组件，如捕获失败的获取请求。但是，如果开发人员希望捕获组件中所有可能发生的错误，那么将面临一些<strong>严格的限制</strong>：</p><h3 id="限制-1：使用-useEffect-钩子会遇到麻烦。"><a href="#限制-1：使用-useEffect-钩子会遇到麻烦。" class="headerlink" title="限制 1：使用 useEffect 钩子会遇到麻烦。"></a>限制 1：使用 useEffect 钩子会遇到麻烦。</h3><p>如果我们在<code>try/catch</code>中使用<code>useEffect</code>，会完全不生效：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;妈呀错啦！&#x27;</span>);</span><br><span class="line">  &#125;, [])</span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">  <span class="comment">// useEffect 抛出错误, 这里永远不会被调用到</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之所以发生这种情况，是因为使用<code>useEffect</code>在呈现后被异步调用，因此从<code>try/catch</code>的角度来看，好像一切都会正常发生。<br>这与任何<code>Promise</code>都是一样的:如果我们不等待结果，那么 javascript 将继续它的业务，当<code>Promise</code>完成时返回它，只执行<code>useEffect</code>(或<code>Promise</code>的)内部的内容。<code>try /catch</code>块将被执行，并且在那时早就消失了。</p><p>所以为了捕捉<code>useEffect</code>中的错误，<code>try/catch</code>也应该放在里面：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line">   <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;妈呀错啦！&#x27;</span>);</span><br><span class="line"> &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">   <span class="comment">// 这就能捕获到了</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;, [])</span><br></pre></td></tr></table></figure><p><a href="https://codesandbox.io/embed/try-catch-and-useeffect-28h3ux?file=/src/App.tsx?codemirror=1&hidedevtools=0&view=preview">玩一下这个例子，戳戳</a></p><p>这适用于任何使用<code>useEffect</code>的<code>hook</code>或任何异步的东西。因此，不是仅仅一个<code>try/catch</code>就可以包装所有内容，而是必须将其分割成多个块：每个<code>hook</code>一个。</p><h3 id="限制-2：子组件"><a href="#限制-2：子组件" class="headerlink" title="限制 2：子组件"></a>限制 2：子组件</h3><p><code>try / catch</code>将无法捕获子组件内发生的任何事情。<br>你不能这样做:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">Component</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> child;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    child = <span class="language-xml"><span class="tag">&lt;<span class="name">Child</span> /&gt;</span></span></span><br><span class="line">  &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">    <span class="comment">// 对于捕获子组件内的错误无用，不会被触发</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> child;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 或者这样也不行</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Component</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Child</span> /&gt;</span></span></span><br><span class="line">  &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">    <span class="comment">// 对于捕获子组件内的错误还是无用，不会被触发</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://codesandbox.io/embed/try-catch-for-children-doesnt-work-5elto1?file=/src/App.tsx?codemirror=1&hidedevtools=0&view=preview">玩一下这个例子，戳戳</a></p><p>这是因为当我们写入<code>&lt;Child /&gt;</code>时，我们实际上并没有呈现这个组件。我们正在做的是创建一个<code>Component Element</code>，它只不过是一个组件的定义，只是一个包含必要信息的对象，如组件<code>type</code>和<code>props</code>，这些信息稍后将被 React 本身使用(指触发该组件的渲染)。它会在<code>try/catch</code> block 成功执行后发生，与<code>promises</code>和<code>useEffect hook</code>的情况完全相同。</p><p>如果想了解更详细的元素和组件是如何工作的，下面是这篇文章的链接：<a href="https://www.developerway.com/posts/react-elements-children-parents">The mystery of React Element, children, parents and re-renders</a></p><h3 id="限制-3：在-Render-期间-setting-state-是不允许的"><a href="#限制-3：在-Render-期间-setting-state-是不允许的" class="headerlink" title="限制 3：在 Render 期间 setting state 是不允许的"></a>限制 3：在 Render 期间 setting state 是不允许的</h3><p>如果你试图捕获<code>useEffect</code>和各种回调之外的错误(即在组件的渲染期间)，那么正确地处理它们不再那么简单：<code>render</code>期间不允许状态更新。</p><p>例如，如果发生错误，像这样的简单代码只会导致重新渲染的无限循环：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">Component</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> [hasError, setHasError] = <span class="title function_">useState</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="title function_">doSomethingWrong</span>();</span><br><span class="line">  &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">    <span class="comment">// 这么做就会出现死循环哦</span></span><br><span class="line">    <span class="comment">// 不信的话，下面就可以试试</span></span><br><span class="line">    <span class="title function_">setHasError</span>(<span class="literal">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>i&#x27;m good<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://codesandbox.io/s/vibrant-wilbur-02c4fc?file=/src/App.tsx">试试就逝世</a></p><p>当然，我们可以在这里返回错误组件，而不是设置状态：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">Component</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="title function_">doSomethingWrong</span>();</span><br><span class="line">  &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">    <span class="comment">// 这是木有问题的</span></span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">SomeErrorScreen</span> /&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，正如大家感觉的那样，这有点麻烦，并且将迫使我们以不同的方式处理同一个组件中的错误：<code>useEffect</code>的状态、<code>callback</code>，以及直接返回其他的所有内容。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 虽然它可以工作，但它非常麻烦，很难维护，不推荐这么写</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">SomeComponent</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> [hasError, setHasError] = <span class="title function_">useState</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 处理一些逻辑，如 发送请求</span></span><br><span class="line">    &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">      <span class="comment">// 不能只是在useEffect或回调错误的情况下返回</span></span><br><span class="line">      <span class="comment">// 所以必须使用state</span></span><br><span class="line">      <span class="title function_">setHasError</span>(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 渲染时候的一些逻辑</span></span><br><span class="line">  &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">    <span class="comment">// 但这里我们不能使用state，所以必须直接返回一些组件以防出现错误</span></span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">SomeErrorScreen</span> /&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在错误状态的情况下仍然需要返回</span></span><br><span class="line">  <span class="keyword">if</span> (hasError) <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">SomeErrorScreen</span> /&gt;</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">SomeComponentContent</span> &#123;<span class="attr">...dataSomething</span>&#125; /&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结一下：如果我们在 React 中仅仅依赖<code>try/catch</code>，我们要么会错过大部分错误，要么会把每个组件都变成一堆无法理解的代码，这些代码本身可能会导致错误。</p><p>幸运的是，还有另一种方法。</p><h2 id="React-ErrorBoundary-组件"><a href="#React-ErrorBoundary-组件" class="headerlink" title="React ErrorBoundary 组件"></a>React ErrorBoundary 组件</h2><p>为了减轻上述限制，React 为我们提供了所谓的“错误边界”：一个特殊的 API，以某种方式将常规组件转换为<code>try/catch</code>语句，仅适用于 React 声明性代码。你可以在每个例子中看到的典型用法，包括 React 文档，是这样的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">Component</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">ErrorBoundary</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">SomeChildComponent</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">AnotherChildComponent</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">ErrorBoundary</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，如果这些组件或它们的子组件在<code>render</code>期间出现错误，错误将被捕获并处理。</p><p>但是 React 并没有给我们组件本身，它只是给了我们一个实现它的工具。最简单的实现是这样的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ErrorBoundary</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line">    <span class="comment">// 初始化错误状态</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123; <span class="attr">hasError</span>: <span class="literal">false</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 有错误发生则转换状态</span></span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">getDerivedStateFromError</span>(<span class="params">error</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">hasError</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 如果错误发生了，返回一个 fallback component</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">hasError</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;&gt;</span>哎妈呀吗，组件出错了!<span class="tag">&lt;/&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">children</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们创建一个常规的类组件(这里是老式的写法，没有用于<code>ErrorBoundary</code>的钩子)，并实现<code>getDerivedStateFromError</code>方法：它将组件转换为适当的<code>ErrorBoundary</code>。</p><p>处理错误时要做的另一件重要的事情是将错误信息发送到可以提醒到开发人员的地方。为此，错误边界提供了<code>componentDidCatch</code>方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ErrorBoundary</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="comment">// 其他都一样</span></span><br><span class="line"></span><br><span class="line">  <span class="title function_">componentDidCatch</span>(<span class="params">error, errorInfo</span>) &#123;</span><br><span class="line">    <span class="comment">// 这里向外暴露错误</span></span><br><span class="line">    <span class="title function_">log</span>(error, errorInfo);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在设置了<code>ErrorBoundary</code>之后，我们可以对它做任何我们想做的事情，就像任何其他组件一样。例如，我们可以使它更具可复用性，并将<code>fallback</code>作为<code>props</code>传递：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 如果又错误发生，返回 fallback component</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">hasError</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">fallback</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">children</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用法如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">Component</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">ErrorBoundary</span> <span class="attr">fallback</span>=<span class="string">&#123;</span>&lt;&gt;</span>艾玛，组件出错了!<span class="tag">&lt;/&gt;</span></span>&#125;&gt;</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">SomeChildComponent</span> /&gt;</span></span></span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">AnotherChildComponent</span> /&gt;</span></span></span><br><span class="line">    &lt;/<span class="title class_">ErrorBoundary</span>&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者加上我们可能需要的任何其他东西，比如：</p><ul><li>重置单击按钮时的状态；</li><li>区分错误类型；</li><li>将错误推到某个上下文。</li></ul><p><a href="https://codesandbox.io/embed/simple-error-boundary-component-4ldsun?file=/src/App.tsx?codemirror=1&hidedevtools=0&view=preview">看看大概的例子</a></p><p>不过，在这个捕获错误自由的世界中有一个问题：它不能捕获所有内容。</p><h2 id="ErrorBoundary-组件的限制"><a href="#ErrorBoundary-组件的限制" class="headerlink" title="ErrorBoundary 组件的限制"></a>ErrorBoundary 组件的限制</h2><p><code>ErrorBoundary</code>只捕捉 React 生命周期中发生的错误。发生在它之外的事情，如<code>Promise</code>的<code>resolve</code>，带 setTimeout 的异步代码，各种回调和事件处理程序，如果不显式地处理，就会被彻底忽略。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">Component</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 这个报错会被 ErrorBoundary component 捕获</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Destroy everything!&#x27;</span>);</span><br><span class="line">  &#125;, [])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">onClick</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 但是这个没了就没了</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;我自由了！&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 如果这个接口失败了，也不会被发现</span></span><br><span class="line">    <span class="title function_">fetch</span>(<span class="string">&#x27;/jiekou&#x27;</span>)</span><br><span class="line">  &#125;, [])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;onClick&#125;</span>&gt;</span>点我<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">ComponentWithBoundary</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">ErrorBoundary</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Component</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">ErrorBoundary</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里常见的建议是使用常规的<code>try/catch</code>来处理这类错误。至少在这里我们可以安全地使用 state：事件处理程序的回调正是我们通常<code>setting state</code>的地方。所以从技术上讲，我们可以把两种方法结合起来，做这样的事情：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">Component</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> [hasError, setHasError] = <span class="title function_">useState</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这个组件和子组件中的大多数错误都将被ErrorBoundary捕获</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">onClick</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 这个会被catch捕获</span></span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;我不自由了!&#x27;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">      <span class="title function_">setHasError</span>(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (hasError) <span class="keyword">return</span> <span class="string">&#x27;something went wrong&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;onClick&#125;</span>&gt;</span>点我<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">ComponentWithBoundary</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">ErrorBoundary</span> <span class="attr">fallback</span>=<span class="string">&#123;</span>&quot;<span class="attr">艾玛粗戳了</span>！&quot;&#125;&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Component</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">ErrorBoundary</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，我们又回到了原点：每个组件都需要保持它的“错误”状态？更重要的是，怎么决定如何处理它。</p><p>当然，我们可以不在组件级别上处理这些错误，只是通过<code>props</code>或<code>Context</code>将它们传递到具有<code>ErrorBoundary</code>的父类,这样至少我们可以在一个地方有一个“<code>fallback</code>”组件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">Component</span> = (<span class="params">&#123; onError &#125;</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">onClick</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;坏了坏了!&#x27;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">      <span class="comment">// 这里就调用props，而不需要自己维护一个state</span></span><br><span class="line">      <span class="title function_">onError</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;onClick&#125;</span>&gt;</span>点我<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">ComponentWithBoundary</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> [hasError, setHasError] = <span class="title function_">useState</span>();</span><br><span class="line">  <span class="keyword">const</span> fallback = <span class="string">&quot;艾玛！出错了呀！&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (hasError) <span class="keyword">return</span> fallback;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">ErrorBoundary</span> <span class="attr">fallback</span>=<span class="string">&#123;fallback&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Component</span> <span class="attr">onError</span>=<span class="string">&#123;()</span> =&gt;</span> setHasError(true)&#125; /&gt;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">ErrorBoundary</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是！但是它有太多额外的代码！我们必须对渲染树中的每个子组件都这样做，更不用说我们现在基本上在维护两个错误状态：</p><ul><li>在父组件中；</li><li>在 ErrorBoundary 本身中。</li></ul><p><code>ErrorBoundary</code>已经有了所有的机制来将错误传播到树上，我们在这里做了双重工作。<br>难道我们不能用<code>ErrorBoundary</code>从异步代码和事件处理程序中捕获这些错误吗?</p><h2 id="使用-ErrorBoundary-捕获异步错误"><a href="#使用-ErrorBoundary-捕获异步错误" class="headerlink" title="使用 ErrorBoundary 捕获异步错误"></a>使用 ErrorBoundary 捕获异步错误</h2><p>有趣的是，我们可以用<code>ErrorBoundary</code>来捕获它们!国外大佬 Dan Abramov 分享了一个很酷的 hack 来实现这一点：<a href="https://github.com/facebook/react/issues/14981#issuecomment-468460187"> Throwing Error from hook not caught in error boundary · Issue #14981 · facebook/react.</a>。</p><p>这里的技巧是先用<code>try/catch</code>捕获这些错误，然后在<code>catch</code>语句中触发正常的<code>React re-render</code>，然后重新将这些错误扔回<code>re-render</code>生命周期。这样<code>ErrorBoundary</code>就可以像捕获其他错误一样捕获它们。由于状态更新是触发重新呈现的方式，而<a href="https://beta.reactjs.org/reference/react/useState#updating-state-based-on-the-previous-state"><code>state set函数</code>实际上可以接受一个<code>updater函数</code>作为参数</a>，解决方案真的让人喊一声大佬牛*：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">Component</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">// create some random state that we&#x27;ll use to throw errors</span></span><br><span class="line">  <span class="keyword">const</span> [state, setState] = <span class="title function_">useState</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">onClick</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// something bad happened</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="comment">// trigger state update, with updater function as an argument</span></span><br><span class="line">      <span class="title function_">setState</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// re-throw this error within the updater function</span></span><br><span class="line">        <span class="comment">// it will be triggered during state update</span></span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://codesandbox.io/embed/simple-async-error-in-error-boundary-r8l22g?file=/src/App.tsx?codemirror=1&hidedevtools=0&view=preview">省流版示例，戳戳</a></p><p>这里的最后一步是将<code>hack</code>抽象出来，这样我们就不必在每个组件中创建<code>state</code>。我们可以在这里发挥创意，创建一个<code>hook</code>，作为一个异步错误抛出器：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">useThrowAsyncError</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> [state, setState] = <span class="title function_">useState</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">setState</span>(<span class="function">() =&gt;</span> <span class="keyword">throw</span> error)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用法如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">Component</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> throwAsyncError = <span class="title function_">useThrowAsyncError</span>();</span><br><span class="line"></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">fetch</span>(<span class="string">&#x27;/jieou&#x27;</span>).<span class="title function_">then</span>().<span class="title function_">catch</span>(<span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 异步抛出错误</span></span><br><span class="line">      <span class="title function_">throwAsyncError</span>(e)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者，我们可以像这样包裹一下回调：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">useCallbackWithErrorHandling</span> = (<span class="params">callback</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> [state, setState] = <span class="title function_">useState</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="title function_">callback</span>(...args);</span><br><span class="line">    &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">      <span class="title function_">setState</span>(<span class="function">() =&gt;</span> <span class="keyword">throw</span> e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的用法如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">Component</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">onClick</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 触发一个报错</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;毁灭吧！&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> onClickWithErrorHandler = <span class="title function_">useCallbackWithErrorHandling</span>(onClick);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;onClickWithErrorHandler&#125;</span>&gt;</span>点我!<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者任何你内心想要的和 app 要求的东西，没有限制!<br>我从事前端这么多年<br>我写 bug 赔了这么多钱<br>不就……<br>就不会再有错误了。</p><p><a href="https://codesandbox.io/s/fzg5zv">完整例子在这，戳戳</a></p><h2 id="能用-react-error-boundary-代替吗"><a href="#能用-react-error-boundary-代替吗" class="headerlink" title="能用 react-error-boundary 代替吗?"></a>能用 react-error-boundary 代替吗?</h2><p>对于那些讨厌重新发明轮子或者只是喜欢用库来解决已经解决的问题的人来说，有一个很好的实现了一个灵活的<code>ErrorBoundary</code>组件，并有一些类似于上面描述的有用的 utils：<a href="https://github.com/bvaughn/react-error-boundary">GitHub - bvaughn/react-error-boundary</a><br>是否使用它只是个人偏好、编码风格和组件中的独特情况的问题。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>写代码就是为了优雅，这篇文章希望对大家处理 Error 的时候能有所帮助。<br>省流小知识点：</p><ul><li><code>try/catch</code>块不会捕获<code>useEffect</code>等钩子和任何子组件内部的错误</li><li><code>ErrorBoundary</code>可以捕获它们，但它不会捕获<strong>异步代码</strong>和<strong>事件处理程序中</strong>的错误</li><li>尽管如此，你可以让<code>ErrorBoundary</code>捕获它们，你只需要先用<code>try/catch</code>捕获它们，然后<strong>重新</strong>将它们扔回 React 生命周期</li></ul><p>希望永无事件发生！</p>]]></content>
      
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《React Query 笔记》</title>
      <link href="/2023/03/07/%E3%80%8AReact%20Query%20%E7%AC%94%E8%AE%B0%E3%80%8B/"/>
      <url>/2023/03/07/%E3%80%8AReact%20Query%20%E7%AC%94%E8%AE%B0%E3%80%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="《React-Query-笔记》"><a href="#《React-Query-笔记》" class="headerlink" title="《React Query 笔记》"></a>《React Query 笔记》</h1><h3 id="要开始做请求方案的调研，第一个深入看的是-React-Query（下面简称为-RQ）。本文是-Practical-React-Query-TkDodo’s-blog-系列文章的阅读笔记。"><a href="#要开始做请求方案的调研，第一个深入看的是-React-Query（下面简称为-RQ）。本文是-Practical-React-Query-TkDodo’s-blog-系列文章的阅读笔记。" class="headerlink" title="要开始做请求方案的调研，第一个深入看的是 React Query（下面简称为 RQ）。本文是 Practical React Query | TkDodo’s blog 系列文章的阅读笔记。"></a>要开始做请求方案的调研，第一个深入看的是 React Query（下面简称为 RQ）。本文是 Practical React Query | TkDodo’s blog 系列文章的阅读笔记。</h3><h2 id="1-为啥很多人会认为-apollo-会取代-redux？"><a href="#1-为啥很多人会认为-apollo-会取代-redux？" class="headerlink" title="1. 为啥很多人会认为 apollo 会取代 redux？"></a>1. 为啥很多人会认为 apollo 会取代 redux？</h2><p><code>apollo</code> 是请求方案，而 <code>redux</code> 是全局状态库，看起来八竿子打不着，但如果我们能在客户端通过缓存的方式访问服务端的数据，那对于 80% 的应用来说，剩下需要处理的客户端状态其实很少。所以，<code>apollo</code> 会取代 <code>redux</code> 吗？It Depends。而 <code>apollo</code> 是处理 <code>graphql</code> 的，RQ 则把 apollo 的很多功能带到了 restful 的 api 场景（且不限于此）。</p><h2 id="2-一些文档外的使用技巧"><a href="#2-一些文档外的使用技巧" class="headerlink" title="2. 一些文档外的使用技巧"></a>2. 一些文档外的使用技巧</h2><ol><li>默认值的选择很好，但对于新手用户也会有时不时的措手不及，需要理解他们，</li><li>使用 <strong>React Query DevTools</strong>，会告诉你缓存的数据状态，同时也要结合 <strong>Chrome DevTool</strong> 的网络面板，因为开发模式请求通常比较快，</li><li>把 <code>query key</code> 当 <code>useEffect</code> 的依赖数组使用，两者非常相似，</li><li>通过传入 <code>initialData</code> 可以让切换状态时先用缓存中的数据做预填充，提升用户体验，比如 todo app 的 <code>filter</code> 从全部切换到完成时的场景，</li><li>保持服务端和客户端状态分离，<code>useQuery()</code> 得到的数据不要存本地 copy，以避免拿到老数据，</li><li><code>enable</code> 配置项非常强大，可以做很多事，比如依赖另一个查询的数据、modal 打开时关闭数据轮询、等待用户输入时禁用、用户输入信息后禁用默认数据的查询等，</li><li>不要尝试通过 <code>queryClient.setQueryData</code> 修改 <code>query cache</code> 使他成为本地状态管理器，因为每次后台重新获取都可能覆盖他们，</li><li>把 <code>useQuery</code> 包起来用会有额外好处，比如 ui 和逻辑分离等。</li></ol><h2 id="3-如果后端没有返回期望的数据格式，那就需要做格式化了。这时有多个选择，"><a href="#3-如果后端没有返回期望的数据格式，那就需要做格式化了。这时有多个选择，" class="headerlink" title="3. 如果后端没有返回期望的数据格式，那就需要做格式化了。这时有多个选择，"></a>3. 如果后端没有返回期望的数据格式，那就需要做格式化了。这时有多个选择，</h2><ol><li>后端转，缺点是不一定能实现，</li><li><code>queryFn</code> 里转，缺点是每次 fetch 时需要跑一遍，同时如果你有一个不能自由修改的 service 层可能行不通（不能通过 openapi 生成的），</li><li><code>render</code> 函数中转，缺点是语法复杂，需借助 useMemo 提升性能，同时数据可能 undefined，</li><li>用 <code>select option</code> 转，没啥明显缺点。所以，相对来说，方案 4 会更好，最佳优化（调用次数最少）、同时允许部分订阅。</li></ol><h2 id="4-RQ-内置了一些渲染优化的能力。"><a href="#4-RQ-内置了一些渲染优化的能力。" class="headerlink" title="4. RQ 内置了一些渲染优化的能力。"></a>4. RQ 内置了一些渲染优化的能力。</h2><ol><li><code>notifyOnChangeProps</code> 配置，从版本 4 起默认开启 <code>track</code> 模式，跟踪你使用了哪些 <code>props</code>，然后只在这些 <code>props</code> 变更后做 <code>notify</code>，可选配置是 <code>all</code> 或 <code>String 数组</code>，选 <code>String 数组</code> 要注意 <code>props</code> 的同步手动更新，避免出现该渲染没渲染然后使用过期数据的问题，</li><li>RQ 做了结构共享，比如 <code>[&#123;id:1,text:1&#125;,&#123;id:2,text:2&#125;]</code>，如果更新数据后只变更了 id 1，那通过 <code>useItems(/*id*/2)</code> 拿的数据会保持引用一致性，不会 notify 更新，详见 replaceEqualDeep 的测试。。</li></ol><h2 id="5-RQ-有-3-种状态"><a href="#5-RQ-有-3-种状态" class="headerlink" title="5. RQ 有 3 种状态:"></a>5. RQ 有 3 种状态:</h2><p><code>success</code>、<code>error</code> 和 <code>loading</code>（idle 在版本 4 里去掉了），以及另一个维度的 <code>isFetching</code>。<br>应该是怎样的状态检测顺序？通常大家会写 <code>loading</code>、<code>error</code>、<code>data</code>（即 success）这样的顺序，但这在 refetch 时，会导致的问题是，loading 或 error 状态时看不到数据。所以更推荐的判断顺序是 data、error、loading。</p><h2 id="6-如何做测试？"><a href="#6-如何做测试？" class="headerlink" title="6. 如何做测试？"></a>6. 如何做测试？</h2><p>这里有个例子这里有个例子。</p><ol><li>不要 <code>mock fetch</code>，用 MSW，</li><li>给每个测试一个 <code>QueryClientProvider</code> 并创建新的 <code>QueryClient</code>，好处是完全隔离（备选方案是每次测试完清 QueryClient 的缓存，缺点是并行运行测试时可能会出错），</li><li>自定义 hook 用 react-hooks-testing-library 做测试，</li><li>测试使用 <code>useQuery</code> 的组件时记得用 <code>QueryClientProvider</code> 包一下，参考 <code>react-query</code> 内部的测试用例，</li><li>设置 <code>retry</code> 为 <code>false</code>，否则可能会因为默认要做 3 次 <code>exponential backoff</code> 重试而导致超时，同时注意不要在 <code>useQuery</code> 里写死 <code>retry</code> 参数，改用 <code>queryClient.setQueryDefaults(&#39;todos&#39;, &#123; retry: 5 &#125;)</code> 会对测试更友好，</li><li>由于 <code>useQuery</code> 是异步的，记得要加 <code>await waitFor(() =&gt; result.current.isSuccess)</code> 等待请求完成，</li><li>如果命令行有太多日志，可以通过设置 <code>QueryClient</code> 的 <code>logger</code> 参数避免冗余报错，<code>logger: &#123; error: () =&gt; &#123;&#125;, log: console.log, warn: console.warn: console.warn &#125;</code></li></ol><h2 id="7-关于类型。"><a href="#7-关于类型。" class="headerlink" title="7. 关于类型。"></a>7. 关于类型。</h2><ol><li><code>useQuery</code> 有两种写法，泛型和类型推导，推荐后者，让 <code>queryFn</code> 返回正确的类型，剩下的全部走推导，注意这里会缺 <code>error</code> 的类型，写的时候可以用 <code>error instanceof Error</code> 确保下，</li><li><code>useQuery</code> 加上 <code>enabled</code> 参数时就可能是 undefined 了，需在 <code>queryFn</code> 里处理 undefined 时抛错，</li><li>使用 <code>useInfiniteQuery</code> 时记得给 <code>queryFn</code> 的 <code>pageParam</code> 加类型，</li><li>使用 <code>default queryFn</code> 时要注意 <code>queryKey</code> 的参数类型。</li></ol><h2 id="8-RQ-WebSocket-有两种用法。"><a href="#8-RQ-WebSocket-有两种用法。" class="headerlink" title="8. RQ + WebSocket 有两种用法。"></a>8. RQ + WebSocket 有两种用法。</h2><ol><li><p>推模式，服务端推送数据，客户端通过 <code>queryClient.setQueriesData</code> 更新数据，缺点是推送了并不需要的数据，比如你并不在需要数据的那个页面，</p></li><li><p>拉模式，服务端只发送事件，告知客户端哪些数据更新了，然后客户端通过 <code>queryClient.invalidateQueries</code> 让那些请求缓存失效，在需要的时候再去服务端拉数据。</p><p> ※个人建议无脑用第二种。同时要注意修改 <code>staleTime</code> 为 <code>Infinity</code>，WebSocket 会保证本地数据是最新的，无需通过 <code>staleTime</code> 设置过期时间。</p></li></ol><h2 id="9-query-key-应该如何组织？"><a href="#9-query-key-应该如何组织？" class="headerlink" title="9. query key 应该如何组织？"></a>9. query key 应该如何组织？</h2><h3 id="一些背景知识："><a href="#一些背景知识：" class="headerlink" title="一些背景知识："></a>一些背景知识：</h3><ol><li><code>useQuery</code> 和 <code>useInfiniteQuery</code> 共享同一个缓存，所以 key 不能重复，</li><li>重新获取不同参数的数据时，不能用 <code>refetch(xxx)</code>，<code>refetch</code> 不能重新获取相同 key 的数据，解法是给 <code>useQuery</code> 传不同的 key，</li><li>与查询缓存交互有多种方法，比如 <code>invalidateQueries</code> 和 <code>setQueriesData</code> 等。</li></ol><h3 id="那么如何高效地组织-query-key？"><a href="#那么如何高效地组织-query-key？" class="headerlink" title="那么如何高效地组织 query key？"></a>那么如何高效地组织 query key？</h3><ol><li>用比如 <code>[&#39;todos&#39;, &#39;list&#39;, &#123; filter: &#39;all&#39; &#125;]</code> 这样的结构，好处是在 <code>invalidate</code> 或突变操作时会更灵活，比如同时操作所有的 <code>todos &gt; list</code>，</li><li>使用 <code>query key factory</code>，避免手写容易导致的错误，比如 <code>todoKeys.all</code>、<code>todoKeys.detail(id)</code> 。</li></ol><h2 id="10-和-query-key-相关的是，queryFn-应该怎么写？"><a href="#10-和-query-key-相关的是，queryFn-应该怎么写？" class="headerlink" title="10. 和 query key 相关的是，queryFn 应该怎么写？"></a>10. 和 query key 相关的是，queryFn 应该怎么写？</h2><ol><li>内联，比如 <code>useQuery([&#39;todos&#39;, p1, p2], () =&gt; fetchXXX(p1, p2))</code>，缺点是 <code>key</code> 和 <code>fn</code> 里的参数必须同步更新，一旦遗漏比如忘记更新 <code>key</code> 里的参数，会导致请求数据不刷新，</li><li><code>QueryFunctionContext</code>，比如</li></ol><figure class="highlight plaintext"><figcaption><span>p1, p2]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(&#123; queryKey &#125;) =&gt; fetchXXX(queryKey[1], queryKey[2]))</span><br></pre></td></tr></table></figure><p>，只只需维护 <code>query key</code> 里的参数即可，缺点是内联函数才有类型，同时 <code>queryKey</code> 是数组格式，前面几项通常会用不到， 3. 在 2 的基础上，支持独立函数，<code>QueryFunctionContext&lt;ReturnType&lt;typeof queryKey&gt;&gt;</code>， 4. 在 3 的基础上，把 <code>key</code> 由数组改成 <code>object</code>，比如 <code>useQuery(&#123; scope: &#39;todos&#39;, entity: &#39;list&#39;, state, sorting &#125;, fn)</code> ，看起来是目前最完美的版本，类型也安全。</p><h2 id="11-RQ-预填充缓存数据有两种方法"><a href="#11-RQ-预填充缓存数据有两种方法" class="headerlink" title="11. RQ 预填充缓存数据有两种方法"></a>11. RQ 预填充缓存数据有两种方法</h2><p><code>placeholderData</code> 和 <code>initialData</code>。</p><h3 id="相同的是"><a href="#相同的是" class="headerlink" title="相同的是:"></a>相同的是:</h3><ol><li>都会直接跳过 <code>loading</code> 状态进入 <code>success</code> 状态，</li><li>都支持值或者返回值的函数两种类型。</li></ol><h3 id="不同的是"><a href="#不同的是" class="headerlink" title="不同的是:"></a>不同的是:</h3><ol><li><code>initialData</code> 在缓存层处理，直接放入缓存，尊重 <code>staleTime</code>，一个 <code>query key</code> 只能由一个 <code>initialData</code>，<code>refetch</code> 错误时数据还在，</li><li><code>placeholderData</code> 在观察者层处理，不放入缓存，用于临时占位，可以为相同的 <code>query key</code> 创建多个不同的 <code>placeholderData</code>，<code>refetch</code> 错误时数据消失。</li></ol><h2 id="12-RN-是啥？"><a href="#12-RN-是啥？" class="headerlink" title="12. RN 是啥？"></a>12. RN 是啥？</h2><p>他不是请求库，因为不内置 axios、fetch 之类的；他是异步的状态管理器，或者是服务端状态的同步工具。<br>在 RN 之前，通常有两种数据获取的方法:</p><ol><li>一次获取、全局分发、很少更新;</li><li>每次获取（比如每次 modal 打开时都请求一遍数据）。这两种都不太好，前者更新太少，后者更新太多。RN 通过 <code>Stale While Revalidate</code> 和机制的 <code>refetch</code> 机制来解这个问题。<code>refetch</code> 触发时机包括 <code>refetchOnMount</code>、<code>refetchOnWindowFocus</code>、<code>refetchOnReconnect</code>，以及手动的 <code>queryClient.invalidateQueries</code>。同时可针对不同场景设置不同的 staleTime 来控制 refetch 频率。</li></ol><h2 id="13-RN-处理错误有-3-种方法。"><a href="#13-RN-处理错误有-3-种方法。" class="headerlink" title="13. RN 处理错误有 3 种方法。"></a>13. RN 处理错误有 3 种方法。</h2><ol><li><code>useQuery</code> 返回值的 <code>isError</code> 或 <code>status === &#39;error&#39;</code> 判断;</li><li><code>onError</code> 回调，可以是 <code>query</code> 级，也可以是全局用 <code>queryCache</code> 配，<code>query</code> 级的要当心避免多次触发;</li><li>基于 <code>Error Boundary</code>，配置 <code>useErrorBoundary:true</code> 即可。</li></ol><p>三种方法可以搭配使用，作者建议针对 refetch 错误用全局 onError + toast 显示，其他的用 1 或 3 的方法处理。另外，如果有 fetch，要在 queryFn 里处理 4xx 和 5xx 请求，他不像 axios 一样会 reject。</p><h2 id="14-RN-通过-useMutation-实现突变（更新数据）。"><a href="#14-RN-通过-useMutation-实现突变（更新数据）。" class="headerlink" title="14. RN 通过 useMutation 实现突变（更新数据）。"></a>14. RN 通过 useMutation 实现突变（更新数据）。</h2><p>和 <code>useQuery</code> 相同的是都会提供 <code>loading</code>、<code>error</code>、<code>status</code> 数据，也支持 <code>onSuccess</code>、<code>onError</code> 和 <code>onSettled</code> 回调。和 <code>useQuery</code> 不同的是，<code>useQuery</code> 是声明式，而 <code>useMutation</code> 是命令式，同时 <code>useMutation</code> 也不会共享状态。突变后要更新数据有三种思路，</p><ol><li><code>invalidate query</code> 让他 <code>refetch</code>，注意只有活跃的 <code>query</code> 会 <code>refetch</code>;</li><li>通过 <code>queryClient.setQueryData</code> 直接更新，适用于知道全部数据的场景，但可能不安全，比如遇到排序、新增后新 id 数据时会变得很复杂;</li><li>乐观更新，适用于小交互。一些常见问题:</li></ol><ul><li><code>onSuccess</code> 回调支持 <code>Promise</code>，适用于比如你需要在 <code>invalidate</code> 操作完成前保持 <code>useMutation</code> 的 <code>loading</code> 状态时;</li><li><code>useMutation</code> 有 <code>mutate</code> 和 <code>mutateAsync</code> 两个方法，通常更推荐 <code>mutate</code>，因为 <code>mutateAsync</code> 要自行 <code>try...catch</code> 处理异常场景，<code>mutateAsync</code> 的场景是有多个并行或串行依赖性突变时;</li><li><code>useMutation fn</code> 只支持一个参数，可以用 <code>Object</code>;</li><li><code>useMutation</code> 和 <code>mutation</code> 都有回调，前者肯定会执行，适用于逻辑，后者组件销毁后不执行，适用于 UI。</li></ul><h2 id="15-关于离线。"><a href="#15-关于离线。" class="headerlink" title="15. 关于离线。"></a>15. 关于离线。</h2><ol><li>有一个 <code>networkMode</code> 设置，可以选择三种模式:</li></ol><ul><li><code>online</code>（默认模式，假设有网络时才能用，没网络会进入暂停状态）</li><li><code>always</code>（不关心网络状态，永远会启用查询，适用于数据获取以外的事）</li><li><code>offlineFirst</code>（总是会发出第一个请求，失败时进入暂停状态），</li></ul><ol start="2"><li><code>useQuery()</code> 会返回 <code>fetchStatus</code>，包括 <code>fetching</code>、<code>paused</code>、<code>idle</code> 三种状态，可以和 <code>status</code> 结合使用，两者<strong>不互斥</strong>。</li></ol><h2 id="16-关于表单。"><a href="#16-关于表单。" class="headerlink" title="16. 关于表单。"></a>16. 关于表单。</h2><ol><li>作者推荐了 <code>react-hook-form</code> 和 RN 搭配使用，</li><li>最简方案是 <code>useQuery</code> 请求数据作为默认值然后 <code>useMutation</code> 突变更新，但存在两个问题，<code>data</code> 可能为空和没有后台更新，<code>data</code> 可能为空壳通过提取组件的方式解，没有后台更新可通过受控组件+优先用受控组件的值的方式解，</li><li>防止重复提交可基于 <code>useMutation()</code> 返回的 <code>isLoading</code>，给提交按钮加 <code>disabled=&#123;isLoading&#125;</code> 来解，</li><li>如果提交后没有跳转到其他页面，通常需要在 <code>mutate</code> 之后 <code>invalidate query</code>（更新数据）并 reset 表单。</li></ol><h2 id="17-RQ-和-React-Router（简称-RR）6-4-的关系。"><a href="#17-RQ-和-React-Router（简称-RR）6-4-的关系。" class="headerlink" title="17. RQ 和 React Router（简称 RR）6.4 的关系。"></a>17. RQ 和 React Router（简称 RR）6.4 的关系。</h2><ol><li>RR 没有做 <code>cache</code> 而 RQ 有，RR 是关于 when（时机）而 RQ 是关于 what（具体请求方案）;</li><li>只有 RR 可以做到提前获取，但问题是由于没有缓存从而会到请求过于频繁;</li><li>RQ 和 RR 可结合使用，在 <code>loader</code> 里通过 <code>queryClient.fetchQuery</code> 发起请求，组件里用 <code>useQuery</code> 正常拿数据即可，出于 ts 类型考虑默认值可以填 <code>useLoaderData</code> 的数据;</li><li>如果用 RR 的 <code>action</code> 做突变，<code>redirect</code> 之前记得 <code>invalidate</code> 相关的 <code>query</code>，同时 <code>invalidate</code> 可以根据场景选择是否 <code>await</code>。</li></ol><h2 id="18-关于请求瀑布流。"><a href="#18-关于请求瀑布流。" class="headerlink" title="18. 关于请求瀑布流。"></a>18. 关于请求瀑布流。</h2><ol><li>依赖类 <code>query</code> 的瀑布流是避免不了的，比如 <code>/user/1/project</code> 依赖 <code>/user</code> 的数据，非依赖的写多个 <code>useQuery</code> 或者用 <code>useQueries</code> 解效果相同;</li><li><code>Suspense</code> 会在 <code>Promise</code> 为 <code>pending</code> 状态时用 <code>fallback</code> 渲染，缺点是 <code>fallback</code> 时间过长从而影响渲染，渲染迟了进而影响子组件的数据请求，从而导致瀑布流;</li><li><code>queryClient.prefetchQuery</code> 可以缓解这个问题，一种用法是放在组件外，可以在代码下载解析时即执行;</li><li><code>useQueries</code> 暂不支持 <code>suspense</code>;</li><li>如果列表页包含详情页的所有数据，可以用列表页缓存的数据填充详情页缓存，这里也分拉和推两种方式。</li></ol><h2 id="FAQ。"><a href="#FAQ。" class="headerlink" title="FAQ。"></a>FAQ。</h2><h3 id="1-如何给-refetch-传递参数？"><a href="#1-如何给-refetch-传递参数？" class="headerlink" title="1. 如何给 refetch 传递参数？"></a>1. 如何给 <code>refetch</code> 传递参数？</h3><p>不能传递。</p><h3 id="2-如何做同一个-useQuery-但-key-变更时的过渡？"><a href="#2-如何做同一个-useQuery-但-key-变更时的过渡？" class="headerlink" title="2. 如何做同一个 useQuery 但 key 变更时的过渡？"></a>2. 如何做同一个 <code>useQuery</code> 但 <code>key</code> 变更时的过渡？</h3><p>用 <code>placeholderData</code> 或者配置 <code>keepPreviousData: true</code> 保留之前的数据</p><h3 id="3-为啥没有更新？"><a href="#3-为啥没有更新？" class="headerlink" title="3. 为啥没有更新？"></a>3. 为啥没有更新？</h3><p>query key 不匹配（比如 1 和 ‘1’ 是不一致的），或者 query client 引用不稳定（比如在 App 里创建的由于 re-render 或路由变更会导致引用不一致）</p><h3 id="4-为啥要用-useQueryClient-而不是-import-export-的方式引用-queryClient？因为更准确（比如多-query-client-的场景）"><a href="#4-为啥要用-useQueryClient-而不是-import-export-的方式引用-queryClient？因为更准确（比如多-query-client-的场景）" class="headerlink" title="4. 为啥要用 useQueryClient 而不是 import+export 的方式引用 queryClient？因为更准确（比如多 query client 的场景）"></a>4. 为啥要用 useQueryClient 而不是 import+export 的方式引用 queryClient？因为更准确（比如多 query client 的场景）</h3><h3 id="5-为啥请求失败而没有收到错误信息？因为-queryFn-没有返回-reject-的-Promise（比如用-fetch-时需在-res-ok-不-ok-时主动抛个错）。"><a href="#5-为啥请求失败而没有收到错误信息？因为-queryFn-没有返回-reject-的-Promise（比如用-fetch-时需在-res-ok-不-ok-时主动抛个错）。" class="headerlink" title="5. 为啥请求失败而没有收到错误信息？因为 queryFn 没有返回 reject 的 Promise（比如用 fetch 时需在 res.ok 不 ok 时主动抛个错）。"></a>5. 为啥请求失败而没有收到错误信息？因为 queryFn 没有返回 reject 的 Promise（比如用 fetch 时需在 res.ok 不 ok 时主动抛个错）。</h3><p>参考：<br>Practical React Query | TkDodo’s blog</p>]]></content>
      
      
      
        <tags>
            
            <tag> react-query </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gitflow 操作思考</title>
      <link href="/2021/03/04/gitflow%20%E6%93%8D%E4%BD%9C%E6%80%9D%E8%80%83/"/>
      <url>/2021/03/04/gitflow%20%E6%93%8D%E4%BD%9C%E6%80%9D%E8%80%83/</url>
      
        <content type="html"><![CDATA[<h1 id="Git-Flow-的另一种思路"><a href="#Git-Flow-的另一种思路" class="headerlink" title="Git Flow 的另一种思路"></a>Git Flow 的另一种思路</h1><blockquote><p>Master 分支 下文简称（M)<br>Test 分支 下文简称 (T)<br>Feature 分支 下文简称（F）<br>Hotfix 分支 下文简称（H）<br>Merge Request 操作请求 下文简称（MR）</p></blockquote><p>高度精简为一句话：一切分支都从Master分支中拉出！</p><h2 id="迭代开始"><a href="#迭代开始" class="headerlink" title="迭代开始"></a>迭代开始</h2><p>暂定当前迭代为Vn，则上一个稳定迭代的版本为Vn-1。</p><p>首先从<code>M -&gt; T</code>，作为开发过程中的测试分支。</p><p>根据产品文档等需求划分工具提示，每一位同志按照自己手头的工作进行:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">M -&gt; F1</span><br><span class="line">M -&gt; F2</span><br><span class="line">...</span><br><span class="line">M -&gt; Fn</span><br></pre></td></tr></table></figure><p>然后根据各自的时间安排进行开发</p><h2 id="迭代进行时"><a href="#迭代进行时" class="headerlink" title="迭代进行时"></a>迭代进行时</h2><p>流程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">M -&gt; F (F&#x27; F&#x27;&#x27; ...) -&gt; T</span><br></pre></td></tr></table></figure><h3 id="正常迭代开发测试合并"><a href="#正常迭代开发测试合并" class="headerlink" title="正常迭代开发测试合并"></a>正常迭代开发测试合并</h3><p>同志张三正在进行自己的<code>F3</code>功能需求开发，那么他每天需要：</p><ol><li>是否为协同开发？是=&gt;2，否=&gt;3</li><li>拉取远程分支的代码到本地，处理同伴开发可能导致的冲突；</li><li>进行本地开发、测试；</li><li>下班前在本地暂存修改，做好commit记录提交到远程仓库；</li><li>在仓库中发起MR，指定对应的Code Review对象为assignee，如果该需求正在开发过程中，则需要点击<img src="https://img.imgdb.cn/item/60403915360785be541f82da.png" alt=""><br> 之后就会变成<img src="https://img.imgdb.cn/item/60403983360785be541fadba.png" alt=""><br> 提交之后可以方便Code Review的同志今天代码检查；<br> 如果已经开发完成确保可以合并，那么可以在MR中点击<code>Remove the WIP: prefix from the title...</code>，这样在代码检查完毕之后便可以合并到对应的<code>T</code>中了。</li></ol><h3 id="发生了conflict"><a href="#发生了conflict" class="headerlink" title="发生了conflict!"></a>发生了conflict!</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">M -&gt; F3 -&gt; T</span><br><span class="line"></span><br><span class="line">M -&gt; F4 -&gt; T </span><br><span class="line"></span><br><span class="line">// 此时F3和F4中都对 FileA 进行了修改 发生了冲突</span><br></pre></td></tr></table></figure><p>同志张三和同志李四在各自的<code>F</code>中都对同一个文件进行了修改，因此在合并到<code>T</code>时发生了冲突；</p><p>解决方案：</p><ol><li><p>发现产生冲突的同志，在完成Code Review后，将<code>T</code>拉到本地后，进行冲突解决，再提交<code>T</code>；（推荐）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">origin/T -&gt; T</span><br><span class="line">F4 -&gt; T (fix conflict)</span><br><span class="line">T -&gt; origin/T</span><br></pre></td></tr></table></figure></li><li><p>发现产生冲突的同志，在完成Code Review后，从<code>M -&gt; F(3+4)</code>，然后联合与自己产生冲突的同学把各自的<code>F</code>合并到<code>F(3+4)</code>中；（避免在最后每个人把各自的<code>F</code>合并到<code>M</code>的时候再解决一次冲突，但是有可能产生很多F（n+m），慎用）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">M -&gt; F(3+4)</span><br><span class="line">F3 -&gt; F(3+4)</span><br><span class="line">F4 -&gt; F(3+4)</span><br><span class="line">F(3+4) -&gt; origin/F(3+4) -&gt; T</span><br></pre></td></tr></table></figure></li></ol><h3 id="迭代结束"><a href="#迭代结束" class="headerlink" title="迭代结束"></a>迭代结束</h3><p>现在迭代完成了，需要把所有的<code>F</code>分支合并到<code>M</code>上面进行发布上线操作；</p><h4 id="常规状态"><a href="#常规状态" class="headerlink" title="常规状态"></a>常规状态</h4><p>在确保<code>T</code>的测试充足情况下是可以直接合并到<code>M</code>的，而且这种时候几乎不会产生任何冲突，平滑合并上线。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 方案1 --&gt;</span><br><span class="line">T -&gt; M</span><br><span class="line">// 等于</span><br><span class="line">&lt;!-- 方案2 --&gt;</span><br><span class="line">F1 -&gt; M</span><br><span class="line">F2 -&gt; M</span><br><span class="line">...</span><br><span class="line">Fn -&gt; M</span><br></pre></td></tr></table></figure><h4 id="突发情况"><a href="#突发情况" class="headerlink" title="突发情况"></a>突发情况</h4><blockquote><p>“由于xx功能考虑不周，本次迭代不上了”——产品经理<br>“我还想在XX功能上面增加亿点点东西……”——产品经理</p></blockquote><p>在某些情况下会出现<code>Fn</code>这个功能需求无法上线的情况，这个时候需要：</p><ol><li>各自合并:</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">F1 -&gt; M</span><br><span class="line">F2 -&gt; M</span><br><span class="line">...</span><br><span class="line">Fn-1 -&gt; M</span><br><span class="line">// Fn 不合并</span><br><span class="line">// 在master上面解决一下冲突，如果master受到保护，则需要看方案2</span><br></pre></td></tr></table></figure><ol><li>拉取一个新的<code>T2</code>，把除了不上线的需求都合入其中，进行回归测试后合入<code>M</code></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">M -&gt; T2</span><br><span class="line">F1 -&gt; T2</span><br><span class="line">F2 -&gt; T2</span><br><span class="line">...</span><br><span class="line">Fn-1 -&gt; T2</span><br><span class="line"></span><br><span class="line">T2 -&gt; M</span><br></pre></td></tr></table></figure><h3 id="发现历史bug"><a href="#发现历史bug" class="headerlink" title="发现历史bug"></a>发现历史bug</h3><p>历史bug为在 上线的版本中发现的功能上的缺陷，需要及时地进行修改；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">M -&gt; H -&gt; T // 进行测试</span><br><span class="line"></span><br><span class="line">H -&gt; M // 测试完成后可以快速上线</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> gitflow 共同协作 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React源码学习</title>
      <link href="/2020/06/11/React%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
      <url>/2020/06/11/React%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="React-dom-源码阅读"><a href="#React-dom-源码阅读" class="headerlink" title="React-dom 源码阅读"></a>React-dom 源码阅读</h1><h2 id="react-dom-render"><a href="#react-dom-render" class="headerlink" title="react-dom-render"></a>react-dom-render</h2><p>首先 =&gt; 创建<br>ReactDOM.render</p><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ol><li>创建ReactRoot</li><li>创建FiberRoot和RootFiber</li><li>创建更新</li></ol><p>通过DOM <code>Renderer.createContainer</code> 创建了一个 <code>FiberRoot</code>；</p><p>接下来挂载到<code>container._reactRootContainer</code>上面；</p><p>然后最重要的是，调用 <code>DOMRenderer.unbatchedUpdates</code>（批量更新），修改了scheduler里面的一个全局变量；</p><p>返回了一个<code>root.render(children, callback)</code> =&gt; 其实这里的操作最重要是调用了<code>DOMRenderer.updateContainer(children, root, null, work._onCommit)</code> =&gt; 关键函数<code>updateContainerAtExpirationTime</code> 这里有个关键参数是 expirationTime （有效期限？失效时间？）=&gt; <code>scheduleRootUpdate</code> 中使用 <code>createUpdate</code>标记更新的位置，使用<code>enqueueUpdate</code>批量更新，使用<code>scheduleWork</code>调度工作（因为react16有任务优先级）</p><h3 id="关键性函数"><a href="#关键性函数" class="headerlink" title="关键性函数"></a>关键性函数</h3><p>首先在ReactDOM.js中找到 ReactDOM 对象 中的 render<br>在 render 的方法中仔细分析 <code>legacyRenderSubtreeIntoContainer(null, element, container, false, callback)</code></p><p>第一个参数是 parentComponent ，接着往下是找到root，<br>然而在新建的时候一定不会有reactRootContainer，所以创建的时候就只需要关注<code>!root</code></p><p>第四个参数是false，跟 hydrate 相关，这个在服务端渲染中有用，告诉react是否可以复用别的节点。</p><h3 id="FiberRoot"><a href="#FiberRoot" class="headerlink" title="FiberRoot"></a>FiberRoot</h3><ul><li>整个应用的起点</li><li>包含应用挂载的目标节点</li><li>记录整个应用更新过程的各种信息</li></ul><p><a href="https://react.jokcy.me/book/api/react-structure.html">数据结构</a></p><h3 id="Fiber"><a href="#Fiber" class="headerlink" title="Fiber"></a>Fiber</h3><ul><li>每一个ReactElement都会对应一个Fiber对象</li><li>记录节点的各种状态</li><li>串联整个应用形成树结构</li></ul><p><a href="https://react.jokcy.me/book/api/react-structure.html">数据结构</a></p><p>串联整个应用形成树结构：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    return,   // 返回父节点</span><br><span class="line">    child,    // 第一个子节点</span><br><span class="line">    sibling   // 第一个子节点的兄弟节点</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只存一个child（第一个子节点），其他的子节点都是第一个child的sibling</p><p>等等等</p><h3 id="Update"><a href="#Update" class="headerlink" title="Update"></a>Update</h3><p>用于记录组件状态的改变<br>存放于UpdateQueue中<br>多个Update可以同时存在</p><p><a href="https://react.jokcy.me/book/api/react-structure.html">数据结构</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>G6使用指南</title>
      <link href="/2020/06/09/G6%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"/>
      <url>/2020/06/09/G6%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<h1 id="G6-使用指南"><a href="#G6-使用指南" class="headerlink" title="G6 使用指南"></a>G6 使用指南</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><pre><code>在吾来产品中有任务机器人的画布功能，我们在设计之初调研了众多库，最后挑选了一款将canvas和HTML DOM结合地不错的JSPlumb库，的的确确也很大程度上完成了功能的开发，在效果上也具有不错的体现，然而在后期，产品团队和设计团队想要对这个画布功能进行修改的时候便遭遇了极大困难，所以说，JSPlumb是一款起点和上限都不高的库。   于是静极思变，我们看见了现在新的库G6，作为阿里团队开发维护的库，我们决定去尝试一下。</code></pre><h2 id="G6"><a href="#G6" class="headerlink" title="G6"></a>G6</h2><pre><code>G6 是一个简单、易用、完备、开源的图可视化引擎，它在高定制能力的基础上，提供了一系列设计优雅、便于使用的图可视化解决方案。能帮助开发者搭建属于自己的图可视化、图分析、或图编辑器应用。</code></pre><h2 id="Graphin"><a href="#Graphin" class="headerlink" title="Graphin"></a>Graphin</h2><pre><code>Graphin 取名意为 Graph Insight（图的分析洞察），是一个基于 G6 封装的 React 组件库。简单，高效，开箱即用。Graphin由于UIbot-Observer平台的高速迭代带来了极大的压力，我便把目光放到了这个库上面，的的确确Graphin为快速开发带来了极大的便利，但是也带来不少的问题。</code></pre><h2 id="搭建"><a href="#搭建" class="headerlink" title="搭建"></a>搭建</h2><pre><code>搭建一个graphin图表基本上需要：</code></pre><p>1.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install @antv/graphin --save</span><br></pre></td></tr></table></figure><p>2.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">Graphin</span> data /&gt;</span><br></pre></td></tr></table></figure><pre><code>的确必要元素就可以这么少，当然，这么点东西肯定不能满足业务需求，大致看一看PRD中和设计提供的原型图，要满足需求需要确定整体布局、改变节点样式、改变边的样式、提供放大缩小的功能、提供全屏的功能……</code></pre><h3 id="确定整体布局"><a href="#确定整体布局" class="headerlink" title="确定整体布局"></a>确定整体布局</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">Graphin</span></span><br><span class="line">    data=&#123;listData&#125;</span><br><span class="line">    layout=&#123;<span class="title class_">LayoutOpt</span>&#125;</span><br><span class="line">/&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">LayoutOpt</span> = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;dagre&#x27;</span>,</span><br><span class="line">    <span class="attr">options</span>: &#123;</span><br><span class="line">     <span class="attr">rankdir</span>: <span class="string">&#x27;TB&#x27;</span>,</span><br><span class="line">     <span class="attr">align</span>: <span class="string">&#x27;UL&#x27;</span>,</span><br><span class="line">     <span class="attr">nodesep</span>: <span class="number">200</span>,</span><br><span class="line">     <span class="attr">ranksep</span>: <span class="number">5</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p>整体布局名称为 dagre ，是一种层次布局，</p></li><li><p>rankdir是布局的方向 Top =&gt; Bottom</p></li><li><p>align是对齐方式，枚举值，Up Left</p></li><li><p>ranksep和nodesep都是间隔值</p></li></ul><h3 id="修改节点样式"><a href="#修改节点样式" class="headerlink" title="修改节点样式"></a>修改节点样式</h3><pre><code>扩展API  `&lt;Graphin/&gt;` 组件 props.extend 配置。用于配置 Graphin 布局/NodeShape/Marker 的扩展。想要实现一个自己满意的节点，那就不能使用Graphin提供的默认的节点样式了，需要自己手动编写一个G6对象实例，里面包括节点的名称、节点的配置等等，talk is cheap，show me the code</code></pre><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">Graphin</span></span><br><span class="line">     data=&#123;listData&#125;</span><br><span class="line">     layout=&#123;<span class="title class_">LayoutOpt</span>&#125;</span><br><span class="line"></span><br><span class="line">         extend=&#123;&#123;</span><br><span class="line">          <span class="attr">nodeShape</span>: extendNodeShape,</span><br><span class="line">     &#125;&#125;</span><br><span class="line">/&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  基础样式配置</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> defaultStyles = &#123;</span><br><span class="line">     <span class="comment">/** 容器 */</span></span><br><span class="line">     <span class="attr">containerWidth</span>: <span class="number">180</span>,</span><br><span class="line">     <span class="attr">containerHeight</span>: <span class="number">40</span>,</span><br><span class="line">     <span class="attr">containerStroke</span>: <span class="string">&#x27;#687c8a&#x27;</span>, <span class="comment">// 边框色</span></span><br><span class="line">     <span class="attr">containerFill</span>: <span class="string">&#x27;#687c8a&#x27;</span>, <span class="comment">// 背景色</span></span><br><span class="line">     <span class="comment">/** 文本 */</span></span><br><span class="line">     <span class="attr">fontColor</span>: <span class="string">&#x27;#FFF&#x27;</span>,</span><br><span class="line">     <span class="attr">fontColorDark</span>: <span class="string">&#x27;#425b6d&#x27;</span>,</span><br><span class="line">     <span class="attr">fontSize</span>: <span class="number">14</span>,</span><br><span class="line">     <span class="comment">/** 深色 */</span></span><br><span class="line">     <span class="attr">dark</span>: <span class="string">&#x27;#425b6d&#x27;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Graphin Node 自定义样式</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> <span class="variable">graphin</span></span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> <span class="variable">props</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">extendNodeShape</span> = (<span class="params">graphin: any, props: any</span>) =&gt; &#123;</span><br><span class="line"><span class="keyword">return</span> [</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">name</span>: <span class="string">&#x27;APPS&#x27;</span>,</span><br><span class="line"><span class="attr">render</span>: <span class="function">(<span class="params">node: &#123; style: any; data: any &#125;</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">const</span> style = &#123;</span><br><span class="line">     ...defaultStyles,</span><br><span class="line">     ...node.<span class="property">style</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">     <span class="attr">shape</span>: <span class="string">&#x27;RectNode&#x27;</span>,</span><br><span class="line">     <span class="attr">shapeComponents</span>: [</span><br><span class="line">     &#123;</span><br><span class="line">          <span class="attr">shape</span>: <span class="string">&#x27;rect&#x27;</span>,</span><br><span class="line">          <span class="attr">attrs</span>: &#123;</span><br><span class="line">               <span class="attr">id</span>: <span class="string">&#x27;rect-container&#x27;</span>,</span><br><span class="line">               <span class="attr">x</span>: <span class="number">0</span>,</span><br><span class="line">               <span class="attr">y</span>: <span class="number">0</span>,</span><br><span class="line">               <span class="attr">width</span>: style.<span class="property">containerWidth</span>,</span><br><span class="line">               <span class="attr">height</span>: style.<span class="property">containerHeight</span>,</span><br><span class="line">               <span class="attr">fill</span>: style.<span class="property">containerFill</span>,</span><br><span class="line">               <span class="attr">stroke</span>: style.<span class="property">containerStroke</span>,</span><br><span class="line">               <span class="attr">cursor</span>: <span class="string">&#x27;pointer&#x27;</span>,</span><br><span class="line">               <span class="attr">lineWidth</span>: <span class="number">2</span>,</span><br><span class="line">               <span class="attr">radius</span>: [<span class="number">4</span>],</span><br><span class="line">          &#125;,</span><br><span class="line">     &#125;,</span><br><span class="line">     &#123;</span><br><span class="line">          <span class="attr">shape</span>: <span class="string">&#x27;circle&#x27;</span>,</span><br><span class="line">          <span class="attr">attrs</span>: &#123;</span><br><span class="line">              <span class="attr">id</span>: <span class="string">&#x27;badge&#x27;</span>,</span><br><span class="line">               <span class="attr">x</span>: style.<span class="property">containerWidth</span>,</span><br><span class="line">               <span class="attr">y</span>: <span class="number">0</span>,</span><br><span class="line">               <span class="attr">r</span>: style.<span class="property">badgeSize</span>,</span><br><span class="line">               <span class="attr">fill</span>: style.<span class="property">badgeFill</span>,</span><br><span class="line">               <span class="attr">cursor</span>: <span class="string">&#x27;pointer&#x27;</span>,</span><br><span class="line">               <span class="attr">lineWidth</span>: <span class="number">1</span>,</span><br><span class="line">             &#125;,</span><br><span class="line">     &#125;,</span><br><span class="line">     &#123;</span><br><span class="line">          <span class="attr">shape</span>: <span class="string">&#x27;text&#x27;</span>, <span class="comment">// 这是右上角的badge 徽记</span></span><br><span class="line">          <span class="attr">attrs</span>: &#123;</span><br><span class="line">                <span class="attr">id</span>: <span class="string">&#x27;badge-text&#x27;</span>,</span><br><span class="line">                <span class="attr">x</span>: style.<span class="property">containerWidth</span> / <span class="number">2</span>,</span><br><span class="line">                <span class="attr">y</span>: -<span class="number">4</span>,</span><br><span class="line">                <span class="attr">fontSize</span>: <span class="number">10</span>,</span><br><span class="line">                <span class="attr">cursor</span>: <span class="string">&#x27;pointer&#x27;</span>,</span><br><span class="line">                <span class="attr">fill</span>: <span class="string">&#x27;#fff&#x27;</span>,</span><br><span class="line">                <span class="attr">textAlign</span>: <span class="string">&#x27;center&#x27;</span>,</span><br><span class="line">                <span class="attr">textBaseline</span>: <span class="string">&#x27;top&#x27;</span>,</span><br><span class="line">          &#125;,</span><br><span class="line">     &#125;,</span><br><span class="line">     &#123;</span><br><span class="line">          <span class="attr">shape</span>: <span class="string">&#x27;Marker&#x27;</span>,</span><br><span class="line">          <span class="attr">attrs</span>: &#123;</span><br><span class="line">                <span class="attr">id</span>: <span class="string">&#x27;node-icon&#x27;</span>,</span><br><span class="line">                <span class="attr">symbol</span>: node.<span class="property">data</span>.<span class="property">type</span>,</span><br><span class="line">                <span class="attr">x</span>: style.<span class="property">containerWidth</span> / <span class="number">2</span>,</span><br><span class="line">                <span class="attr">y</span>: style.<span class="property">containerWidth</span> / <span class="number">2</span>,</span><br><span class="line">                <span class="attr">r</span>: style.<span class="property">iconSize</span>,</span><br><span class="line">                <span class="attr">fill</span>: style.<span class="property">iconFill</span>,</span><br><span class="line">          &#125;,</span><br><span class="line">     &#125;,</span><br><span class="line">     &#123;</span><br><span class="line">          <span class="attr">shape</span>: <span class="string">&#x27;text&#x27;</span>,</span><br><span class="line">          <span class="attr">attrs</span>: &#123;</span><br><span class="line">                <span class="attr">id</span>: <span class="string">&#x27;text-desc&#x27;</span>,</span><br><span class="line">                <span class="attr">text</span>: node.<span class="property">data</span>.<span class="property">label</span>,</span><br><span class="line">                <span class="attr">x</span>: style.<span class="property">containerWidth</span> / <span class="number">2</span>,</span><br><span class="line">                <span class="attr">y</span>: style.<span class="property">containerHeight</span> / <span class="number">2</span>,</span><br><span class="line">                <span class="attr">cursor</span>: <span class="string">&#x27;pointer&#x27;</span>,</span><br><span class="line">                <span class="attr">fontSize</span>: style.<span class="property">fontSize</span>,</span><br><span class="line">                <span class="attr">fill</span>: style.<span class="property">fontColor</span>,</span><br><span class="line">                <span class="attr">fontWeight</span>: <span class="string">&#x27;bolder&#x27;</span>,</span><br><span class="line">                <span class="attr">fontFamily</span>: <span class="string">&#x27;Courier New&#x27;</span>,</span><br><span class="line">                <span class="attr">textAlign</span>: <span class="string">&#x27;center&#x27;</span>,</span><br><span class="line">                <span class="attr">textBaseline</span>: <span class="string">&#x27;middle&#x27;</span>,</span><br><span class="line">          &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">],</span><br><span class="line"><span class="attr">state</span>: &#123;</span><br><span class="line">        <span class="attr">selected</span>: &#123;</span><br><span class="line">                <span class="string">&#x27;rect-container&#x27;</span>: &#123;</span><br><span class="line">                <span class="attr">stroke</span>: style.<span class="property">containerStroke</span>,</span><br><span class="line">                <span class="attr">fill</span>: style.<span class="property">containerStroke</span>,</span><br><span class="line">                <span class="attr">animate</span>: &#123;</span><br><span class="line">                     <span class="attr">attrs</span>: &#123;</span><br><span class="line">                              <span class="attr">lineWidth</span>: <span class="number">6</span>,</span><br><span class="line">                              <span class="attr">shadowOffsetX</span>: <span class="number">0</span>,</span><br><span class="line">                              <span class="attr">shadowOffsetY</span>: <span class="number">0</span>,</span><br><span class="line">                              <span class="attr">shadowBlur</span>: <span class="number">2</span>,</span><br><span class="line">                              <span class="attr">shadowColor</span>: <span class="string">&#x27;#fff&#x27;</span>,</span><br><span class="line">                              <span class="attr">repeat</span>: <span class="literal">false</span>, <span class="comment">// 循环</span></span><br><span class="line">                     &#125;,</span><br><span class="line">                     <span class="attr">duration</span>: <span class="number">200</span>,</span><br><span class="line">                     <span class="attr">easing</span>: <span class="string">&#x27;easeCubic&#x27;</span>,</span><br><span class="line">                     <span class="attr">callback</span>: <span class="literal">null</span>,</span><br><span class="line">                     <span class="attr">delay</span>: <span class="number">0</span>,</span><br><span class="line">                 &#125;,</span><br><span class="line">                    &#125;,</span><br><span class="line">                <span class="string">&#x27;node-icon&#x27;</span>: &#123;</span><br><span class="line">                 <span class="attr">fill</span>: <span class="string">&#x27;#fff&#x27;</span>,</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attr">badge</span>: &#123;</span><br><span class="line">                 <span class="attr">lineWidth</span>: <span class="number">6</span>,</span><br><span class="line">                &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>以上代码中，我注册了一个名为“APPS”的节点，</p><ul><li><p>它主体是一个矩形’rect’，起点位置[0, 0]，Fill代表的是填充的背景色，Stroke代表的是边框的颜色，lineWidth代表是他的粗细；</p></li><li><p>右上角会有圆形的徽标’cicle’；</p></li><li><p>徽标中会有text；</p></li><li><p>在主体中也有text；</p></li><li><p>在选中（selected）的时候会有一个动画出现——整个节点的边框会变粗。</p></li></ul><blockquote><p>你想用什么节点就自己接入吧。</p></blockquote><h3 id="改变边的样式"><a href="#改变边的样式" class="headerlink" title="改变边的样式"></a>改变边的样式</h3><p>这个就需要写在data当中了</p><hr><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在data中的设置</span></span><br><span class="line"><span class="attr">style</span>: <span class="title class_">EdgeStyle</span>,</span><br><span class="line"><span class="attr">labelCfg</span>: <span class="title class_">FontStyle</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment">// 边的样式</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">EdgeStyle</span> = &#123;</span><br><span class="line">    <span class="attr">lineWidth</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="attr">stroke</span>: <span class="string">&#x27;#b3bdc5&#x27;</span>,</span><br><span class="line">    <span class="attr">endArrow</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">strokeOpacity</span>: <span class="number">0.7</span>,</span><br><span class="line">    <span class="attr">shadowColor</span>: <span class="string">&#x27;#b3bdc5&#x27;</span>,</span><br><span class="line">    <span class="attr">shadowBlur</span>: <span class="number">1</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字体样式</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">FontStyle</span> = &#123;</span><br><span class="line">    <span class="attr">style</span>: &#123;</span><br><span class="line">    <span class="attr">fill</span>: <span class="string">&#x27;#425b6d&#x27;</span>,</span><br><span class="line">    <span class="attr">lineWidth</span>: <span class="number">4</span>,</span><br><span class="line">    <span class="attr">opacity</span>: <span class="number">0.7</span>,</span><br><span class="line">    <span class="attr">fontSize</span>: <span class="number">14</span>,</span><br><span class="line">    <span class="attr">fontWeight</span>: <span class="number">600</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>都非常容易理解的参数就不一一介绍了</p><h3 id="增加放大缩小全屏功能"><a href="#增加放大缩小全屏功能" class="headerlink" title="增加放大缩小全屏功能"></a>增加放大缩小全屏功能</h3><p>这个功能听起来高大上或许非常难以实现，但是其实G6都暴露出来了api，并且Graphin都已经做好了封装，只需要：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Toolbar</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;@antv/graphin-components&#x27;</span></span><br><span class="line"></span><br><span class="line">&lt;<span class="title class_">Graphin</span>&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">Toolbar</span> /&gt;</span></span></span><br><span class="line">&lt;/<span class="title class_">Graphin</span>&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>so ez</p>]]></content>
      
      
      
        <tags>
            
            <tag> UMI3 G6 Graphin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用UMI3搭建项目心得</title>
      <link href="/2020/06/01/%E4%BD%BF%E7%94%A8UMI3%E6%90%AD%E5%BB%BA%E9%A1%B9%E7%9B%AE%E6%96%B0%E7%9A%84/"/>
      <url>/2020/06/01/%E4%BD%BF%E7%94%A8UMI3%E6%90%AD%E5%BB%BA%E9%A1%B9%E7%9B%AE%E6%96%B0%E7%9A%84/</url>
      
        <content type="html"><![CDATA[<blockquote><p> 写这一篇之前感谢子杰同学的付出，给我们搭建了一套基于umi3的框架，内置了启动配置等等耗时的基础操作，达到了快速启动项目的目的。</p></blockquote><hr><p>但是在使用中仍然需要注意几点，听我细细道来。</p><h2 id="UMI3"><a href="#UMI3" class="headerlink" title="UMI3"></a>UMI3</h2><h3 id="基础结构"><a href="#基础结构" class="headerlink" title="基础结构"></a>基础结构</h3><p>这个是给小白说的，虽然umi3的写法超高度类似于reactjs的写法，但是不代表你就可以不去阅读umi3的文档了。</p><p>当然阅读了文档也不代表你就全部领悟了（可能因为作者默认你是老的开发者，所以有部分change他会说是从umi2中变换而来的，想了解还是得看一眼早期文档）</p><p>有意思的是他的项目目录结构：</p><p><code>src/layouts</code>：作为页面的基础布局，可以有多个<br><code>src/pages</code>: 作为各个路由对应的页面<br>这俩是默认的↑</p><p><code>src/components</code>: 组件<br><code>src/grpc</code>: 如果你接口的接入方式是grpc-web，注意这里面的目录层级结构需要和编译出来的proto文件所在的目录层级一致<br><code>src/utils....</code><br>这些是约定俗成的↑</p><h3 id="项目配置"><a href="#项目配置" class="headerlink" title="项目配置"></a>项目配置</h3><p>几乎全部在<code>.umirc.ts</code>文件内</p><p>不同于umi2x版本的层级配置，Umi3的配置全部拉平，第一次写就会有点懵逼，但是胆子大一点多尝试尝试就会好受的。</p><h3 id="开始踩坑"><a href="#开始踩坑" class="headerlink" title="开始踩坑"></a>开始踩坑</h3><h4 id="小坑1-routes-配置"><a href="#小坑1-routes-配置" class="headerlink" title="小坑1 routes 配置"></a>小坑1 routes 配置</h4><p>routes 配置中要把路由结构写清晰（虽然他说可以默认按照文件目录结构生成，但是个人尝试了似乎并不好使）</p><p>什么意思呢？</p><p>比方说你拥有</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">pages/login</span><br><span class="line"></span><br><span class="line">pages/center1</span><br><span class="line"></span><br><span class="line">pages/center2</span><br><span class="line"></span><br><span class="line">pages/center2/:hash</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>理论上通过路由，Umi3会帮你匹配到你目录结构下面的各个文件，然而，你的需求可能远不止此：</p><p>login页面的布局和其他页面并不相同<br>center2的详情页的和center2的页面路由很相似<br>…<br>这个时候如果你不在配置中写得明明白白的，我保证一个星期后你自己都不认得这个项目了。</p><p>正确示范↓</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">routes</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">path</span>: <span class="string">&#x27;/login&#x27;</span>,</span><br><span class="line">        <span class="attr">title</span>: <span class="string">&#x27;登录&#x27;</span>,</span><br><span class="line">        <span class="attr">component</span>: <span class="string">&#x27;@/pages/login&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">path</span>: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">        <span class="attr">component</span>: <span class="string">&#x27;@/layouts/index&#x27;</span>,</span><br><span class="line">        <span class="attr">routes</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">path</span>: <span class="string">&#x27;/center1&#x27;</span>,</span><br><span class="line">                <span class="attr">title</span>: <span class="string">&#x27;xx中心&#x27;</span>,</span><br><span class="line">                <span class="attr">component</span>: <span class="string">&#x27;@/pages/center1&#x27;</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">path</span>: <span class="string">&#x27;/center2&#x27;</span>,</span><br><span class="line">                <span class="attr">title</span>: <span class="string">&#x27;yy中心&#x27;</span>,</span><br><span class="line">                <span class="attr">component</span>: <span class="string">&#x27;@/pages/center2&#x27;</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">exact</span>: <span class="literal">true</span>,</span><br><span class="line">                <span class="attr">path</span>: <span class="string">&#x27;/center2/:hash&#x27;</span>,</span><br><span class="line">                <span class="attr">title</span>: <span class="string">&#x27;yy详情&#x27;</span>,</span><br><span class="line">                <span class="attr">component</span>: <span class="string">&#x27;@/pages/centers/[hash]&#x27;</span>,</span><br><span class="line">             &#125;,</span><br><span class="line">         ],</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里有个坑存在：文档中默认 <code>exact: false</code>，但是如果你没事儿就千万不要自己写在route的配置中，写进去立马让这段匹配不好使！</p><p>其他的怎么定义路由就不细说了，文档里面全都有。</p><h4 id="小坑2-dva-类react-redux"><a href="#小坑2-dva-类react-redux" class="headerlink" title="小坑2 dva 类react redux"></a>小坑2 dva 类react redux</h4><p>这个只需要在配置中写上即可，文档中一笔带过，不注意的人还发现不了嘿，不用自己再装一遍react-redux！</p><h4 id="小坑3-Umi3自带了antd4"><a href="#小坑3-Umi3自带了antd4" class="headerlink" title="小坑3 Umi3自带了antd4"></a>小坑3 Umi3自带了antd4</h4><p>这导致什么问题？（写作时间2020/5.20）我们现在的组件库仍然是antd3x</p><p>理论上我们开发项目要用到组件库，那就简单安装一下下laiye-antd即可，我们的laiye-antd会自己自觉引用项目中依赖的antd。</p><p>now注意！坑就在此，不知道发生了什么情况，在项目编译的时候会检查laiye-antd。由于 antd3x =&gt; antd4x中删除了moment组件，修改了select组件的样式，独立了icon等，导致了编译时会报错moment找不到！</p><p>百思不得其解，涉及到npm包和npm包里的npm包，情况相当不明朗，不过还是有解决方案的：</p><p>在umirc.ts文件中增加一行配置</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">extraBabelPlugins</span>: [</span><br><span class="line">    [<span class="string">&#x27;import&#x27;</span>, &#123;</span><br><span class="line">        <span class="attr">libraryName</span>: <span class="string">&#x27;laiye-antd&#x27;</span>,</span><br><span class="line">        <span class="attr">style</span>: <span class="string">&#x27;css&#x27;</span></span><br><span class="line">    &#125;, <span class="string">&#x27;laiye-antd&#x27;</span>],</span><br><span class="line">],</span><br></pre></td></tr></table></figure><p>声明，我们要按需加载laiye-antd，用什么加载什么，这样编译的时候就会放过moment组件了。</p><p>至于select组件使用时候丢失样式什么的，直接</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; select &#125; <span class="keyword">from</span> <span class="string">&#x27;laiye-antd&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; select &#125; <span class="keyword">from</span> <span class="string">&#x27;antd&#x27;</span></span><br></pre></td></tr></table></figure><p>就行了</p><h2 id="项目部署"><a href="#项目部署" class="headerlink" title="项目部署"></a>项目部署</h2><h3 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h3><p>项目部署需要几个关键文件（夹）</p><p>/docker/baseimg.Dockerfile<br>/docker/Dockerfile<br>/docker/start.sh<br>/Jenkinsfile (由运维同学提供)<br>/pm2.json<br>在后端gitlab仓库中的配置模板项目（config-templates）中增加线上配置</p><h3 id="具体步骤："><a href="#具体步骤：" class="headerlink" title="具体步骤："></a>具体步骤：</h3><ol><li><p>得利于子杰同学的努力，项目中已经拥有了docker这个文件夹，只需要微调里面存放项目的地址即可；</p></li><li><p>将自己的项目推到gitlab的仓库中，并且将gitlab项目地址、项目的各个环境的域名告诉运维同学；</p></li><li><p>自己摸索到后端的仓库中，找到 config-templates 的项目，在对应的文件夹下面新（fu）建（zhi）好自己的配置文件，可以叫人帮你一起看看配置的对不对，然后发merge-request给运维同学；</p></li><li><p>运维同学给到两样关键数据：（1.）Jenkins项目地址 （2）测试机上面的端口号；</p></li><li><p><strong>Jenkins地址</strong>拿到后在自己的项目里面构建 baseimg 的 tag，只有拥有了baseimg才能走通master和testxx分支的构建；这里需要和运维同学一起联调；</p></li><li><p>测试机上的端口号，将项目本地配置文件中的启动端口号更改成运维同学配置好的端口；通过ssh进入测试机，进入webroot目录中下载你的项目，走一遍yarn；yarn build；yarn pm2……;</p></li></ol><p>第5步是部署测试环境、灰度环境、生产环境</p><p>第6步是部署联调环境</p><p>按照这个流程走下来基本上就么得问题了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> UMI3 Dva Webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>吾来-画布功能要点汇总</title>
      <link href="/2020/04/09/%E5%90%BE%E6%9D%A5-%E7%94%BB%E5%B8%83%E5%8A%9F%E8%83%BD%E8%A6%81%E7%82%B9%E6%B1%87%E6%80%BB/"/>
      <url>/2020/04/09/%E5%90%BE%E6%9D%A5-%E7%94%BB%E5%B8%83%E5%8A%9F%E8%83%BD%E8%A6%81%E7%82%B9%E6%B1%87%E6%80%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="要点汇总"><a href="#要点汇总" class="headerlink" title="要点汇总"></a>要点汇总</h1><ul><li>画布的前身今世</li><li>技术选择</li><li>技术实现</li></ul><h2 id="画布的前身今世"><a href="#画布的前身今世" class="headerlink" title="画布的前身今世"></a>画布的前身今世</h2><blockquote><p>画布是任务场景中对于对话单元的设置以及排布的区域，以下介绍对比了画布的演进历史。</p></blockquote><h3 id="DM1时代"><a href="#DM1时代" class="headerlink" title="DM1时代"></a>DM1时代</h3><p>DM1（Dialog Manage 1st version）对话管理 即 任务对话管理第一版本;</p><p>现在（2019.11.25）依然呈现在项目中-任务对话-场景列表-「旧版」场景;</p><p>里面的触发器和对话单元呈现y轴排布，编辑场景对于对话单元的排布要求编辑人员有较高的水准，界面较为简陋，使用起来不是特别得心应手。</p><h3 id="DM1-8时代"><a href="#DM1-8时代" class="headerlink" title="DM1.8时代"></a>DM1.8时代</h3><p>DM1.8 这个数字非常有趣，它不是1也不是2，是一个中间版本;<br>它属于DM2数据的前身，现在已经下线。<br>那为什么会出现这个版本呢？<br>想法来源 : 界面采用了和DM1一模一样的配置，不同点在于，算法团队领先于迭代2个月升级了数据库，升级了算法结构，在非常紧急的情况下需要兼容到DM2的数据结构以及DM1的用户交互，花费1个迭代 + 10.1黄金周的时间完成。</p><h3 id="DM2时代"><a href="#DM2时代" class="headerlink" title="DM2时代"></a>DM2时代</h3><p>DM2（Dialog Manage 2nd version）任务对话管理第二版本<br>现在项目中的主流场景，也是现在维护的重心所在。</p><pre><code>从十月中旬到11.22日上线，由乔岳领衔，张熠、康永胜通力合作，实际开发时间 为（10.27-11.22），胜利上线。</code></pre><h2 id="技术选择"><a href="#技术选择" class="headerlink" title="技术选择"></a>技术选择</h2><p>在DM1的时期，就有非常多的抱怨声音：</p><pre><code>对话单元排布不够直观；找不到自己需要的对话单元；流程必须脑子想；顺序调整麻烦；……</code></pre><p>CEO做出指示</p><blockquote><p>“ 我们要打造一款市面上与众不同的对话编辑产品 ”</p></blockquote><p>于是，DM2的需求就这么拍下来了……</p><p>CEO再指示 “ 我们要在11.22日顺利上线 ”</p><p>于是，DM2需求的截止日期也拍下来了……</p><blockquote><p>鲁迅先生说过：“ 调研技术方案很复杂 ”</p></blockquote><p>的确是这样，按照惯例，我或许想要去扒一扒类似产品的技术栈，然而现实很残酷，我没找到类似产品。</p><p>好的，这难不倒我，我想了别的方法——在谷歌搜索中敲入「可视化操作 js 前端 模块拖拽」等的关键词。</p><p>结果非常喜人，D3.js 作为最高的推荐进入了我的选择。</p><h3 id="D3-js"><a href="#D3-js" class="headerlink" title="D3.js"></a>D3.js</h3><p><a href="https://d3js.org/">https://d3js.org/</a></p><p>D3js作为行业内非常受人关注的可视化工具，里面提供了大量的实例，沉浸在大家开发的各(hua)式(li)各(hu)样(shao)的工具中，我感到异常欣喜——或许调研工作就这么完成了！</p><p>我太天真了</p><p>D3js 它并不是一个开箱即用的工具，丰富的画布操作、酷炫的物理引擎，在他们的背后是一个又一个的数学函数在支撑。尽管我能找到在界面上有95%相近的模板，但是剩下的5%却可能遥不可及。</p><p>在处理了第三个DEMO转换失败之后，我放弃了选用D3js。</p><h3 id="2-Canvas"><a href="#2-Canvas" class="headerlink" title="2. Canvas"></a>2. Canvas</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API">https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API</a></p><p>几乎相同的理由，相比于D3js， Canvas 似乎更加原始，通过丰富的API去展示画布中的信息，但是操纵画布怎么返回信息到前端？</p><p>‘That really makes me confused !’</p><p>闪电般的速度，我就放弃了</p><h3 id="3-JSPlumb"><a href="#3-JSPlumb" class="headerlink" title="3. JSPlumb"></a>3. JSPlumb</h3><p><a href="https://jsplumbtoolkit.com/">https://jsplumbtoolkit.com/</a></p><p>社区版的文档地址</p><p>感叹着 我太南了 的时候，不经意间进入了这个网站。</p><p>哦吼！</p><p>这看似一般的界面下，隐藏四个大字（就是他了）</p><p>那么好处都有啥？</p><ul><li><p>看起来就是个编辑流程的玩意儿；</p></li><li><p>封装了足够多的拖拽连线的事件；</p></li><li><p>提供了足够的API在社区版本中；</p></li></ul><p>澳大利亚的团队好说话，写了个邮件人家就让我免费使用开发版（一个月）；</p><p>距离截止日期又近了几天，要来不及了；</p><p>用简单的DEMO证明了从数据到画布是可行的，在画布中自定义单元的样式也是可行的，免费的，可以在React技术栈中使用可行的，连线的效果设计师看了都👏是可行的……</p><p>没错，最后我选择的技术栈就是使用JSPlumb。</p><h2 id="技术实现"><a href="#技术实现" class="headerlink" title="技术实现"></a>技术实现</h2><p>这是重点，这是重点，这是……</p><h3 id="前端前技术"><a href="#前端前技术" class="headerlink" title="前端前技术"></a>前端前技术</h3><p>框架确定好了，那么根据框架特性，我们要确定一个总体的思想——数据流向问题。</p><p>需求为 做一个可以多版本的可视化的能拖拽的能连线的 画布，细节自己琢磨。</p><p>前端的目光先聚集在“多版本”之后：</p><ul><li><p>可视化：框架已经帮忙做好了；</p></li><li><p>能拖拽：框架也帮忙了；</p></li><li><p>能连线：框架也做好了；</p></li></ul><p>收工！</p><p>然而真的是这样吗？</p><p>我们做一些对话单元的div放在那里，拖进画布中，画布返回结构，如果需要保存那就再做一次映射？</p><p>错，那样的产品不可能免费</p><p>实际上JSPlumb的行为完全是由我们操纵的：</p><p>渲染画布：从数据库中读取数据，按照JSPlumb官网的要求生成所需的数据结构，传递到画布实例中，渲染生成；</p><p>对话单元拖入画布中，放下： 画布监听鼠标放置的位置，返回位置信息（画布左上角为（0,0）向左向下递增），我们修改画布数据，渲染单元；</p><p>对话单元连线：连线需要知道两个端点，数据结构为</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">from</span>: id1, <span class="attr">to</span>: id2&#125;</span><br></pre></td></tr></table></figure><p>相应的，每个对话单元块会有一个自己的block_id，（如果有多种跳转关系）那么每个单元块内部的关系会有自己的relation_id，通过这些id，就能定义好数据结构，修改画布数据，渲染连线。</p><p>由此可见，实际上我们的数据流向是单向的，不必担心画布还会生成一份数据进行糅合处理，永远是外层监听画布内的事件，通过修改渲染画布的数据结构来达到修改画布信息的目的。</p><h3 id="前后端技术"><a href="#前后端技术" class="headerlink" title="前后端技术"></a>前后端技术</h3><h4 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h4><blockquote><p>“画布内要多版本”-产品经理如是说</p></blockquote><p>MySQL的操作过于繁重，不适合做版本的管理。</p><p>经验丰富的康永胜同志果断的学习并且采用MongoDB的技术栈。</p><p>MongoDB拥有轻量的特性，读写速度快，用于画布内的数据存储和版本管理再好不过了，只有在发布画布内信息的时候，MongoDB才会把数据跟MySQL进行一次同步，更新到MySQL当中。</p><h2 id="代码细节"><a href="#代码细节" class="headerlink" title="代码细节"></a>代码细节</h2><h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><p>└── Visual<br>├── block<br>│ ├── ask.block.tsx<br>│ ├── …<br>│ ├── collect.block.tsx<br>│ ├── …<br>│ └── block.tsx<br>├── common<br>│ ├── bounce.tsx<br>│ ├── dimension.tsx<br>│ ├── header.tsx<br>│ ├── lemma.tsx<br>│ ├── option.tsx<br>│ └── topbar.tsx<br>├── configs<br>│ ├── block.config.ts<br>│ ├── instance.config.ts<br>│ └── jsplumb.config.ts<br>├── forms<br>│ ├── test.form.tsx<br>│ ├── test.style.ts<br>│ ├── trigger.form.tsx<br>│ └── trigger.style.ts<br>├── hoc<br>│ ├── drag.hoc.tsx<br>│ └── endpoint.hoc.tsx<br>├── canvasView.tsx<br>├── controlsView.tsx<br>├── index.tsx<br>├── visual.data.ts<br>└── visual.style.ts</p><h3 id="block"><a href="#block" class="headerlink" title="block"></a>block</h3><p>画布中的对话单元模块，使用的时候有两种模式：</p><ol><li>简单模式：如同询问单元</li></ol><p>只需要传递block的种类</p><ol start="2"><li>复杂模式：如同收集单元<br>如果需要自己画出来，那就得自己render。</li></ol><p>区分简单复杂模式有一个简单的方法，如果这个单元需要填槽，那么大概率他就是一个复杂模式，如果不需要，对话流只需要简单地通过单元，那就是简单模式。</p><h3 id="common"><a href="#common" class="headerlink" title="common"></a>common</h3><p>该目录下放置了一些通用的组件:</p><ul><li><p>bounce.tsx 左侧的抽屉（点击打开关闭）</p></li><li><p>dimension.tsx 下方的缩略图（minimap）</p></li><li><p>header.tsx 画布上方的顶栏（意图名称、设置、发布等等）</p></li><li><p>topbar.tsx 对话单元模块的顶部（对话单元的icon，编辑按钮，删除按钮x）</p></li><li><p>option.tsx 对话单元模块的区域（跳转关系等，使用endpoint.hoc.tsx包裹生成端点间连接能力）</p></li><li><p>lemma.tsx 对话单元模块的区域（默认文案、添加关系等）</p></li></ul><h3 id="configs"><a href="#configs" class="headerlink" title="configs"></a>configs</h3><ul><li><p>block.config.ts 处理对话单元数据（格式化，一些ENUM定义，提取数据中有关单元信息等的文件）</p></li><li><p>instance.config.ts 画布实例配置（全局加锁，用于打开编辑框时）</p></li><li><p>jsplumb.config.ts 画布相关配置（点、线、画布等）</p></li></ul><h3 id="forms"><a href="#forms" class="headerlink" title="forms"></a>forms</h3><p>表单类信息</p><p>test.form(style).ts 编辑对话单元详情的文件，非常非常大，希望以后有谁来拆分出来！</p><p>trigger.form.ts 以前用来编辑触发器的文件</p><h3 id="hoc高阶组件"><a href="#hoc高阶组件" class="headerlink" title="hoc高阶组件"></a>hoc高阶组件</h3><p>drag.hoc.tsx 赋予组件拖动能力，设置对话单元的初始位置（top left），新增端点</p><p>endpoint.hoc.tsx 赋予对话单元模块中的端点能力，包括鼠标进出的效果。</p><h2 id="配合操作"><a href="#配合操作" class="headerlink" title="配合操作"></a>配合操作</h2><p><strong>index.tsx</strong> 作为画布的入口文件，是输出和渲染画布的主要文件。当路由解析到对应画布的路由的时候，index.tsx就被激活了！</p><p>首先会经历一段生命周期，在即将装载的时候会获取一部分数据，以及注册一些方法（展示自动保存）。</p><p>装载完成后有个监听和 pushState 操作，这一步操作是为了防止mac用户在操作电脑的时候「左滑 移动 画布」直接触发历史回退，做了拦截。</p><p>其他都比较常规，属于看看注释就能看懂的。</p><p><strong>visual.data.ts</strong> 是定义了画布内所有接口的文件，基本上在书写画布内代码的时候想要找的接口在这里都能找的！</p><p><strong>visual.style.ts</strong> 画布内的大部分样式都在这里，除了对话单元编辑抽屉 和 触发器编辑抽屉</p><p><strong>controlsView.tsx</strong> 画布页面左侧的对话单元陈列区域，拥有点击添加、拖拽（拖拽起点监听）添加等的能力。</p><p><strong>canvasView.tsx</strong> 画布区域！实例化画布，渲染画布所需要的各种数据结构， 绑定所有建立关联的事件：</p><ul><li><p>鼠标移入；</p></li><li><p>鼠标移出；</p></li><li><p>删除连接；</p></li><li><p>建立连接（分为触发器-对话单元，对话单元-对话单元）；</p></li><li><p>拖拽放置新建(onDrop监听nativeEvent , 通过layerX\Y来确定放置位置等)；</p></li></ul><h2 id="业务迷惑行为学大赏"><a href="#业务迷惑行为学大赏" class="headerlink" title="业务迷惑行为学大赏"></a>业务迷惑行为学大赏</h2><h3 id="1-填槽顺序调整"><a href="#1-填槽顺序调整" class="headerlink" title="1. 填槽顺序调整"></a>1. 填槽顺序调整</h3><p>1.1 什么是填槽顺序？</p><p>如果一个意图中有多个询问单元或多个隐藏单元，在两种情况下，任务机器人需要用户手动进行流程校准才可以保证机器人跳转正常：</p><p>第一种情况：用户的消息可以同时填入多个对话单元对应的槽，这时优先填哪个槽？</p><p>第二种情况：用户的消息能更新意图下的某个词槽，这个词槽没有跟当前停留的单元绑定。这时应该：</p><p>让当前单元处理这条消息，还是：</p><p>让这条消息去填充能够填充的那个词槽，再让流程跳回重新判断</p><p>我们通过规定绑定了词槽的单元顺序（询问单元、隐藏单元）来解决这个问题。对于以上两个问题，只要根据这个顺序确定就可以了。</p><p>对于case A：按照单元顺序，排在前面的优先填</p><p>对于case B：按照单元顺序，如果被更新的词槽在当前词槽前面，就更新词槽；如果在后面，就让当前单元处理这条消息；</p><p>拖动单元前的 “把手” 进行排序；</p><h3 id="1-2-代码层面："><a href="#1-2-代码层面：" class="headerlink" title="1.2 代码层面："></a>1.2 代码层面：</h3><p>在这个功能当中，发挥作用的字段为 <code>first_order</code></p><p>如图中所示，自上而下，降序排列；</p><p>不同于对话单元生成时候增长的 order_id，一开始所有单元的 first_order 都是0，只有 type === ‘BLOCK-ASK’ || type === ‘BLOCK-HIDE’的单元在第一次保存校准值之后才会拥有自己的first_order，而且是递减的降序排列；</p><h2 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h2><h3 id="连线的数据结构？"><a href="#连线的数据结构？" class="headerlink" title="连线的数据结构？"></a>连线的数据结构？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A: [&#123; from: relation_id, to: block_id &#125;......] 从 id 到 id。</span><br></pre></td></tr></table></figure><h3 id="拖拽后块结构之间的连线是怎么实现的？"><a href="#拖拽后块结构之间的连线是怎么实现的？" class="headerlink" title="拖拽后块结构之间的连线是怎么实现的？"></a>拖拽后块结构之间的连线是怎么实现的？</h3><p>A: 连线分为两种模式：1. 画布中拖拽连接；2. 编辑器中设置跳转关系；</p><p>方式不同，但是最后都是通过改变渲染画布中连接关系的数据结构来实现连\删线的。</p><h3 id="是否有画布能承载的最大单元数？"><a href="#是否有画布能承载的最大单元数？" class="headerlink" title="是否有画布能承载的最大单元数？"></a>是否有画布能承载的最大单元数？</h3><p>A: 前端没有做限制，在数据层似乎有个最大数的限制，🎙康师傅？</p><h3 id="单元边上的端点是如何设置的？"><a href="#单元边上的端点是如何设置的？" class="headerlink" title="单元边上的端点是如何设置的？"></a>单元边上的端点是如何设置的？</h3><p>A: JSPlumb提供了方法 jsp.addEndpoint;</p><h3 id="连线上的删除icon是怎么放上去的"><a href="#连线上的删除icon是怎么放上去的" class="headerlink" title="连线上的删除icon是怎么放上去的?"></a>连线上的删除icon是怎么放上去的?</h3><p>A: JSPlumb提供了方法 getInstance().onConnectionOver 去设置;</p><h3 id="每次改变时候草稿自动更新，是做的差量计算吗，都保存了那些值来对比是否改变了并存在哪里了？"><a href="#每次改变时候草稿自动更新，是做的差量计算吗，都保存了那些值来对比是否改变了并存在哪里了？" class="headerlink" title="每次改变时候草稿自动更新，是做的差量计算吗，都保存了那些值来对比是否改变了并存在哪里了？"></a>每次改变时候草稿自动更新，是做的差量计算吗，都保存了那些值来对比是否改变了并存在哪里了？</h3><p>A: 不是。更新的时候就是各自对应的接口的调用、传递、保存，只不过是全局做了一个动画来表示我们刚刚调用过接口；</p><h3 id="拖动时，连接线的变化是如何实现的？"><a href="#拖动时，连接线的变化是如何实现的？" class="headerlink" title="拖动时，连接线的变化是如何实现的？"></a>拖动时，连接线的变化是如何实现的？</h3><p>A: JSPlumb 工具实现好了，只要线连接上，移动对话单元，连接线也可以自己跟着跑；</p><h3 id="左侧拖拽组件是画布自带的吗？拖拽是什么实现的？左侧的展示区域中的对话单元是怎么做到拖动到画布中的？"><a href="#左侧拖拽组件是画布自带的吗？拖拽是什么实现的？左侧的展示区域中的对话单元是怎么做到拖动到画布中的？" class="headerlink" title="左侧拖拽组件是画布自带的吗？拖拽是什么实现的？左侧的展示区域中的对话单元是怎么做到拖动到画布中的？"></a>左侧拖拽组件是画布自带的吗？拖拽是什么实现的？左侧的展示区域中的对话单元是怎么做到拖动到画布中的？</h3><p>A: 左侧展示区域并不是画布内的功能，参照 controlsView.tsx;</p><h3 id="拖拽是给-div-增加了-draggable属性；"><a href="#拖拽是给-div-增加了-draggable属性；" class="headerlink" title="拖拽是给 div 增加了 draggable属性；"></a>拖拽是给 div 增加了 draggable属性；</h3><p>参照canvasView.tsx文件所述，监听了画布区域中的onDrop事件，触发了一个方法</p><p>dropHandle，记录了（新的单元，位置信息，名字，种类等），调用新增对话单元的接口，同时更新树，渲染到画布中，等到接口返回数据，再更新redux中的block-list；</p><h3 id="hover多端点的对应项时候，如何做到对应项的连接线也同样变化？"><a href="#hover多端点的对应项时候，如何做到对应项的连接线也同样变化？" class="headerlink" title="hover多端点的对应项时候，如何做到对应项的连接线也同样变化？"></a>hover多端点的对应项时候，如何做到对应项的连接线也同样变化？</h3><p>A: 参照 block.tsx 中的 option.tsx ，他使用 endpoint.hoc.tsx 高阶组件包裹了每一个跳转关系选项，再联合上 jsplumb.config.tsx 中hover线变色的配置，达成了这个效果；</p><h3 id="底部缩略图如何实现的？"><a href="#底部缩略图如何实现的？" class="headerlink" title="底部缩略图如何实现的？"></a>底部缩略图如何实现的？</h3><p>A: 参照 dimension.tsx 下方的缩略图（minimap）；</p><h3 id="点击还原时，接口返回的值如何对应的，还原出之前的画布？"><a href="#点击还原时，接口返回的值如何对应的，还原出之前的画布？" class="headerlink" title="点击还原时，接口返回的值如何对应的，还原出之前的画布？"></a>点击还原时，接口返回的值如何对应的，还原出之前的画布？</h3><p>A: 返回的数据就和初始拿到的一样即可，就是一次重新打开（渲染）的过程而已；</p><h3 id="画布内块结构位置是怎么保存的？"><a href="#画布内块结构位置是怎么保存的？" class="headerlink" title="画布内块结构位置是怎么保存的？"></a>画布内块结构位置是怎么保存的？</h3><p>A: 画布内的对话单元的位置的改变有三种情况：</p><p>点击左侧展示区对应的对话单元生成；</p><p>拖拽左侧展示区相应的对话单元生成；</p><p>挪动画布中的对话单元；</p><p>画布中还有一个特殊单位：触发器，他的位置只有挪动改变；</p><p><strong>点击</strong>生成的时候，直接按照规则给出当前的pos（x, y），存储到数据中；</p><p><strong>拖拽</strong>生成的时候，通过监听事件onDrop，触发了dropHandle，记录pos（event.layerX, event.layerY）;</p><p><strong>挪动</strong>对话单元、触发器的时候，参照 drag.hoc.tsx JSPlumb 提供了 getInstance().jsp.draggable的api，监听了拖拽的始末时刻，得到数值，调用接口存储；</p><h3 id="在重新打开画布的时候会恢复之前的位置，如何实现？"><a href="#在重新打开画布的时候会恢复之前的位置，如何实现？" class="headerlink" title="在重新打开画布的时候会恢复之前的位置，如何实现？"></a>在重新打开画布的时候会恢复之前的位置，如何实现？</h3><p>A: 拿到数据之后，通过 drag.hoc.tsx 文件中的 render 中的 style，告诉每个对话单元的位置，利用DOM的能力放置每一个对话单元；</p><h3 id="redux都存了什么？"><a href="#redux都存了什么？" class="headerlink" title="redux都存了什么？"></a>redux都存了什么？</h3><p>A: 存了好多东西。</p><p>画布的redux存储的是画布相关操作引起的变化：</p><p>增\删\改对话单元</p><p>初始化跳转关系连接</p><p>增\删\改 跳转关系</p><p>开\关抽屉</p><p>画布加锁</p><p>简而言之分成3类，画布中 对话单元 （block）、画布中 跳转关系 （connection）、界面 UI。</p>]]></content>
      
      
      
        <tags>
            
            <tag> React Redux JsPlumb Dom </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>划词标注编辑器开发之旅</title>
      <link href="/2020/04/05/%E5%88%92%E8%AF%8D%E6%A0%87%E6%B3%A8%E7%BC%96%E8%BE%91%E5%99%A8%E5%BC%80%E5%8F%91%E4%B9%8B%E6%97%85/"/>
      <url>/2020/04/05/%E5%88%92%E8%AF%8D%E6%A0%87%E6%B3%A8%E7%BC%96%E8%BE%91%E5%99%A8%E5%BC%80%E5%8F%91%E4%B9%8B%E6%97%85/</url>
      
        <content type="html"><![CDATA[<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfl5oaitupj314x0u0ahu.jpg" alt=""></p><h1 id="技术方案"><a href="#技术方案" class="headerlink" title="技术方案"></a>技术方案</h1><p>类似于如何把大象塞进冰箱，句式操作页面总共分为三个大块：</p><ol><li>初始化数据；（打开冰箱门）</li><li>编辑操作；（把大象塞进去）</li><li>存储数据；（关上冰箱门）</li></ol><h1 id="一、初始化步骤"><a href="#一、初始化步骤" class="headerlink" title="一、初始化步骤"></a>一、初始化步骤</h1><p>在一个页面中的句式或许有非常多条（例如任务对话 中的意图触发器），也可能只有一条（任务对话中的填槽句式页面），但是对于句式编辑器来说，一个编辑器对应一条句式。</p><p>那么编辑器肯定不会“无中生有”，它所要展示的内容均来自于接口传递的句式数据。这份数据结构中最重要的几个key分别是”content”、”notations”。”content”代表的是句式中存储的文本信息，而”notations”存储的是句式中的词槽实体信息——包括位置、长度、和对应id。</p><p>因此，在初始化的时候就进行第一次判断——“notations”字段是否为空，如果为空，说明当前句式中并没有词槽实体信息，就是一个纯文本，可以根据”content”中的内容直接展示；如果不为空，则说明有词槽实体，需要对应的替换后再展示给用户。</p><p>替换的方式简单说明一下：”notations”字段接收到的数据是一个数组，里面每一项对应的是一组「词槽slot_id-实体entity_id」，除此之外还有两个字段”start_index”、”length”，”start_index”表示这一组「词槽-实体」对应在存储的句式文本”content”中的下标位置，”length”自然就是代表他们所占的长度，通过这3个数据就能把句式文本中的占位符”[ATID:xx]”替换成为用户喜闻乐见的”@城市:北京”。</p><p>「atInfoStore」，顾名思义，他是一个存储“@”信息的变量。这个是纯前端应用的工具字段，在初始化的过程中也初始化了「atInfoStore」，每当解析完一组完整的「词槽-实体、实体」，就会对应地往「atInfoStore」中推一组数据，key为atid，value为词槽和实体信息，并且有一个原则贯穿其中——只增不减，具体下文中详述。</p><p>那么高亮是怎么做到的？其实文本不是简单的设置<code>&lt;textarea /&gt;\&lt;input /&gt;</code>中的value，句式编辑器是一个<code>&lt;div contenteditable=&quot;true&quot;&gt;...&lt;/div&gt;</code>的开启了编辑功能的div。句式的文本内容”content”其实是作为一个文本节点插入了进去，在上一步初始化词槽实体的过程中将对应的数据使用<code>&lt;span id=&quot;atid&quot;&gt;</code>标签包裹了起来，并且在css中设置<code>&lt;span&gt;</code>标签的不可选中已经背景色的变换就实现了高亮。</p><h1 id="二、修改句式"><a href="#二、修改句式" class="headerlink" title="二、修改句式"></a>二、修改句式</h1><p>修改也分成两种修改：1. 普通的文本输入；2. 增删改「词槽-实体」信息</p><p>第一种没有什么好说的，直接修改的是”content”中的内容；</p><p>第二种展开叙述一下：</p><h2 id="1-增加"><a href="#1-增加" class="headerlink" title="1. 增加"></a>1. 增加</h2><p>句式编辑器监听了输入，每当用户输入”@“符号的时候就会自动记录当前光标的在文本中的位置并且弹出词槽实体选择框，当选择「词槽-实体、实体」完毕之后，句式编辑器先往「atinfoStore」里面推了一条新的数据，key: atid负向增长，value: 还是老样子词槽和实体的信息，同时生成了一个dom节点——<code>&lt;span id=&quot;newatid&quot;&gt;@词槽：实体、实体&lt;/span&gt;</code>，这个dom节点随即插入到了之前记录的位置上，这样一次简单的增加”@”信息的操作就完成了。</p><h2 id="2-改"><a href="#2-改" class="headerlink" title="2. 改"></a>2. 改</h2><p>用户鼠标点击对应的高亮区域，句式编辑器从高亮区域的dom节点<code>&lt;span id=”xxatid“&gt;...&lt;/span&gt;</code>中取出「xxatid」，然后从atInfoStore中读取到对应的「词槽-实体」信息填入到跳出的编辑词槽信息的弹窗内；等到用户修改完毕之后，点击保存会重新走一遍「1. 增加」的流程。需要注意的是，为了避免复杂的页面节点的替换操作，我做的是删除掉原有节点，重新生成新节点插入到原有的位置上，因此，在修改某一处”@”信息时，atInfoStore中的数据会增加一条新的atId对应的词槽实体数据，而不是修改原有「xxatid」对应的信息。</p><h2 id="3-删"><a href="#3-删" class="headerlink" title="3. 删"></a>3. 删</h2><p>这也没说的，删了就没了。</p><h1 id="三、保存句式"><a href="#三、保存句式" class="headerlink" title="三、保存句式"></a>三、保存句式</h1><p>为了简化保存时的计算，我特意在编辑器里面做了判断，所有的修改动作都会被判定为原有的句式发生了变化，哪怕是加了一个字又删除掉。如果句式没有发生改变，直接跳过调用接口；如果发生了改变，那么就发生了以下的操作；<br>我之前说了，在页面上展示的并不是简单的文本，而是文本节点和span包裹的节点，这些信息是无法直接读取且保存到数据库中的，所以第一步就是把HTML元素转换成存储的数据。由于在编辑过程中，所有需要转换的部分都被很好的包裹在了带有id的span标签中，在转换HTML元素的时候我只需要把「span」标签以及标签中的「id」提取出来，id可以对应地从「atInfoStore」中找到词槽-实体信息，而span的存在可以很快的进行占位符「[ATID:xx]」的替换。</p><p>被占位符替换完的数据就可以直接存储到”content”字段当中，而对应地从「atInfoStore」中读取的词槽-实体信息，就被一条一条塞入到”notations”字段当中；<br>最后把它们拼成接口所需要的数据结构，调用graphQL接口提交保存即可；</p><h1 id="背景技术"><a href="#背景技术" class="headerlink" title="背景技术"></a>背景技术</h1><p>句式编辑器使用的是HTML自己本身的<code>contenteditable</code>能力；弹窗则是采用了ant-design的popover；接口是使用了GraphQL的技术；</p><h1 id="效果以及优点"><a href="#效果以及优点" class="headerlink" title="效果以及优点"></a>效果以及优点</h1><p>句式编辑器为定制化需求开发，市面上没有找到现成的可以直接使用的富文本编辑器，这是属于来也科技的编辑器。在时间的证明下，它很好地为任务对话提供了触发和收集词槽的功能，用户不需要使用繁琐的表格进行配置，只需要轻松地输入”@“符号即可快速呼出弹窗选择词槽和实体，极快速地配置以及简单明了的操作界面，在很大程度上降低了用户学习和使用词槽-实体的成本。</p>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScript DOM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>single-spa实现通信</title>
      <link href="/2019/11/14/single-spa%E5%AE%9E%E7%8E%B0%E9%80%9A%E4%BF%A1/"/>
      <url>/2019/11/14/single-spa%E5%AE%9E%E7%8E%B0%E9%80%9A%E4%BF%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="需求背景"><a href="#需求背景" class="headerlink" title="需求背景"></a>需求背景</h1><p>在single-spa大的环境下，每一个子App都是一个独立的个体。独立意味着我们会有如下的几个需求：</p><ul><li>每个应用程序拥有着自己的状态和变量，同时没有应用程序知道另一个应用程序或他们的数据模型的内部状态。总之，每个应用程序被视为黑盒，并且可以由不同的团队进行维护；</li><li>每个应用程序必须能够有一个复杂的状态；</li><li>当你的应用程序之间导航，状态不容有失（因为组件会挂载/卸载）。</li></ul><h1 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h1><h2 id="事件系统"><a href="#事件系统" class="headerlink" title="事件系统"></a>事件系统</h2><p>为了满足这些要求，我已经决定了使用「事件系统」，其中每个应用程序可以选择是否监听其他应用程序发送的事件。这使得每个应用程序可以监听到其他应用程序发生了变化后，只修改自己的状态，以保持它们的隔离状态。</p><p>没有应用程序需要<strong>直接访问</strong>另一个应用程序的状态。</p><h2 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h2><p>此外，我需要的应用程序分为两个部分。一个是正​​常应用本身（GUI，框架等），另一个“通讯层”是独立模块，可以被门户（portal) <strong>加载/实例化</strong>而与应用状态无关。</p><p>这允许每个应用程序监听和响应事件，即使它们没有挂载。</p><p>每个应用程序都可以按照自己喜欢的方式处理这些事件。唯一的要求是所有的应用程序都同意一个事件格式来发送和接收这些事件。</p><h1 id="方案实现"><a href="#方案实现" class="headerlink" title="方案实现"></a>方案实现</h1><h2 id="Redux"><a href="#Redux" class="headerlink" title="Redux"></a>Redux</h2><p>对于这个例子，我决定使用redux，因为它基本上完全满足我的需要：</p><ul><li>抛出事件</li><li>处理事件</li></ul><p>tips：但是这个系统可以使用任何你喜欢的技术。</p><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><h3 id="概念图"><a href="#概念图" class="headerlink" title="概念图"></a>概念图</h3><p>接下来这是一个图表，它说明了实际发生了什么：<br><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8xg0iyewpj30ir0d3my2.jpg" alt=""></p><p>图表中的重要组成信息：</p><ol><li><strong>StoreApps</strong>: 包含状态+业务逻辑。实现可在发生全局事件时由GlobalEventDistributor调用的调度方法。</li><li><strong>GUIApps</strong>: singleSPA 中间件+ UI代码 如 HTML, CSS, Controller等+框架如 React 或 Angular singleSPA中间件+ UI代码</li><li><strong>GlobalEventDistributor</strong>: 可以用来注册Store。向所有存储区发送调度事件。(观察者模式)</li></ol><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><ol><li>根应用程序引导并加载所有存储区（stores）并实例化它们。这是必要的，因为我们需要通信层(存储区)始终处于活动状态。即使整个应用程序还没有挂载。否则，没有应用程序的特定事件得到处理。</li><li>当应用程序被挂载时，根应用程序向下传递属于各个应用程序的已实例化的存储区。根应用程序还将『对GlobalEventDistributor的引用』传递给应用程序。</li><li>现在，您可以使用dispatch()方法将所有全局事件发送到GlobalEventDistributor，并将所有其他事件发送到本地存储。</li></ol><h1 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h1><p>如前所述，最大的缺点是必须在根应用程序加载时加载所有存储。<br>这样做的原因是，我们正在构建一个项目，该项目将有一个巨大的应用程序状态完全存储在浏览器中。<br>用户可能会在没有任何服务器通信的情况下输入1h的数据，一旦完成，用户通过一次单击将会保存所有内容。</p><p>然而，这不一定是您的用例。例如，如果您只对与当前活动的任何应用程序的应用程序间通信感兴趣，您可能不需要预先加载所有状态，而是在应用程序运行时加载它们。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webpack学习笔记</title>
      <link href="/2019/09/29/webpack%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2019/09/29/webpack%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>webpack的英文文档和<a href="https://webpack.docschina.org/configuration/output">中文文档</a>都非常完善！</p><h1 id="输出（output）"><a href="#输出（output）" class="headerlink" title="输出（output）"></a>输出（output）</h1><h2 id="output-library"><a href="#output-library" class="headerlink" title="output.library"></a>output.library</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>乾坤学习</title>
      <link href="/2019/09/11/%E4%B9%BE%E5%9D%A4/"/>
      <url>/2019/09/11/%E4%B9%BE%E5%9D%A4/</url>
      
        <content type="html"><![CDATA[<p>乾坤是阿里出品的一款基于single-spa搭建的框架，<br>git地址是：<a href="https://github.com/umijs/qiankun">https://github.com/umijs/qiankun</a></p><blockquote><p>乾是天，坤是地，乾坤就是全宇宙</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> qiankun singleSPA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微信小程序插件开发</title>
      <link href="/2019/07/16/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
      <url>/2019/07/16/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<h1 id="小程序插件"><a href="#小程序插件" class="headerlink" title="小程序插件"></a>小程序插件</h1><p>以目录结构为主简单介绍，注意，doc miniprogram plugin 名称均不可更改。</p><h2 id="doc"><a href="#doc" class="headerlink" title="doc"></a>doc</h2><p>该目录下存放的是小程序插件必备的说明文档“README.md”以及文档所需的图片，注意该目录下的README.md在微信小程序开发工具中需要单独提交。</p><h2 id="miniprogram"><a href="#miniprogram" class="headerlink" title="miniprogram"></a>miniprogram</h2><p>小程序插件开发的主体。</p><p>小程序插件必须依赖一个主体（小程序），因此在开发过程中会需要一个小程序，这个目录下的小程序就是模拟之后调用者的小程序。</p><p>不必担心提交的时候携带上这个目录会影响插件，因为微信官方审核的时候也是需要通过开发者在当前目录下写的小程序调用小程序插件来进行判断是否符合规范等。</p><h2 id="plugin"><a href="#plugin" class="headerlink" title="plugin"></a>plugin</h2><p>小程序插件开发的真正区域。</p><h3 id="api"><a href="#api" class="headerlink" title="api"></a>api</h3><p>小程序插件对外可调用的api，可以在miniprogram目录下找到调用插件的地方结合起来理解。</p><p>一般来说这里可以不用动。</p><h3 id="pages"><a href="#pages" class="headerlink" title="pages"></a>pages</h3><p>小程序插件的页面，虽然可以用多个，但是在吾来对话机器人插件中用不着，因此就只有一个chat页面，里面有小程序插件本体的HTML、CSS、JS。</p><h4 id="chat"><a href="#chat" class="headerlink" title="chat"></a>chat</h4><p>按照生命周期了解功能。</p><ol><li><p>首先进入插件后就触发 <code>ready</code> 这个生命周期钩子；<br>在这个生命周期内进行了一系列操作：</p><ul><li>把调用方传递参数本地化；</li><li>判断是否已经登录，如果调用方在吾来后台把调用者的小程序的appId和appSecret传递给我们了，那么如果调用方传递的参数<code>username: &#39;&#39;</code>，那么我们就可以帮忙做登录，如果调用方自己有能力，就可以自己登录完毕，把登录完毕换回的<code>openid</code>存在<code>username</code>字段中传递给插件，详情请阅读doc下的README.md;</li><li>登陆完毕之后调用<code>startWork</code>开始插件的基础设置——是否展示历史消息、头像是什么、气泡什么样……详情请参见<a href="http://openapi-docs-inner.wul.ai/docs/1.9.0/channel_backend/channel_backend.html#operation/Start">后端开放平台接口</a></li></ul><p>登录操作和启动操作都完成后就可以开始工作了。</p></li></ol><h3 id="components"><a href="#components" class="headerlink" title="components"></a>components</h3><p>页面要调用的组件，小程序调用插件的方法可以查阅官方文档</p><p>工具类: module-*<br>消息类型: msg-*<br>用户消息: user-msg<br>机器人回复: bot-msg<br>提示消息组件: notice-msg</p><p>代码内部做了详细的注释，阅读起来应该没有很大的问题。</p><h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><p>一些静态文件，小图标等，大的图片考虑上传阿里云；</p><h3 id="utils"><a href="#utils" class="headerlink" title="utils"></a>utils</h3><h4 id="constant-js"><a href="#constant-js" class="headerlink" title="constant.js"></a>constant.js</h4><p>存放了一些常量：</p><ul><li>接口的path</li><li>项目内常用的一些常量（看见大写的变量不懂的话来这里看看）</li></ul><h4 id="env-js"><a href="#env-js" class="headerlink" title="env.js"></a>env.js</h4><p>按照注释做，用于区分测试环境还是灰度正式环境，影响到的是后端接口的host</p><h4 id="promisify-js"><a href="#promisify-js" class="headerlink" title="promisify.js"></a>promisify.js</h4><p>封装了promise方法，想要调用Promise请求的时候可以考虑从这里引用。</p><h4 id="request-js"><a href="#request-js" class="headerlink" title="request.js"></a>request.js</h4><p>封装了POST和GET方法</p><h4 id="util-js"><a href="#util-js" class="headerlink" title="util.js"></a>util.js</h4><p>封装了一些项目中通用的方法</p><h4 id="watch-js"><a href="#watch-js" class="headerlink" title="watch.js"></a>watch.js</h4><p>ohhhhh,这个文件没啥用。</p><hr><p>以上就是对于小程序插件的介绍，相关配置<code>project.config.json</code> <code>plugin.json</code> <code>app.json</code>可以通过官方文档对照学习使用，很easy的。</p><h1 id="如何应对定制化"><a href="#如何应对定制化" class="headerlink" title="如何应对定制化"></a>如何应对定制化</h1><p>定制化需要考虑功能是否是必须从基础版本中脱离出来的，如果是，那么继续。</p><h2 id="需要一个新的插件"><a href="#需要一个新的插件" class="headerlink" title="需要一个新的插件"></a>需要一个新的插件</h2><p>这意味着需要一份新鲜的代码<br><a href="https://gitlab.com/laiye-frontend-repos/wechat-sdk">吾来小程序插件Gitlab地址</a><br>进入并且Fork到新的仓库中，仍然会进行开发。</p><p>代码有了，还需要一个<a href="https://mp.weixin.qq.com/">微信后台账号</a>，找到负责的产品去新建就完了。</p><p>新建完毕之后按照正常小程序插件开发流程去配置，下载一个‘微信小程序开发工具’进行本地的开发即可。</p><h2 id="如果需要更新"><a href="#如果需要更新" class="headerlink" title="如果需要更新"></a>如果需要更新</h2><p>Fork的版本如果想要更新到通用版的某个更加新的版本，可以通过新建Merge Request来解决。</p><h2 id="定制化"><a href="#定制化" class="headerlink" title="定制化"></a>定制化</h2><h3 id="保乐力加定制化"><a href="#保乐力加定制化" class="headerlink" title="保乐力加定制化"></a>保乐力加定制化</h3><h4 id="需求："><a href="#需求：" class="headerlink" title="需求："></a>需求：</h4><ol><li>可以在插件内部点击消息中的链接跳转到<strong>调用方小程序</strong>内部的某个页面；</li><li>可以在插件内部点击消息中的链接跳转到<strong>其他的小程序</strong>的某个页面；</li></ol><hr><h4 id="跳转方案："><a href="#跳转方案：" class="headerlink" title="跳转方案："></a>跳转方案：</h4><p>小程序插件开发有诸多限制，小程序插件的wx对象和调用者的wx（后面用WX来表示）对象是不同的，在官方文档中插件内部的跳转的api虽然不被限制，但是实际的效果却是只能在小程序插件内部的页面中切换跳转。</p><p>因此采用了HACK的方式，在小程序插件内部获取到了调用方小程序的 WX 对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 调用方的js文件 --&gt;</span><br><span class="line">plugin.<span class="title function_">init</span>(wulAiSDK, wx, pubkey, userInfo);</span><br><span class="line"></span><br><span class="line">&lt;!-- 小程序插件内部调用<span class="variable constant_">WX</span> --&gt;</span><br><span class="line">&lt;!-- 需求<span class="number">1</span> --&gt;</span><br><span class="line"><span class="variable constant_">WX</span>.<span class="title function_">navigateTo</span>()</span><br><span class="line">&lt;!-- 需求<span class="number">2</span> --&gt;</span><br><span class="line"><span class="variable constant_">WX</span>.<span class="title function_">navigateToMiniProgram</span>()</span><br></pre></td></tr></table></figure><h4 id="触发跳转方案"><a href="#触发跳转方案" class="headerlink" title="触发跳转方案"></a>触发跳转方案</h4><p>在已有的消息类型，如CUSTOM消息类型中的content字段中存储上跳转所需的<code>appId pathUrl</code>等所需信息，当有这个类型的消息到达时，在对应的 “/components/msg-custom”（新建）组件中去处理content字段中携带的信息，并且以链接的形式呈现在消息卡片中，当用户点击的时候触发方法进行跳转。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 微信小程序插件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Single-Spa学习</title>
      <link href="/2019/07/15/Single-Spa%E5%AD%A6%E4%B9%A0/"/>
      <url>/2019/07/15/Single-Spa%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="触摸single-spa之道"><a href="#触摸single-spa之道" class="headerlink" title="触摸single-spa之道"></a>触摸single-spa之道</h1><h2 id="什么是single-spa？"><a href="#什么是single-spa？" class="headerlink" title="什么是single-spa？"></a>什么是single-spa？</h2><blockquote><p>single-spa是一个在前端应用程序中汇集多个javascript微内容的框架。 使用single-spa构建您的前端可带来许多好处，例如：</p></blockquote><blockquote><ul><li>在同一页面上使用多个框架而无需刷新页面（React，AngularJS，Angular，Ember或您正在使用的任何内容）</li><li>独立部署微内容。</li><li>使用新框架编写代码，而无需重写现有应用程序</li><li>延迟加载代码，用于改善初始加载时间。</li></ul></blockquote><h3 id="诞生概述"><a href="#诞生概述" class="headerlink" title="诞生概述"></a>诞生概述</h3><p>single-spa通过将生命周期应用于整个应用程序，从现代框架组件生命周期中获取灵感。 它的诞生起源于Canopy希望使用 <code>React + react-router</code> 而不是永远坚持使用我们的<code>AngularJS + ui-router</code>应用程序，现在single-spa支持几乎所有框架。<br>    由于JavaScript因其众多框架的短命而臭名昭着，因此single-spa的设计者决定让开发者们想要的任何框架都很容易。</p><ol><li><p>应用程序，每个应用程序本身就是一个完整的SPA（有点）。 每个应用程序都可以响应url路由事件，并且必须知道如何从DOM引导，装载和卸载它们。 传统SPA和单一spa应用程序之间的主要区别在于它们必须能够与其他应用程序共存，并且它们不是每个都有自己的html页面。</p><p>例如，您的React或Angular SPA是应用程序。 处于活动状态时，它们会侦听URL路由事件并将内容放在DOM上。 处于非活动状态时，它们不会侦听url路由事件，而是完全从DOM中删除。</p></li></ol><ol start="2"><li>单个spa-config，它是html页面和使用single-spa注册应用程序的JavaScript。 每个应用程序都注册了三件事：</li></ol><ul><li>一个名字</li><li>加载应用程序代码的函数</li><li>用于确定应用程序何时处于活动/非活动状态的功能</li></ul><h3 id="很难使用吗？"><a href="#很难使用吗？" class="headerlink" title="很难使用吗？"></a>很难使用吗？</h3><h4 id="从技术栈架构上来说"><a href="#从技术栈架构上来说" class="headerlink" title="从技术栈架构上来说"></a>从技术栈架构上来说</h4><p>single-spa适用于 ES5，ES6 +，TypeScript，Webpack，SystemJS，Gulp，Grunt，Bower，ember-cli或任何可用的构建系统。 开发者可以通过npm安装它，jspm安装它，或者如果愿意，甚至只需使用<script>标记。</p><p>作者的目标是尽可能简单地使用single-spa。<br>但作者也指出，这是一种先进的架构，与前端应用程序的典型工作方式不同。</p><h4 id="从浏览器层面来说"><a href="#从浏览器层面来说" class="headerlink" title="从浏览器层面来说"></a>从浏览器层面来说</h4><p>single-spa适用于Chrome，Firefox，Safari，IE11和Edge。</p><h2 id="储备知识"><a href="#储备知识" class="headerlink" title="储备知识"></a>储备知识</h2><p>这里记录我在阅读了官网文档已经一些最佳实践之后归纳出的储备知识。<br>对于前端来说，要解决的问题一般分为两种阶段:</p><ol><li>开发阶段；</li><li>部署阶段；</li></ol><p>其中开发阶段要解决：</p><ol><li>第三方包的安装、使用、依赖的维护；</li><li>自有代码的维护和使用；</li></ol><h3 id="SystemJs"><a href="#SystemJs" class="headerlink" title="SystemJs"></a>SystemJs</h3><p>为什么要用 SystemJS ？<br>因为如果在项目中如果只使用单一规范，比如针对 AMD，我们可能会用 RequireJS；ES6 的模块，我们可能会用到 ES6 Module Loader Polyfill；CommonJS 规范的模块，我们可能用 SystemJS – 它同样可用于加载 AMD/ES6 模块。<br>systemjs 是一个最小系统加载工具，用来创建插件来处理可替代的场景加载过程，包括加载 CSS 场景和图片，主要运行在浏览器和 NodeJS 中。它是 ES6 浏览器加载程序的的扩展，将应用在本地浏览器中。通常创建的插件名称是模块本身，要是没有特意指定用途，则默认插件名是模块的扩展名称。</p><p>通常它支持创建的插件种类有：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># <span class="variable constant_">CSS</span> </span><br><span class="line"><span class="title class_">System</span>.<span class="keyword">import</span>(<span class="string">&#x27;my/file.css!&#x27;</span>)</span><br><span class="line"></span><br><span class="line"># <span class="title class_">Image</span> </span><br><span class="line"><span class="title class_">System</span>.<span class="keyword">import</span>(<span class="string">&#x27;some/image.png!image&#x27;</span>)</span><br><span class="line"></span><br><span class="line"># <span class="title class_">JSON</span> </span><br><span class="line"><span class="title class_">System</span>.<span class="keyword">import</span>(<span class="string">&#x27;some/data.json!&#x27;</span>).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">json</span>)&#123;&#125;)</span><br><span class="line"></span><br><span class="line"># <span class="title class_">Markdown</span> </span><br><span class="line"><span class="title class_">System</span>.<span class="keyword">import</span>(<span class="string">&#x27;app/some/project/README.md!&#x27;</span>).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">html</span>) &#123;&#125;)</span><br><span class="line"></span><br><span class="line"># <span class="title class_">Text</span> </span><br><span class="line"><span class="title class_">System</span>.<span class="keyword">import</span>(<span class="string">&#x27;some/text.txt!text&#x27;</span>).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">text</span>) &#123;&#125;)</span><br><span class="line"></span><br><span class="line"># <span class="title class_">WebFont</span> </span><br><span class="line"><span class="title class_">System</span>.<span class="keyword">import</span>(<span class="string">&#x27;google Port Lligat Slab, Droid Sans !font&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="Webpack"><a href="#Webpack" class="headerlink" title="Webpack"></a>Webpack</h3>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>划词标注编辑器开发之旅</title>
      <link href="/2019/07/10/%E5%89%8D%E7%AB%AF%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"/>
      <url>/2019/07/10/%E5%89%8D%E7%AB%AF%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/</url>
      
        <content type="html"><![CDATA[<h1 id="前端代码规范"><a href="#前端代码规范" class="headerlink" title="前端代码规范"></a>前端代码规范</h1><ul><li>使用字面语法来创建对象。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">const</span> item = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">const</span> item = &#123;&#125;;</span><br></pre></td></tr></table></figure><ul><li>在对象声明的时候将简写的属性进行分组。</li></ul><blockquote><p>为什么? 这样更容易的判断哪些属性使用的简写。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> anakinSkywalker = <span class="string">&#x27;Anakin Skywalker&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> lukeSkywalker = <span class="string">&#x27;Luke Skywalker&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">episodeOne</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">twoJediWalkIntoACantina</span>: <span class="number">2</span>,</span><br><span class="line">  lukeSkywalker,</span><br><span class="line">  <span class="attr">episodeThree</span>: <span class="number">3</span>,</span><br><span class="line">  <span class="attr">mayTheFourth</span>: <span class="number">4</span>,</span><br><span class="line">  anakinSkywalker,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  lukeSkywalker,</span><br><span class="line">  anakinSkywalker,</span><br><span class="line">  <span class="attr">episodeOne</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">twoJediWalkIntoACantina</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">episodeThree</span>: <span class="number">3</span>,</span><br><span class="line">  <span class="attr">mayTheFourth</span>: <span class="number">4</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>尽量使用对象扩展操作符，而不是用 Object.assign 浅拷贝一个对象。 使用对象的 rest 操作符来获得一个具有某些属性的新对象。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// very bad</span></span><br><span class="line"><span class="keyword">const</span> original = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> copy = <span class="title class_">Object</span>.<span class="title function_">assign</span>(original, &#123; <span class="attr">c</span>: <span class="number">3</span> &#125;); <span class="comment">// 变异的 `original` ಠ_ಠ</span></span><br><span class="line"><span class="keyword">delete</span> copy.<span class="property">a</span>; <span class="comment">// 这....</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">const</span> original = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> copy = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, original, &#123; <span class="attr">c</span>: <span class="number">3</span> &#125;); <span class="comment">// copy =&gt; &#123; a: 1, b: 2, c: 3 &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">const</span> original = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> copy = &#123; ...original, <span class="attr">c</span>: <span class="number">3</span> &#125;; <span class="comment">// copy =&gt; &#123; a: 1, b: 2, c: 3 &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; a, ...noA &#125; = copy; <span class="comment">// noA =&gt; &#123; b: 2, c: 3 &#125;</span></span><br></pre></td></tr></table></figure><ul><li>如果数组有多行，则在开始的时候换行，然后在结束的时候换行。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">const</span> arr = [</span><br><span class="line">  [<span class="number">0</span>, <span class="number">1</span>], [<span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>],</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> objectInArray = [&#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="number">1</span>,</span><br><span class="line">&#125;, &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="number">2</span>,</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> numberInArray = [</span><br><span class="line">  <span class="number">1</span>, <span class="number">2</span>,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">const</span> arr = [[<span class="number">0</span>, <span class="number">1</span>], [<span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>]];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> objectInArray = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="number">1</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="number">2</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> numberInArray = [</span><br><span class="line">  <span class="number">1</span>,</span><br><span class="line">  <span class="number">2</span>,</span><br><span class="line">];</span><br></pre></td></tr></table></figure><ul><li>对于多个返回值使用对象解构，而不是数组解构。</li></ul><blockquote><p>为什么? 你可以随时添加新的属性或者改变属性的顺序，而不用修改调用方。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">processInput</span>(<span class="params">input</span>) &#123;</span><br><span class="line">  <span class="comment">// 处理代码...</span></span><br><span class="line">  <span class="keyword">return</span> [left, right, top, bottom];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用者需要考虑返回数据的顺序。</span></span><br><span class="line"><span class="keyword">const</span> [left, __, top] = <span class="title function_">processInput</span>(input);</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">processInput</span>(<span class="params">input</span>) &#123;</span><br><span class="line">  <span class="comment">// 处理代码...</span></span><br><span class="line">  <span class="keyword">return</span> &#123; left, right, top, bottom &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用者只选择他们需要的数据。</span></span><br><span class="line"><span class="keyword">const</span> &#123; left, top &#125; = <span class="title function_">processInput</span>(input);</span><br></pre></td></tr></table></figure><ul><li>使用默认的参数语法，而不是改变函数参数。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// really bad</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">handleThings</span>(<span class="params">opts</span>) &#123;</span><br><span class="line">  opts = opts || &#123;&#125;;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// still bad</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">handleThings</span>(<span class="params">opts</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (opts === <span class="keyword">void</span> <span class="number">0</span>) &#123;</span><br><span class="line">    opts = &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">handleThings</span>(<span class="params">opts = &#123;&#125;</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>总是把默认参数放在最后。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">handleThings</span>(<span class="params">opts = &#123;&#125;, name</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">handleThings</span>(<span class="params">name, opts = &#123;&#125;</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>尽量使用 class. 避免直接操作 prototype .</li></ul><blockquote><p>为什么? class 语法更简洁，更容易推理。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Queue</span>(<span class="params">contents = []</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">queue</span> = [...contents];</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Queue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">pop</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> value = <span class="variable language_">this</span>.<span class="property">queue</span>[<span class="number">0</span>];</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">queue</span>.<span class="title function_">splice</span>(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Queue</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">contents = []</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">queue</span> = [...contents];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">pop</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> value = <span class="variable language_">this</span>.<span class="property">queue</span>[<span class="number">0</span>];</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">queue</span>.<span class="title function_">splice</span>(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>不要使用迭代器。 应该使用 JavaScript 的高阶函数代替 for-in 或者 for-of</li></ul><blockquote><p> 拥有返回值得纯函数比这个更容易解释。<br>使用 map() / every() / filter() / find() / findIndex() / reduce() / some() / … 遍历数组， 和使用 Object.keys() / Object.values() / Object.entries() 迭代你的对象生成数组。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> num <span class="keyword">of</span> numbers) &#123;</span><br><span class="line">  sum += num;</span><br><span class="line">&#125;</span><br><span class="line">sum === <span class="number">15</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">numbers.<span class="title function_">forEach</span>(<span class="function">(<span class="params">num</span>) =&gt;</span> &#123;</span><br><span class="line">  sum += num;</span><br><span class="line">&#125;);</span><br><span class="line">sum === <span class="number">15</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// best (use the functional force)</span></span><br><span class="line"><span class="keyword">const</span> sum = numbers.<span class="title function_">reduce</span>(<span class="function">(<span class="params">total, num</span>) =&gt;</span> total + num, <span class="number">0</span>);</span><br><span class="line">sum === <span class="number">15</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">const</span> increasedByOne = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; numbers.<span class="property">length</span>; i++) &#123;</span><br><span class="line">  increasedByOne.<span class="title function_">push</span>(numbers[i] + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">const</span> increasedByOne = [];</span><br><span class="line">numbers.<span class="title function_">forEach</span>(<span class="function">(<span class="params">num</span>) =&gt;</span> &#123;</span><br><span class="line">  increasedByOne.<span class="title function_">push</span>(num + <span class="number">1</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// best (keeping it functional)</span></span><br><span class="line"><span class="keyword">const</span> increasedByOne = numbers.<span class="title function_">map</span>(<span class="function"><span class="params">num</span> =&gt;</span> num + <span class="number">1</span>);</span><br></pre></td></tr></table></figure><ul><li>把 const 声明的放在一起，把 let 声明的放在一起。</li></ul><blockquote><p>为什么? 这在后边如果需要根据前边的赋值变量指定一个变量时很有用</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">let</span> i, len, dragonball,</span><br><span class="line">    items = <span class="title function_">getItems</span>(),</span><br><span class="line">    goSportsTeam = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">let</span> i;</span><br><span class="line"><span class="keyword">const</span> items = <span class="title function_">getItems</span>();</span><br><span class="line"><span class="keyword">let</span> dragonball;</span><br><span class="line"><span class="keyword">const</span> goSportsTeam = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">let</span> len;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">const</span> goSportsTeam = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">const</span> items = <span class="title function_">getItems</span>();</span><br><span class="line"><span class="keyword">let</span> dragonball;</span><br><span class="line"><span class="keyword">let</span> i;</span><br><span class="line"><span class="keyword">let</span> length;</span><br></pre></td></tr></table></figure><ul><li>使用定义变量的时候把它们放在一个合理的地方。<blockquote><p>let 和 const 是块级作用域而不是函数作用域。</p></blockquote></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad - 不必要的函数调用</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">checkName</span>(<span class="params">hasName</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> name = <span class="title function_">getName</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (hasName === <span class="string">&#x27;test&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (name === <span class="string">&#x27;test&#x27;</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setName</span>(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">checkName</span>(<span class="params">hasName</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (hasName === <span class="string">&#x27;test&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> name = <span class="title function_">getName</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (name === <span class="string">&#x27;test&#x27;</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setName</span>(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Http请求的深入了解</title>
      <link href="/2019/07/10/Http%E8%AF%B7%E6%B1%82%E7%9A%84%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3/"/>
      <url>/2019/07/10/Http%E8%AF%B7%E6%B1%82%E7%9A%84%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>content-disposition: attachment;<br>就可以直接下载了</p>]]></content>
      
      
      
        <tags>
            
            <tag> Http,前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React-Fiber学习笔记</title>
      <link href="/2019/07/01/React-Fiber%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2019/07/01/React-Fiber%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>React Fiber 是 React 核心算法的持续重新实现。这是React团队两年多研究的成果。</p><p>React Fiber 的目标是提高其适合动画、布局和手势等区域的能力。其主功能是增量渲染:能够将渲染工作拆分为块并将其分散到多个帧上。</p><p>其他关键功能包括:</p><ol><li>当新更新进来时，可以暂停、中止或重用工作;</li><li>能够为不同类型的更新分配优先级;</li><li>和新的并发基元。</li></ol><h1 id="关于这篇文档"><a href="#关于这篇文档" class="headerlink" title="关于这篇文档"></a>关于这篇文档</h1><p><code>Fiber</code>引入了几个新颖的概念，单靠查看代码是很难解决的。<br>这也是一项正在进行中的工作。<code>Fiber</code>是一个正在进行的项目，在完成之前可能会进行重大的重构。这篇文档是在这里记录它的设计。</p><h1 id="先决条件"><a href="#先决条件" class="headerlink" title="先决条件"></a>先决条件</h1><p>我强烈建议您在继续之前熟悉以下资源:</p><ul><li><a href="https://reactjs.org/blog/2015/12/18/react-components-elements-and-instances.html">React组件、元素和实例</a> - “组件”通常是一个重载的术语。牢牢把握这些条款至关重要。</li><li><a href="https://zh-hans.reactjs.org/docs/reconciliation.html">协调</a> - React 对帐算法的高级描述。</li><li><a href="https://github.com/reactjs/react-basic">React基本理论概念</a> - 无实现负担的响应概念模型的描述。其中一些在一读时可能没有意义。没关系，随着时间的推移，它更有意义。</li><li><a href="https://zh-hans.reactjs.org/docs/design-principles.html">React设计原则</a> - 特别注意<a href="https://zh-hans.reactjs.org/docs/design-principles.html#scheduling">协调</a>部分。它做了很好的解释React Fiber的原因。</li></ul><h1 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h1><hr><p>如果您尚未查看先决条件部分。</p><p>在深入探讨新事物之前，让我们先回顾一下概念。</p><h2 id="什么是协调（reconciliation）"><a href="#什么是协调（reconciliation）" class="headerlink" title="什么是协调（reconciliation）?"></a>什么是协调（reconciliation）?</h2><h3 id="协调（reconciliation）"><a href="#协调（reconciliation）" class="headerlink" title="协调（reconciliation）"></a>协调（reconciliation）</h3><p>React 算法用于将一个树与另一个树进行差异，以确定需要更改哪些部分。</p><h3 id="更新（update）"><a href="#更新（update）" class="headerlink" title="更新（update）"></a>更新（update）</h3><p>用于渲染 React 应用的数据的更改。通常是”setState”的结果。最终导致重新渲染。<br>React 的 API 的核心思想是将更新视为导致整个应用重新渲染。这允许开发人员以声明性方式推理，而不是担心如何有效地将应用从任何特定状态转换到另一种状态(A 到 B，B 到 C，C 到 A，等等)。</p><p>实际上，在每个更改上重新渲染整个应用仅适用于最琐碎的应用;在真实应用中，性能成本高得令人望而却步。React 具有优化功能，可创建整个应用重新渲染的外观，同时保持出色的性能。这些优化的大部分都是称为协调的过程的一部分。</p><p>协调<code>Scheduling</code>是通常理解为”虚拟 DOM”背后的算法，高级描述如下所示:当您渲染 React 应用程序时，将生成描述该应用程序的节点树并将其保存在内存中。然后，此树将刷新到渲染环境 —— 例如，在浏览器应用程序的情况下，它将转换为一组 DOM 操作。更新应用时(通常通过 setState)将生成一个新树。新树与上一个树有差异，以计算更新渲染的应用所需的操作。</p><p>尽管<code>Fiber</code>是对协调器的一个基础重写，但 React 文档中描述的高级算法将大致相同。要点如下:</p><ul><li>假定不同的组件类型生成完全不同的树。React 不会尝试将它们分散，而是完全替换旧树。</li><li>使用key执行列表差异对比的时候，key应具备”稳定、可预测和唯一”的特性。</li></ul><h2 id="协调与渲染（Reconciliation-versus-rendering）"><a href="#协调与渲染（Reconciliation-versus-rendering）" class="headerlink" title="协调与渲染（Reconciliation versus rendering）"></a>协调与渲染（Reconciliation versus rendering）</h2><p>DOM 只是 React 可以渲染到的渲染环境之一，其他主要目标是通过响应原生进行本机的本机 iOS 和 Android 视图。(这就是为什么有点用错”虚拟 DOM”。）</p><p>它可以支持这么多目标的原因是，React 的设计是使对帐和渲染是单独的阶段。协调者执行计算树的哪些部分已更改的工作;然后，渲染程序使用该信息实际更新渲染的应用。</p><p>这种分离意味着 React DOM 和 React Native 可以在共享由 React 核心提供的同一协调器时使用自己的渲染器。</p><p><code>Fiber</code> 重新实现协调器。它主要与渲染无关，尽管渲染器需要更改以支持(和利用)新的体系结构。</p><h2 id="协调（Scheduling）"><a href="#协调（Scheduling）" class="headerlink" title="协调（Scheduling）"></a>协调（Scheduling）</h2><h3 id="协调"><a href="#协调" class="headerlink" title="协调"></a>协调</h3><p>确定何时应执行工作的过程。</p><h3 id="工作（Work）"><a href="#工作（Work）" class="headerlink" title="工作（Work）"></a>工作（Work）</h3><p>必须执行的任何计算。工作通常是更新的结果(例如 setState)。</p><blockquote><p>在其当前实现中，React 递归遍历整棵Dom树，并在单个变化期间内调用整个更新树的渲染函数。但是，将来它可能会开始延迟某些更新以避免删除帧。<br>这是 React 设计中的一个常见主题。一些流行的库实现了”Push”方法，其中在新数据可用时就执行计算。但是，React 要坚持”Pull”方法，即计算可以推迟到必要的时刻再进行。<br>React 不是通用数据处理库。它是用于构建用户界面的库。我们认为，它在应用中处于独特的位置，可以知道哪些计算现在相关，哪些不相关。<br>如果某些内容位于屏幕外，我们可以延迟与它相关的任何逻辑。如果数据到达速度比帧速率快，我们可以合并和批量更新。我们可以将来自用户交互(如按钮单击引起的动画)的工作优先于不太重要的后台工作(例如渲染刚从网络加载的新内容)，以避免删除帧。</p></blockquote><p>要点如下:</p><ul><li>在 UI 中，不必立即应用每个更新;事实上，这样做可能会浪费，导致帧下降和降低用户体验。</li><li>不同类型的更新具有不同的优先级 - 动画更新需要比来自数据存储的更新更快地完成。</li><li>基于推送的方法要求应用(您，程序员)决定如何安排工作。基于拉取的方法使框架(React)变得智能，并为您做出这些决策。</li></ul><p>React 目前没有以明显地表示要使用该计划;一次更新会导致立即重新渲染整个子树。利用协调是 <code>Fiber</code> 背后的驱动理念就是重构React的核心算法。</p><hr><p>现在，我们已准备好深入了解<code>Fiber</code>的实现。接下来提到的内容比我们到目前为止讨论的内容更具有技术性。</p><h1 id="什么是Fiber？"><a href="#什么是Fiber？" class="headerlink" title="什么是Fiber？"></a>什么是Fiber？</h1><p>接下来即将讨论React Fiber架构的核心，<code>Fiber</code>是一个比应用程序开发人员通常认为的低级抽象的概念，如果你发现自己在试图理解它时感到沮丧，不要感到气馁。不断尝试，你做的努力最终都会有意义。</p><hr><p>我们已经确定 <code>Fiber</code> 的主要目标是使 React 能够利用协调。具体来说，我们需要能够</p><ul><li>暂停工作，然后过一会再回来。</li><li>为不同类型的工作分配优先级。</li><li>重用以前完成的工作。</li><li>如果不再需要操作了，则中止工作。</li></ul><p>为了做到这一点，我们首先需要一种方法，将工作分解为单元。从某种意义上说，这就是<strong>纤维（<code>Fiber</code>）</strong>。一个纤维表示一个工作单元。</p><p>更进一步，让我们回到 React 组件作为数据函数的概念，通常表示为： v = f(d)</p><p>因此，呈现 React 应用类似于调用其正文包含对其他函数的调用的函数，等等。这种类比在思考<code>Fiber</code>时很有用。</p><p>计算机通常跟踪程序执行的方式是使用调用堆栈。执行函数时，将新堆栈帧添加到堆栈中。该堆栈帧表示该函数执行的工作。</p><p>在处理 UI 的时候，可能出现问题是，如果一次执行的工作太多，就会导致动画丢弃帧并看起来不连贯。此外，如果某些操作被较新的更新取代，那么这些较旧的操作可能就没有必要。这就是 UI 组件和函数之间的比较大不相同的地方，因为组件比一般函数更具体。</p><p>较新的浏览器(和React Native)实现 API，来帮助解决这一确切问题:<br>请求 IdleCallback 计划在空闲期间调用低优先级函数，并请求动画Frame 计划在下一个调用高优先级函数动画帧。</p><p>问题是，为了使用这些 API，工程师们需要一种将渲染工作分解为增量单元的方法。如果仅依赖调用堆栈，它将继续工作，直到堆栈为空。</p><p>思考痛点：</p><ul><li>如果我们能够自定义调用堆栈的行为以优化渲染 UI，这难道不是很棒吗?</li><li>如果我们能随时中断调用堆栈并手动操作堆栈帧，这难道不是很棒吗?</li></ul><p>这就是React Fiber的目的，<code>Fiber</code>是堆栈的重新实现，专门用于React组件。您可以将单个<code>Fiber</code>视为<strong>虚拟堆栈框架</strong>。</p><p>重新实现堆栈的优点是可以将堆栈框架保留在内存中，并在需要时执行它们。这对实现我们实现计划目标至关重要。</p><p>除了<strong>协调</strong>之外，手动处理堆栈框架可以释放并发和错误边界等功能的潜力。本文将在之后的部分中介绍这些主题。</p><p>在下一节中，文章将更多地介绍<code>Fiber</code>的结构。</p><h2 id="Fiber的结构"><a href="#Fiber的结构" class="headerlink" title="Fiber的结构"></a>Fiber的结构</h2><p><em>注意:随着React对实现细节的更具体的了解，某些内容可能更改的可能性增加，文章内部的内容不能完全代表最新的React Fiber技术</em></p><p>具体而言，<code>Fiber</code>是一个 JavaScript 对象，其中包含有关组件、其输入及其输出的信息。</p><p><code>Fiber</code>对应于堆栈框架，但它也对应于组件的实例。</p><p>下面是属于<code>Fiber</code>的一些重要字段。(此列表并非详尽列出所有字段奥）</p><h3 id="type-and-key"><a href="#type-and-key" class="headerlink" title="type and key"></a><code>type</code> and <code>key</code></h3><p><code>Fiber</code>的类型和键与”React”元素的用途相同。(事实上，当从元素创建<code>Fiber</code>时，这两个字段将直接复制到该字段上。</p><p><code>Fiber</code>的类型描述它对应的组件。对于复合组件，类型是函数或类组件本身。对于主机组件(div、span 等)，类型是字符串。</p><p>从概念上讲，类型是函数(如 v = f(d))，其执行被堆栈框架跟踪。</p><p>与类型一起，键<code>key</code>在调节期间使用，以确定是否可以重复使用<code>Fiber</code>。</p><h3 id="child-and-sibling"><a href="#child-and-sibling" class="headerlink" title="child and sibling"></a><code>child</code> and <code>sibling</code></h3><p>这些字段指向其他Fiber,描述了Fiber的递归树结构。</p><p><code>子Fiber</code>对应于组件的渲染方法返回的值。因此,在下面的示例中</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Child</span> /&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Parent</code>的子Fiber(子元素)对应于<code>Child</code>。</p><p>同级字段用于呈现返回多个子级的情况(<code>Fiber</code>中的新功能!):</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> [<span class="language-xml"><span class="tag">&lt;<span class="name">Child1</span> /&gt;</span></span>, <span class="language-xml"><span class="tag">&lt;<span class="name">Child2</span> /&gt;</span></span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>子Fiber</code>形成一个单独链接的列表,其头是第一个子元素。因此,在此示例中,<code>Parent</code>的子项为<code>Child1</code>,<code>Child1</code>的同级为<code>Child2</code>。</p><p>回到我们的函数类比,您可以将<code>子Fiber</code>视为 <a href="https://en.wikipedia.org/wiki/Tail_call">tail-called function</a></p><h3 id="return"><a href="#return" class="headerlink" title="return"></a><code>return</code></h3><p><code>return Fiber</code>是程序在处理当前<code>Fiber</code>后应返回的<code>Fiber</code>。它在概念上与堆栈框架的返回地址相同。也可以将其视为<code>parent Fiber</code>。</p><p>如果<code>Fiber</code>有多个<code>child Fibers</code>,则每个<code>child Fiber</code>的<code>return Fiber</code>是<code>parent Fiber</code>。因此,在上一节中的示例中,<code>child 1</code> 和<code>child 2</code>的<code>return Fiber</code>是<code>parent Fiber</code>。</p><h3 id="pendingProps-和memoizedProps"><a href="#pendingProps-和memoizedProps" class="headerlink" title="pendingProps 和memoizedProps"></a><code>pendingProps</code> 和<code>memoizedProps</code></h3><p>从概念上讲,<code>props</code>是函数的参数。<code>Fiber</code>的<code>pendingProps</code>在其执行开始时设置,而<code>memoizedProps</code>在末尾设置。</p><p>当传入的<code>pendingProps</code>等于<code>memoizedProps</code>时,它表明<code>Fiber</code>以前的输出可以重复使用,从而防止不必要的工作。</p><h3 id="pendingProps的优先级"><a href="#pendingProps的优先级" class="headerlink" title="pendingProps的优先级"></a><code>pendingProps</code>的优先级</h3><p>指示由<code>Fiber</code>表示的 <code>props</code> 的优先级的数字。”React优先级（ReactPriorityLevel）”模块列出了不同的优先级及其表示的内容。</p><p>除 NoWork(0)外,数字越大表示优先级较低。例如,可以使用以下函数检查光纤的优先级是否至少与给定级别相同:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">matchesPriority</span>(<span class="params">fiber, priority</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> fiber.<span class="property">pendingWorkPriority</span> !== <span class="number">0</span> &amp;&amp;</span><br><span class="line">         fiber.<span class="property">pendingWorkPriority</span> &lt;= priority</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此函数仅用于说明;它实际上不是 React Fiber 代码库的一部分。</p><p>协调程序（scheduler）使用优先级字段搜索要执行的下一个工作单元。</p><p>此算法将在以后的章节中讨论。</p><h3 id="alternate"><a href="#alternate" class="headerlink" title="alternate"></a>alternate</h3><h4 id="flush"><a href="#flush" class="headerlink" title="flush"></a><em>flush</em></h4><p>刷新（flush）Fiber 是将他的输出渲染在屏幕上。</p><h4 id="work-in-progress"><a href="#work-in-progress" class="headerlink" title="work-in-progress"></a><em>work-in-progress</em></h4><p>尚未完成的Fiber;从概念上讲,是尚未从堆栈框架返回的 <code>Fiber</code>。</p><p>在任何时候,组件实例最多具有两个与其对应的 <code>Fiber</code>: 当前的 Fiber <code>the current Fiber</code>、刷新的Fiber <code>flushed fiber</code> 和 尚未完成的Fiber <code>work-in-progress Fiber</code>。</p><p><code>the current Fiber</code>的备用是<code>work-in-progress Fiber</code>,而<code>work-in-progress Fiber</code>的备用是<code>the current Fiber</code>。</p><p>使用称为克隆Fiber <code>cloneFiber</code> 的功能 懒创建（ lazily using ） <code>Fiber</code>的备用<code>Fiber</code>。<code>cloneFiber</code> 将尝试重用 <code>Fiber</code> 的备用对象<code>work-in-progress Fiber</code>(如果存在)而不是始终创建新对象,从而最大限度地减少分配。</p><p>工程师们应该将 备用字段 <code>alternate</code> 作为实现 <code>Fiber</code>的细节,但它在代码库中经常弹出,因此在此处讨论它非常有价值。</p><h3 id="output"><a href="#output" class="headerlink" title="output"></a>output</h3><h4 id="host-component"><a href="#host-component" class="headerlink" title="host component"></a><em>host component</em></h4><p>React 应用程序的叶节点。它们特定地存在于渲染环境(例如,在浏览器应用中,它们是”div”,”span”等)。在 JSX 中,它们使用 <strong>小写的名称标签</strong> 表示。</p><p>从概念上讲,<code>Fiber</code>的输出是函数的返回值。</p><p>每个<code>Fiber</code>最终都有输出,但输出仅由<strong>host component</strong>在叶节点上创建，这个输出然后再向树上转移。</p><p>最终提供给渲染器的输出的内容将刷新渲染到展示的环境中。渲染器有责任定义这个最终输出的内容是应该 创建 还是 更新。</p><h1 id="未来部分"><a href="#未来部分" class="headerlink" title="未来部分"></a>未来部分</h1><p>这就是现在所有的一切,但本文档还远远不够完整。后续部分将介绍更新整个生命周期中使用的算法。要涵盖的主题包括:</p><ul><li>协调程序（scheduler）如何找到要执行的下一个工作单元。</li><li>如何通过 Fiber 树跟踪和传播优先级。</li><li>计划程序如何知道何时暂停和恢复工作。</li><li>如何刷新工作并标记为已完成。</li><li>副作用(如生命周期方法)的工作原理。</li><li>什么是协同例程,以及如何使用它来实现上下文和布局等功能。</li></ul><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="https://github.com/acdlite/react-fiber-architecture">Fiber</a><br><a href="https://zh-hans.reactjs.org/docs/faq-internals.html#what-is-react-fiber">Virtual DOM 及内核</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GMTC大会记</title>
      <link href="/2019/06/27/GMTC%E5%A4%A7%E4%BC%9A%E8%AE%B0/"/>
      <url>/2019/06/27/GMTC%E5%A4%A7%E4%BC%9A%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="急速秒卡0-3s完成渲染"><a href="#急速秒卡0-3s完成渲染" class="headerlink" title="急速秒卡0.3s完成渲染"></a>急速秒卡0.3s完成渲染</h1><h2 id="闪开优化"><a href="#闪开优化" class="headerlink" title="闪开优化"></a>闪开优化</h2><p>Data PreFetch</p><h2 id="容器选择"><a href="#容器选择" class="headerlink" title="容器选择"></a>容器选择</h2><p>不用native，成本太高<br>Weex<br>H5 优化<br>PWA方向<br>SSR方向</p><h2 id="重新理解页面渲染"><a href="#重新理解页面渲染" class="headerlink" title="重新理解页面渲染"></a>重新理解页面渲染</h2><p>数据模板<br>最快的是从内存中直接取出模板并且渲染；</p><h2 id="NSR预渲染"><a href="#NSR预渲染" class="headerlink" title="NSR预渲染"></a>NSR预渲染</h2><p>Native Server Render</p><h2 id="移动端要求"><a href="#移动端要求" class="headerlink" title="移动端要求"></a>移动端要求</h2><h2 id="微服务化"><a href="#微服务化" class="headerlink" title="微服务化"></a>微服务化</h2><p>造轮子<br>首屏pureJSX + 非首屏Preact</p><h2 id="pureJsx"><a href="#pureJsx" class="headerlink" title="pureJsx"></a>pureJsx</h2><p>是一个没有Virtualdom的，但是最小组件还保留的React实现；<br>只有1KB；</p><hr><h1 id="Bilibili"><a href="#Bilibili" class="headerlink" title="Bilibili"></a>Bilibili</h1><p>网页最佳打开时间 不应超过2秒</p><p>上下游的维度来进行优化</p><h2 id="秒开"><a href="#秒开" class="headerlink" title="秒开"></a>秒开</h2><p>原来stage0：<br>loadHtml css loag-reporter jquery comment bundle bussiness video<br>优化stage0：<br>load HTML Base CSS video log-reporter</p><p>参考：（逐帧分析youtube）</p><p>原来Stage1:<br>palyer.js   init Player</p><p>优化Stage1:<br>vedio.js player.js =&gt; init player</p><p>原来Stage2:<br>Auth playUrl</p><p>优化Stage2:<br>HTML have playUrl ？playUrl(node ssr) : Auth playurl</p><p>ps: 充分利用nodessr</p><p>优化stage3:<br>避免使用第一个预检请求 + MSE（MediaSourceExtensions） 初始化与拉流并行</p><p>优化入口处理：<br>1、通过分析用户点击分析，推荐视频播放地址预取；<br>2、局部SPA；<br>3、入口部分预取播放器资源；<br>4、热门视频头部缓存预取（与页同时输出）</p><p>优化难点：<br>1、长尾优化（可能是CDN的问题）；</p><p>产品优化：<br>新版播放页：播放器上移，资源优先级高</p><p>视频类型：MPEG-DASH<br>这个牛逼⤴️</p><h2 id="弹幕体验"><a href="#弹幕体验" class="headerlink" title="弹幕体验"></a>弹幕体验</h2><p>基于RequestAnimationFrame</p><ul><li>css3（逐帧添加）</li><li>Canvas（逐帧绘制）</li></ul><p>弹幕碰撞检测，因为没有固定轨道，</p><p>优化点：复用弹幕节点，避免DOM频繁创建与移除</p><h3 id="蒙版弹幕"><a href="#蒙版弹幕" class="headerlink" title="蒙版弹幕"></a>蒙版弹幕</h3><p>基于css3 mask-image属性的弹幕，配合人工智能学习的路径点制造出防遮挡的效果</p><p>优化蒙版：</p><ol><li>自动降帧</li><li>大屏幕下没有办法</li></ol><hr><h1 id="基于dom的幻灯片实现"><a href="#基于dom的幻灯片实现" class="headerlink" title="基于dom的幻灯片实现"></a>基于dom的幻灯片实现</h1><ul><li>编辑器实现思路</li><li>编辑器的技术选型</li><li>编辑器的功能难点与解决方法</li></ul><p>实现思路不同于模块化、组件化，是 从点到线，从线到面</p><p>office open xml 基于xml格式的office文档标准（用来定义某些元素到底需要实现什么东西）</p><h2 id="选型考虑范围"><a href="#选型考虑范围" class="headerlink" title="选型考虑范围"></a>选型考虑范围</h2><ol><li>图形</li></ol><ul><li>svg 有性能问题（1000以上会出现卡顿），但是渲染能力强，在移动端显示正常</li><li>canvas 性能好，但是移动端（resize）的时候会出问题</li></ul><p>最后选了svg</p><ol start="2"><li>富文本<br>HTML DOM contenteditable<br>第三方编辑器： Draft.js(react) \ CKEditor \ Quill \ ProseMisrror</li></ol><ul><li>最大化利用浏览器</li><li>数据与UI分离</li><li>保证数据与DOM的一致性</li><li>可扩展</li></ul><h2 id="实时协作算法"><a href="#实时协作算法" class="headerlink" title="实时协作算法"></a>实时协作算法</h2><p>OT算法<br>用insert、remove和retain来表示文档内容及其修改</p><p>insert 插入<br>remove 移除<br>retain 保留</p><p>A用户 operate1 ⬇️ operate2’ -&gt;</p><p>B用户 operate2 ⤴️ operate1’ -&gt;</p><h2 id="图形变换移动"><a href="#图形变换移动" class="headerlink" title="图形变换移动"></a>图形变换移动</h2><ul><li>移动</li><li>缩放</li><li>旋转</li></ul><p>群体变换（多选中几个，做移动，做缩放，做旋转），如果固定坐标系，计算变更后的坐标，很麻烦，<br>因此，选择矩阵变换⬇️<br><strong>仿射变换</strong><br>P2(x’, y’) = T1 * T2 * T3 * P1(x, y)</p><hr><h1 id="数据可视化-React-amp-D3"><a href="#数据可视化-React-amp-D3" class="headerlink" title="数据可视化 React &amp; D3"></a>数据可视化 React &amp; D3</h1><p>数据可视化分析，从数据中提取信息，用交互式图表展示出来，从而做出操作；</p><p>应用场景；<br>事件序列数据，帮助产品经理决策；<br>机器学习模型数据，帮助机器学习工程师分析与检测模型的更迭；</p><h2 id="前端大数据可视化"><a href="#前端大数据可视化" class="headerlink" title="前端大数据可视化"></a>前端大数据可视化</h2><p>出现的情况：高apis请求等</p><ul><li>多样数据总结</li><li>多维度数据过滤</li><li>高频API请求</li><li>高度依赖 <strong>React+ Redux</strong></li><li><strong>Observable</strong> 管理协调数据</li></ul><h2 id="D3与数据可视化数据"><a href="#D3与数据可视化数据" class="headerlink" title="D3与数据可视化数据"></a>D3与数据可视化数据</h2><p>有任务 + data + 概念模型 =&gt; 处理（合理利用人类视觉原理图形化数据） =&gt; 生成D3图表</p><p>人类视觉 不同的图形类型来处理数据<br>视觉变量 selective</p><h3 id="D3核心概念"><a href="#D3核心概念" class="headerlink" title="D3核心概念"></a>D3核心概念</h3><p>数据驱动文档 =&gt; Data-Driven Documents<br>数据到Dom的映射</p><ul><li>数据与DOM元素绑定</li><li>使用函数绘制到svg上</li></ul><p>DOM 操作 - 与 React的异同<br>同： 数据与DOM一一对应<br>异：对于数据的变化直接掌控</p><h3 id="辅助数据加工-数组变形"><a href="#辅助数据加工-数组变形" class="headerlink" title="辅助数据加工 - 数组变形"></a>辅助数据加工 - 数组变形</h3><ul><li>统计数据 =&gt; 数据总结</li><li>数据变形 =&gt; 数据分面</li></ul><h3 id="辅助数据加工-比例尺"><a href="#辅助数据加工-比例尺" class="headerlink" title="辅助数据加工 - 比例尺"></a>辅助数据加工 - 比例尺</h3><p>主要是为了视觉元素支持</p><h3 id="辅助数据加工-布局计算"><a href="#辅助数据加工-布局计算" class="headerlink" title="辅助数据加工 - 布局计算"></a>辅助数据加工 - 布局计算</h3><h3 id="数据图像的映射-颜色操作"><a href="#数据图像的映射-颜色操作" class="headerlink" title="数据图像的映射 - 颜色操作"></a>数据图像的映射 - 颜色操作</h3><h3 id="数据图像的映射-路径生成"><a href="#数据图像的映射-路径生成" class="headerlink" title="数据图像的映射 - 路径生成"></a>数据图像的映射 - 路径生成</h3><p>选用内置插值方式将数据转化为路径<br>Gestalt law of continuity</p><h3 id="数据图像的映射-动画"><a href="#数据图像的映射-动画" class="headerlink" title="数据图像的映射 - 动画"></a>数据图像的映射 - 动画</h3><p>利用插值函数，一行代码实现动画效果</p><h2 id="D3可视化的优势"><a href="#D3可视化的优势" class="headerlink" title="D3可视化的优势"></a>D3可视化的优势</h2><ul><li>数据与图形元素的一一对应<ul><li>用户与图形元素的交互 =&gt; 数据的选取</li></ul></li><li>丰富的数据处理与图形映射功能<ul><li>辅助生成图形</li><li>高度自由化</li></ul></li></ul><h2 id="结合React"><a href="#结合React" class="headerlink" title="结合React"></a>结合React</h2><h3 id="D3的缺陷"><a href="#D3的缺陷" class="headerlink" title="D3的缺陷"></a>D3的缺陷</h3><ul><li>代码冗长<ul><li>Margin得放入函数计算</li></ul></li><li>实现响应式图表需要直接处理window resize</li><li>React与D3在DOM管理上存在潜在冲突</li></ul><h3 id="使用react-d3kit-实现D3代码复用"><a href="#使用react-d3kit-实现D3代码复用" class="headerlink" title="使用react-d3kit 实现D3代码复用"></a>使用react-d3kit 实现D3代码复用</h3><p>twitter团队搞得<br>d3kit：把D3代码封装成ES6</p><p>解决了margin枯燥的计算<br>解决了resize时候的问题</p><p>和react结合</p><ul><li>用react 的状态来控制图表的重新渲染</li><li>利用Redux来统筹不同可视化组件的设置</li><li>D3事件与react时间管理器的衔接</li></ul><hr><h1 id="前端极致优化"><a href="#前端极致优化" class="headerlink" title="前端极致优化"></a>前端极致优化</h1><p>选择性能优化工具<br>需要的能力（软实力-需求梳理、推广落地，硬实力-操作系统知识、数据处理能力、服务器知识、系统设计能力）</p><ul><li>理解优化的收益和所处阶段<br>4个阶段</li><li>性能优化的数据支撑平台<br>现状、目标、成果</li><li>极致技术细节</li></ul><p>ps:性能优化不是全部优化，在某些区间内优化</p><h1 id="内容优化"><a href="#内容优化" class="headerlink" title="内容优化"></a>内容优化</h1><ol><li>文本图片</li></ol><p>文本压缩、图片压缩<br>（gzip、foundation）</p><p>图片 （svg =&gt; 可以gzip压缩）（无损压缩，压缩的是图片信息）（抽离像素通道）（图片转换成样式表）</p>]]></content>
      
      
      
        <tags>
            
            <tag> 前端大会 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React虚拟DOM 深入学习</title>
      <link href="/2019/05/01/React-virtual-dom/"/>
      <url>/2019/05/01/React-virtual-dom/</url>
      
        <content type="html"><![CDATA[<h1 id="为什么我需要（React-virtual-dom）？"><a href="#为什么我需要（React-virtual-dom）？" class="headerlink" title="为什么我需要（React-virtual-dom）？"></a>为什么我需要（React-virtual-dom）？</h1><p>产品的功能源自需求，react 作为一个成功的UI库也是如此。</p><p>假象我们有这种需求：</p><blockquote><p>我需要自己撸一个轮子，能够在数据改变的时候，及时相应在页面上面，怎么做？</p></blockquote><p>一个工作两年左右的工程师就会思考：</p><ol><li>state改变监听</li><li>拥有一个JSX模板</li><li>state改变被监听+模板变化 = 生成一个DOM展示；</li><li>state又变了；</li><li>state改变被监听+模板变化 = 生成一个新的DOM展示；</li></ol><p>问题存在吗？</p><p>问题很大：</p><ul><li>第一次生成了一整个DOM；</li><li>第二次有生成了一整个DOM;</li><li>第二次的DOM完整替换了第一次生成的DOM;</li></ul><p>重绘很耗费性能的好嘛。</p><p>粗略地改进：<br>…4</p><ol start="5"><li>在替换旧的DOM之前进行对比，不一样的再替换之（实际上就是DocumentFragment）;</li><li>展示新的DOM;</li></ol><p>提升如何？<br>其实并不明显</p><p>React方案改进<br>…2</p><ol start="3"><li>state改变被监听+模板变化 =&gt; 生成虚拟DOM，用以描述真实DOM；</li><li>用虚拟DOM生成真实DOM；</li><li>state又变了；</li><li>state改变被监听+模板变化 =&gt; 生成新的虚拟DOM，比较旧的虚拟DOM和新鲜的虚拟DOM，找到区别，直接修改；</li></ol><p>终于：</p><ul><li>性能提升一截；</li><li>甚至使得跨端应用成为现实，RN（React Native）得到广泛使用。为什么呢？因为原生应用里不存在DOM这个概念，<br>但是虚拟DOM这个思想，这个简单的js对象是完全可以正常跑通的，因此，只需要在执行环境中判断出是在Browser还是App中，就可以使React开发多端应用。</li></ul><h1 id="都9102年了，你凭什么还说我们浏览器慢？"><a href="#都9102年了，你凭什么还说我们浏览器慢？" class="headerlink" title="都9102年了，你凭什么还说我们浏览器慢？"></a>都9102年了，你凭什么还说我们浏览器慢？</h1><p>先来看一看浏览器加载HTML文件都需要做什么：<br><img src="http://ww3.sinaimg.cn/large/006tNc79ly1g4evhx81ttj30ho089dgf.jpg" alt="BrowserPaint"></p><p>虽然每个浏览器有自己的引擎，但是大致工作流程都差不多，如图所示分为5步：</p><ol><li>用HTML分析器（解析器），分析HTML元素，构建一棵<strong>DOM 树</strong>；</li><li>用CSS分析器（解析器），分析CSS文件和元素的inline样式，生成<strong>页面样式表</strong>；</li><li>将前面的<strong>DOM树</strong>和<strong>样式表</strong>结合，构建一棵<strong>Render树</strong>。这个过程被称为Attachment，每一个DOM节点都拥有attach方法，接收样式信息，返回一个render对象（renderer)。通过这些render对象(renderer)构成一棵<strong>Render树</strong>；</li><li>浏览器对着<strong>Render树</strong>开始布局，为每一个存在于Render树上的节点确定一个精确的坐标；</li><li>Render树有了，节点显示的位置坐标也有了，最后一步就是调用每个节点的<strong>paint</strong>方法，让他们现出原形！</li></ol><p>那么，当你在撸代码的时候，使用了原生的api，或者是JQuery（老夫不管……）去操作DOM时，浏览器就会按照以上5个步骤重新走一遍，而且更加恐怖的是，假设你在写代码时，“我要一次性更新10个DOM节点”，那在浏览器眼中，它收到第一个更新请求后并不知道后面还有九个，因此立刻执行（1.2.3.4.5.），最终执行了10遍流程。<br>假如说每一次新的更新都会对前一个DOM节点的坐标值发生影响，那么也就是说，只有最后一次计算节点的坐标才是有用的，前面9次白算！<br>所以说，虽然随着时代的变迁，计算机硬件不停地升级，Mac电脑都卖到2W了，但是操作DOM的代价依然非常昂贵，频繁地操作更会出现卡顿等奇奇怪怪の现象，严重影响用户体验。<br>不要反驳说，我一个小小的简单的DOM节点能有多少玩意儿啊？<br>给你看看<br><img src="http://ww2.sinaimg.cn/large/006tNc79ly1g4ew0zde6ej32740jganl.jpg" alt=""></p><p>那怕是一个小小的div，都有如此多的属性，那么整个DOM树有多少，想想都害怕。</p><h1 id="什么是虚拟Dom呢？"><a href="#什么是虚拟Dom呢？" class="headerlink" title="什么是虚拟Dom呢？"></a>什么是虚拟Dom呢？</h1><p>虚拟DOM是一个描述真实DOM的简单js对象</p><p>回到上面那个问题中，加入一次操作中有10个更新DOM的操作，那么我虚拟DOM不会像普通浏览器那样傻傻的立即操作，而是将10次更新内容的diff保存到本地的一个js对象中，最终将这个js对象一次性attach到DOM树上，通知浏览器，你好去paint了，这样就可以极大程度上节约计算成本，避免无谓的计算，好钢要用在刀刃上。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">VirtualDomTree</span> = <span class="title class_">Element</span>(<span class="string">&#x27;div&#x27;</span>, &#123; <span class="attr">id</span>: <span class="string">&#x27;virtual-container&#x27;</span> &#125;, [</span><br><span class="line">    <span class="title class_">Element</span>(<span class="string">&#x27;p&#x27;</span>, &#123;&#125;, [<span class="string">&#x27;Virtual DOM&#x27;</span>]),</span><br><span class="line">    <span class="title class_">Element</span>(<span class="string">&#x27;div&#x27;</span>, &#123;&#125;, [<span class="string">&#x27;before update&#x27;</span>]),</span><br><span class="line">    <span class="title class_">Element</span>(<span class="string">&#x27;ul&#x27;</span>, &#123;&#125;, [</span><br><span class="line">        <span class="title class_">Element</span>(<span class="string">&#x27;li&#x27;</span>, &#123; <span class="attr">class</span>: <span class="string">&#x27;list-item&#x27;</span> &#125;, [<span class="string">&#x27;Item 1&#x27;</span>]),</span><br><span class="line">        <span class="title class_">Element</span>(<span class="string">&#x27;li&#x27;</span>, &#123; <span class="attr">class</span>: <span class="string">&#x27;list-item&#x27;</span> &#125;, [<span class="string">&#x27;Item 2&#x27;</span>]),</span><br><span class="line">        <span class="title class_">Element</span>(<span class="string">&#x27;li&#x27;</span>, &#123; <span class="attr">class</span>: <span class="string">&#x27;list-item&#x27;</span> &#125;, [<span class="string">&#x27;Item 3&#x27;</span>]),</span><br><span class="line">    ])</span><br><span class="line">])</span><br></pre></td></tr></table></figure><p>好处很明显，数据的更新第一步反映在<strong>js对象</strong>上，在内存中对<strong>js对象</strong>的操作速度肯定比浏览器慢悠悠跑来的快得多，等到更新完毕，再交由浏览器去绘制，完美。</p><p>那再具体一点，到底是怎么实现的呢？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> tagName 节点名</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> props 节点的属性</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> children 子节点</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Element</span>(<span class="params">tagName, props, children</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!(<span class="variable language_">this</span> <span class="keyword">instanceof</span> <span class="title class_">Element</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Element</span>(tagName, props, children);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">tagName</span> = tagName;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">props</span> = props || &#123;&#125;;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">children</span> = children || [];</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">key</span> = props ? props.<span class="property">key</span> : <span class="literal">undefined</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">children</span>.<span class="title function_">forEach</span>(<span class="function">(<span class="params">child</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (child <span class="keyword">instanceof</span> <span class="title class_">Element</span>) &#123;</span><br><span class="line">            count += child.<span class="property">count</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">count</span> = count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>除了以上三个参数之外还会保存key和count</p></blockquote><p>OK，到了这一步还没有结束，等到有了js对象之后，还需要将其映射成为真实的DOM：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Element</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">render</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> el = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="variable language_">this</span>.<span class="property">tagName</span>);</span><br><span class="line">    <span class="keyword">const</span> props = <span class="variable language_">this</span>.<span class="property">props</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> propName <span class="keyword">in</span> props) &#123;</span><br><span class="line">        <span class="title function_">setAttr</span>(el, propName, props[propName]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">children</span>.<span class="title function_">forEach</span>(<span class="function">(<span class="params">child</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> childEl = (child <span class="keyword">instanceof</span> <span class="title class_">Element</span>) ?</span><br><span class="line">                        child.<span class="title function_">render</span>() : <span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(child);</span><br><span class="line">        el.<span class="title function_">appendChild</span>(childEl);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> el;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>根据DOM名调用源生的createElement创建真实DOM，将DOM的属性全都加到这个DOM元素上，如果有子元素继续递归调用创建子元素，并appendChild挂到该DOM元素上。这样就完成了从创建虚拟DOM到将其映射成真实DOM的全部工作。</p><h1 id="神秘的Diff算法"><a href="#神秘的Diff算法" class="headerlink" title="神秘的Diff算法"></a>神秘的Diff算法</h1><p>这个玩意儿算是面试总会问到的。</p><p>两棵树如果进行完全的比较，那么时间复杂度是O(n^3 );<br>但是通过《深入浅出React和Redux》这本书的介绍，Diff算法的时间复杂度只有O(n)！</p><p>要实现如此低的时间复杂度，那么就要牺牲一些东西，比如，深度遍历、精确性。<br>但是，在现实的前端开发中，跨层级的DOM元素的操作不是占据大多数情形的，因此，这么选择的Diff算法是最优的。</p><p><img src="http://ww4.sinaimg.cn/large/006tNc79ly1g4eyqxkkccj31g00gmwh0.jpg" alt=""></p><p>diff算法中只会比较同层级的元素，一旦发现某一级之间有所不同，则会弃置其子级，直接用从新的差异的一级以及其下的所有子级替换旧的。我们会有个疑问，这样做那子级中相同的元素不是无法复用了吗，那怎么还能提高比对性能？这无疑是一种缺陷，但也带来了好处就是算法实现简单，也就提高了比对速度，因此最后也是能够提升性能的。</p><p>现在，某张小熠又新创建了一棵树，用于和上文中的树比较：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> newVirtualDomTree = <span class="title class_">Element</span>(<span class="string">&#x27;div&#x27;</span>, &#123; <span class="attr">id</span>: <span class="string">&#x27;virtual-container&#x27;</span> &#125;, [</span><br><span class="line">    <span class="title class_">Element</span>(<span class="string">&#x27;h3&#x27;</span>, &#123;&#125;, [<span class="string">&#x27;Virtual DOM&#x27;</span>]),                     <span class="comment">// REPLACE</span></span><br><span class="line">    <span class="title class_">Element</span>(<span class="string">&#x27;div&#x27;</span>, &#123;&#125;, [<span class="string">&#x27;after update&#x27;</span>]),                   <span class="comment">// TEXT</span></span><br><span class="line">    <span class="title class_">Element</span>(<span class="string">&#x27;ul&#x27;</span>, &#123; <span class="attr">class</span>: <span class="string">&#x27;newList&#x27;</span> &#125;, [              <span class="comment">// PROPS</span></span><br><span class="line">        <span class="title class_">Element</span>(<span class="string">&#x27;li&#x27;</span>, &#123; <span class="attr">class</span>: <span class="string">&#x27;item&#x27;</span> &#125;, [<span class="string">&#x27;Item 1&#x27;</span>]),</span><br><span class="line">        <span class="comment">// Element(&#x27;li&#x27;, &#123; class: &#x27;item&#x27; &#125;, [&#x27;Item 2&#x27;]),    // REORDER remove</span></span><br><span class="line">        <span class="title class_">Element</span>(<span class="string">&#x27;li&#x27;</span>, &#123; <span class="attr">class</span>: <span class="string">&#x27;item&#x27;</span> &#125;, [<span class="string">&#x27;Item 3&#x27;</span>]),</span><br><span class="line">    ]),</span><br><span class="line">]);</span><br></pre></td></tr></table></figure><p><img src="http://ww3.sinaimg.cn/large/006tNc79ly1g4ez87s2x1j30z409i75b.jpg" alt=""><br>花里胡哨的线，但是也大概表达了Diff了些什么：</p><ul><li>第一种（蓝色）是最简单的，如图中的p标签变成了H3标签，这个过程被称之为 <strong><em><em>REPLACE</em></em></strong> 旧节点包括下面的子节点都将被卸载，如果新节点和旧节点仅仅是类型不同，但下面的所有子节点都一样时，这样做显得效率不高。但为了避免O(n^3 )的时间复杂度，这样做是值得的。这也提醒了React开发者，应该避免无谓的节点类型的变化，例如运行时将div变成p就没什么太大意义。</li><li>第二种（紫色）也比较简单，节点类型一样，仅仅属性或属性值变了。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">renderA</span>: &lt;ul&gt;</span><br><span class="line"><span class="attr">renderB</span>: <span class="language-xml"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">class:</span> &#x27;<span class="attr">newList</span>&#x27;&gt;</span></span></span><br><span class="line"><span class="language-xml">=&gt; [addAttribute class &quot;newList&quot;]</span></span><br></pre></td></tr></table></figure><p>这个过程被称为 <strong><em><em>PROPS</em></em></strong><br>这个时候不会触发节点的卸载（componentWillUnmounted）和装载（componentWillMount）生命周期，而是执行了 <strong>节点更新</strong> （shouldComponentUpdated =&gt; componentDidUpdated 系列方法）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">diffProps</span>(<span class="params">oldNode, newNode</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> oldProps = oldNode.<span class="property">props</span>;</span><br><span class="line">    <span class="keyword">const</span> newProps = newNode.<span class="property">props</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> key;</span><br><span class="line">    <span class="keyword">const</span> propsPatches = &#123;&#125;;</span><br><span class="line">    <span class="keyword">let</span> isSame = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// find out different props</span></span><br><span class="line">    <span class="keyword">for</span> (key <span class="keyword">in</span> oldProps) &#123;</span><br><span class="line">        <span class="keyword">if</span> (newProps[key] !== oldProps[key]) &#123;</span><br><span class="line">            isSame = <span class="literal">false</span>;</span><br><span class="line">            propsPatches[key] = newProps[key];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// find out new props</span></span><br><span class="line">    <span class="keyword">for</span> (key <span class="keyword">in</span> newProps) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!oldProps.<span class="title function_">hasOwnProperty</span>(key)) &#123;</span><br><span class="line">            isSame = <span class="literal">false</span>;</span><br><span class="line">            propsPatches[key] = newProps[key];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> isSame ? <span class="literal">null</span> : propsPatches;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>第三种（绿色）就只是文本变化了，文本其实也是一个Text Node，这个简单，直接修改文字内容即可，被称之为 <strong><em><em>TEXT</em></em></strong></li><li>第四种是 移动、增加、删除子节点，这个过程被称之为 <strong><em><em>REORDER</em></em></strong></li></ul><p>具体可以看 <a href="https://www.infoq.cn/article/react-dom-diff/">虚拟DOM 算法解析</a></p><h2 id="列表渲染的元素，你如果不加key，我就嗷嗷叫……"><a href="#列表渲染的元素，你如果不加key，我就嗷嗷叫……" class="headerlink" title="列表渲染的元素，你如果不加key，我就嗷嗷叫……"></a>列表渲染的元素，你如果不加key，我就嗷嗷叫……</h2><p><img src="http://ww3.sinaimg.cn/large/006tNc79ly1g4ezut9k77j310a02uwfs.jpg" alt=""><br>这个warning，vue和react都会报。他们强烈建议开发者，拜托你在写通过数组循环渲染item的时候，一定要加上key，不然我们在虚拟DOM比较的时候就只能进行两层循环，才知道什么发生改变了，你们开发者如果加上了key，那我们就可以非常快速且清晰地比较出新增和删除了什么东西！</p><p>比如⤵️</p><p>A B 【F】 C D E</p><p>我想要插入一个F元素，那么简单粗暴的方法就出现了：<br>卸载C，装载F，卸载D，装载C，卸载E，装载D，装载E<br><img src="http://ww1.sinaimg.cn/large/006tNc79ly1g4f02dkxxcj30su09w757.jpg" alt=""></p><p>如果我们在JSX里为数组或枚举型元素增加上key后，React就能根据key，直接找到具体的位置进行操作，效率比较高。</p><blockquote><p> Keys should be “stable, predictable, and unique.” 所以不建议在使用key的时候，简单地使用上数组的index属性，那个玩意儿会带来巨大的坑。</p></blockquote><p><img src="http://ww1.sinaimg.cn/large/006tNc79ly1g4f08h182lj30s609ejsa.jpg" alt=""></p><blockquote><p>因此就变成了最小编辑距离问题，可以用Levenshtein Distance算法来实现，时间复杂度是O(M*N)，但通常我们只要一些简单的移动就能满足需要，降低点精确性，将时间复杂度降低到O(max(M, N)即可。</p></blockquote><p>最终Diff出来的结果</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="number">1</span>: [ &#123;<span class="attr">type</span>: <span class="variable constant_">REPLACE</span>, <span class="attr">node</span>: <span class="title class_">Element</span>&#125; ],</span><br><span class="line">    <span class="number">4</span>: [ &#123;<span class="attr">type</span>: <span class="variable constant_">TEXT</span>, <span class="attr">content</span>: <span class="string">&quot;after update&quot;</span>&#125; ],</span><br><span class="line">    <span class="number">5</span>: [ &#123;<span class="attr">type</span>: <span class="variable constant_">PROPS</span>, <span class="attr">props</span>: &#123;<span class="attr">class</span>: <span class="string">&quot;newList&quot;</span>&#125;&#125;, &#123;<span class="attr">type</span>: <span class="variable constant_">REORDER</span>, <span class="attr">moves</span>: [&#123;<span class="attr">index</span>: <span class="number">2</span>, <span class="attr">type</span>: <span class="number">0</span>&#125;]&#125; ],</span><br><span class="line">    <span class="number">6</span>: [ &#123;<span class="attr">type</span>: <span class="variable constant_">REORDER</span>, <span class="attr">moves</span>: [&#123;<span class="attr">index</span>: <span class="number">2</span>, <span class="attr">type</span>: <span class="number">0</span>&#125;]&#125; ],</span><br><span class="line">    <span class="number">8</span>: [ &#123;<span class="attr">type</span>: <span class="variable constant_">REORDER</span>, <span class="attr">moves</span>: [&#123;<span class="attr">index</span>: <span class="number">2</span>, <span class="attr">type</span>: <span class="number">0</span>&#125;]&#125; ],</span><br><span class="line">    <span class="number">9</span>: [ &#123;<span class="attr">type</span>: <span class="variable constant_">TEXT</span>, <span class="attr">content</span>: <span class="string">&quot;Item 3&quot;</span>&#125; ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最终映射到真实DOM中"><a href="#最终映射到真实DOM中" class="headerlink" title="最终映射到真实DOM中"></a>最终映射到真实DOM中</h2><p>深度遍历DOM将Diff的内容更新进去：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">dfsWalk</span>(<span class="params">node, walker, patches</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> currentPatches = patches[walker.<span class="property">index</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> len = node.<span class="property">childNodes</span> ? node.<span class="property">childNodes</span>.<span class="property">length</span> : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        walker.<span class="property">index</span>++;</span><br><span class="line">        <span class="title function_">dfsWalk</span>(node.<span class="property">childNodes</span>[i], walker, patches);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (currentPatches) &#123;</span><br><span class="line">        <span class="title function_">applyPatches</span>(node, currentPatches);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体的更新代码如下<br>其实就是根据Diff信息调用源生API操作DOM：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">applyPatches</span>(<span class="params">node, currentPatches</span>) &#123;</span><br><span class="line">    currentPatches.<span class="title function_">forEach</span>(<span class="function">(<span class="params">currentPatch</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> (currentPatch.<span class="property">type</span>) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="attr">REPLACE</span>: &#123;</span><br><span class="line">                <span class="keyword">const</span> newNode = (<span class="keyword">typeof</span> currentPatch.<span class="property">node</span> === <span class="string">&#x27;string&#x27;</span>)</span><br><span class="line">                    ? <span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(currentPatch.<span class="property">node</span>)</span><br><span class="line">                    : currentPatch.<span class="property">node</span>.<span class="title function_">render</span>();</span><br><span class="line">                node.<span class="property">parentNode</span>.<span class="title function_">replaceChild</span>(newNode, node);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="attr">REORDER</span>:</span><br><span class="line">                <span class="title function_">reorderChildren</span>(node, currentPatch.<span class="property">moves</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="attr">PROPS</span>:</span><br><span class="line">                <span class="title function_">setProps</span>(node, currentPatch.<span class="property">props</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="attr">TEXT</span>:</span><br><span class="line">                <span class="keyword">if</span> (node.<span class="property">textContent</span>) &#123;</span><br><span class="line">                    node.<span class="property">textContent</span> = currentPatch.<span class="property">content</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// ie</span></span><br><span class="line">                    node.<span class="property">nodeValue</span> = currentPatch.<span class="property">content</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="attr">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">`Unknown patch type <span class="subst">$&#123;currentPatch.type&#125;</span>`</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个时候呼应开头了，虚拟DOM的目的是将所有操作累加起来，统计计算出所有的变化后，统一更新一次DOM，以上大概就是全部解析内容了。</p><h1 id="React-Fiber"><a href="#React-Fiber" class="headerlink" title="React Fiber"></a>React Fiber</h1><p>请看下一篇我的博客《React-Fiber学习笔记》</p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="https://reactjs.org/docs/faq-internals.html#what-is-the-virtual-dom">What is the Virtual DOM?「React官网」</a><br><a href="https://www.infoq.cn/article/react-dom-diff/">深入浅出React： 虚拟DOM Diff 算法解析</a><br>链接挂掉了几个<br>深度剖析：如何实现一个 Virtual DOM 算法</p>]]></content>
      
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微信小程序开发指南</title>
      <link href="/2019/04/08/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/"/>
      <url>/2019/04/08/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><h2 id="小程序是什么"><a href="#小程序是什么" class="headerlink" title="小程序是什么"></a>小程序是什么</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;小程序是一种全新的连接用户与服务的方式，它可以在微信内被便捷地获取和传播，同时具有出色的使用体验。</p><h2 id="发展史"><a href="#发展史" class="headerlink" title="发展史"></a>发展史</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;小程序并非凭空冒出来的一个概念。当微信中的 WebView 逐渐成为移动 Web 的一个重要入口时，微信就有相关的 JS API 了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">WeixinJSBridge</span>.<span class="title function_">invoke</span>(<span class="string">&#x27;imagePreview&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">current</span>: <span class="string">&#x27;http://inews.gtimg.com/newsapp_bt/0/1693121381/641&#x27;</span>,</span><br><span class="line">    <span class="attr">urls</span>: [ <span class="comment">// 所有图片的URL列表，数组格式</span></span><br><span class="line">        <span class="string">&#x27;https://img1.gtimg.com/10/1048/104857/10485731_980x1200_0.jpg&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;https://img1.gtimg.com/10/1048/104857/10485726_980x1200_0.jpg&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;https://img1.gtimg.com/10/1048/104857/10485729_980x1200_0.jpg&#x27;</span></span><br><span class="line">    ]</span><br><span class="line">&#125;, <span class="keyword">function</span> (<span class="params">res</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res.<span class="property">err_msg</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以上是一个调用微信原生组件浏览图片的JS API，相比于额外引入一个JS图片预览组件库，这种调用方式显得非常简洁和高效。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;实际上，微信官方是没有对外暴露过如此调用的，此类 API 最初是提供给腾讯内部一些业务使用，很多外部开发者发现了之后，依葫芦画瓢地使用了，逐渐成为微信中网页的事实标准。2015年初，微信发布了一整套网页开发工具包，称之为 JS-SDK，开放了拍摄、录音、语音识别、二维码、地图、支付、分享、卡券等几十个API。给所有的 Web 开发者打开了一扇全新的窗户，让所有开发者都可以使用到微信的原生能力，去完成一些之前做不到或者难以做到的事情。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用 JS-SDK 调用图片预览组件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">wx.<span class="title function_">previewImage</span>(&#123;</span><br><span class="line"><span class="attr">current</span>: <span class="string">&#x27;https://img1.gtimg.com/10/1048/104857/10485726_980x1200_0.jpg&#x27;</span>,</span><br><span class="line"><span class="attr">urls</span>: [ <span class="comment">// 所有图片的URL列表，数组格式</span></span><br><span class="line">    <span class="string">&#x27;https://img1.gtimg.com/10/1048/104857/10485731_980x1200_0.jpg&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;https://img1.gtimg.com/10/1048/104857/10485726_980x1200_0.jpg&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;https://img1.gtimg.com/10/1048/104857/10485729_980x1200_0.jpg&#x27;</span></span><br><span class="line">],</span><br><span class="line"><span class="title function_">success</span>(<span class="params">res</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>JS-SDK 解决了移动网页能力不足的问题，通过暴露微信的接口使得 Web 开发者能够拥有更多的能力，然而在更多的能力之外，JS-SDK 的模式并没有解决使用移动网页遇到的体验不良的问题。用户在访问网页的时候，在浏览器开始显示之前都会有一个的白屏过程，在移动端，受限于设备性能和网络速度，白屏会更加明显。微信官方把很多技术精力放置在如何帮助平台上的Web开发者解决这个问题。因此微信官方设计了一个 JS-SDK 的增强版本，其中有一个重要的功能，称之为“微信 Web 资源离线存储”。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">微信 Web 资源离线存储是面向 Web 开发者提供的基于微信内的 Web 加速方案。</span><br><span class="line">通过使用微信离线存储，Web 开发者可借助微信提供的资源存储能力，直接从微信本地加载 Web 资源而不需要再从服务端拉取，从而减少网页加载时间，为微信用户提供更优质的网页浏览体验。每个公众号下所有 Web App 累计最多可缓存 5M 的资源。</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然而，页面切换的生硬和点击的迟滞感还是会给开发者带来不好的体验，微信官方希望能够给出：</p><ul><li>快速的加载</li><li>更强大的能力</li><li>原生的体验</li><li>易用且安全的微信数据开放</li><li>高效和简单的开发<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此，微信小程序就诞生了。</li></ul><h2 id="小程序与普通网页开发的区别"><a href="#小程序与普通网页开发的区别" class="headerlink" title="小程序与普通网页开发的区别"></a>小程序与普通网页开发的区别</h2><p>相似点：主要开发语言是 JavaScript；</p><p>不同点：</p><p>小程序的网页开发渲染线程和脚本线程是双线程分离的，逻辑层运行在 JSCore 中，并没有一个完整浏览器对象，因而缺少相关的DOM API和BOM API。这一区别导致了前端开发非常熟悉的一些库，例如 jQuery、 Zepto 等，在小程序中是无法运行的。同时 JSCore 的环境同 NodeJS 环境也是不尽相同，所以一些 NPM 的包在小程序中也是无法运行的。<br>双线程</p><p>网页开发面临各式各样的浏览器，PC 端需要面对 IE、Chrome、QQ浏览器等，在移动端需要面对Safari、Chrome以及 iOS、Android 系统中的各式 WebView ，小程序面临的是两大操作系统 iOS 和 Android 的微信客户端，以及用于辅助开发的小程序开发者工具。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在开发的过程中会经常发现，为什么我在（开发工具上）是好的，在我的（安卓手机）上也是好的，到你的（苹果手机）上就不好使了呢？<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为，三个开发环境也是有很大差异的。</p><table><thead><tr><th>运行环境</th><th>逻辑层</th><th>渲染层</th></tr></thead><tbody><tr><td>iOS</td><td>JavaScriptCore</td><td>WKWebView</td></tr><tr><td>安卓</td><td>V8</td><td>chromium定制内核</td></tr><tr><td>小程序开发者工具</td><td>NWJS</td><td>Chrome WebView</td></tr></tbody></table><p>开发流程，网页开发者在开发网页的时候，只需要使用到浏览器，并且搭配上一些辅助工具或者编辑器即可。小程序的开发则有所不同，需要经过申请小程序帐号、安装小程序开发者工具、配置项目等等过程方可完成。</p><h1 id="小程序技术选型"><a href="#小程序技术选型" class="headerlink" title="小程序技术选型"></a>小程序技术选型</h1><h2 id="渲染技术"><a href="#渲染技术" class="headerlink" title="渲染技术"></a>渲染技术</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在通用的渲染技术有：web渲染、Native渲染、web与Native混合渲染也就是Hybrid渲染。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;小程序选择了 Hybrid 的渲染方式，可以用一种近似 Web 的方式来开发，并且还可以实现在线更新代码。同时，引入原生组件有以下好处：</p><p>扩展 Web 的能力。比如像输入框组件（input, textarea）有更好地控制键盘的能力<br>体验更好，同时也减轻 WebView 的渲染工作<br>绕过 setData、数据通信和重渲染流程，使渲染性能更好</p><h2 id="基础库"><a href="#基础库" class="headerlink" title="基础库"></a>基础库</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;小程序的基础库是 JavaScript 编写的，它可以被注入到渲染层和逻辑层运行。主要用于：</p><p>在渲染层，提供各类组件来组建界面的元素<br>在逻辑层，提供各类 API 来处理各种逻辑<br>处理数据绑定、组件系统、事件系统、通信系统等一系列框架逻辑<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于小程序的渲染层和逻辑层是两个线程管理，两个线程各自注入了基础库。小程序的基础库不会被打包在某个小程序的代码包里边，它会被提前内置在微信客户端。这样可以：</p><p>降低业务小程序的代码包大小<br>可以单独修复基础库中的 Bug，无需修改到业务小程序的代码包</p><h2 id="Exparser-框架"><a href="#Exparser-框架" class="headerlink" title="Exparser 框架"></a>Exparser 框架</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exparser 是微信小程序的组件组织框架，内置在小程序基础库中，为小程序的各种组件提供基础的支持。小程序内的所有组件，包括内置组件和自定义组件，都由 Exparser 组织管理。Exparser 特点包括：</p><p>基于 Shadow DOM 模型：模型上与 WebComponents 的 ShadowDOM 高度相似，但不依赖浏览器的原生支持，也没有其他依赖库；实现时，还针对性地增加了其他 API 以支持小程序组件编程。<br>可在纯 JS 环境中运行：这意味着逻辑层也具有一定的组件树组织能力。<br>高效轻量：性能表现好，在组件实例极多的环境下表现尤其优异，同时代码尺寸也较小。</p><h1 id="小程序基础"><a href="#小程序基础" class="headerlink" title="小程序基础"></a>小程序基础</h1><p>目录结构</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上图为微信小程序的项目结构，pages下面包含了小程序中的每一个页面，每一个页面由页面结构，页面样式，页面配置和逻辑代码四部分组成。</p><ul><li>页面结构<br>页面结构文件为index.wxml，通过微信自定义的标签来写。</li><li>页面逻辑<br>页面逻辑通过JavaScript来书写。</li><li>页面样式表<br>类似CSS文件，来定义页面内元素的样式。</li><li>页面配置<br>页面内的权限等配置信息。</li></ul><h2 id="程序与页面"><a href="#程序与页面" class="headerlink" title="程序与页面"></a>程序与页面</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当小程序准备加载的时候，微信会把整个小程序的代码包下载到本地。<br>紧接着通过 app.json 的 pages 字段就可以知道你当前小程序的所有页面路径:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;pages&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;pages/index/index&quot;</span>,</span><br><span class="line">        <span class="string">&quot;pages/logs/logs&quot;</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个配置说明在 当前项目定义了两个页面，分别位于 pages/index/index 和 pages/logs/logs。而写在 pages 字段的第一个页面就是这个小程序的首页（打开小程序看到的第一个页面）。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;再接着，微信客户端就把首页的代码装载进来，通过小程序底层的一些机制，就可以渲染出这个首页。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;小程序启动之后，在 app.js 定义的 App 实例的 onLaunch 回调会被执行:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">App</span>(&#123;</span><br><span class="line">    <span class="title function_">onLaunch</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">// 小程序启动之后 触发</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">onShow</span>(<span class="params">options</span>) &#123;</span><br><span class="line">        <span class="comment">// 页面出现的时候触发</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">onHide</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 页面隐藏的时候触发.</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">onError</span>(<span class="params">msg</span>) &#123;</span><br><span class="line">    <span class="comment">// 页面出错的时候触发</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">globalData</span>: <span class="string">&#x27;这是全局的数据&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;整个小程序只有一个 App 实例，是全部页面共享的。开发者可以通过 getApp 方法获取到全局唯一的 App 示例，获取App上的数据或调用开发者注册在 App 上的函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// logs.js</span></span><br><span class="line"><span class="keyword">const</span> appInstance = <span class="title function_">getApp</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(appInstance.<span class="property">globalData</span>) <span class="comment">// 这是全局的数据</span></span><br></pre></td></tr></table></figure><h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><p>基础组件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">map</span>&gt;</span><span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br></pre></td></tr></table></figure><p>原生组件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">video</span>&gt;</span><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br></pre></td></tr></table></figure><p>自定义组件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">my-component</span>&gt;</span><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;微信官方提供了大量的 小程序的API 供开发者使用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 微信扫一扫</span></span><br><span class="line">wx.<span class="title function_">scanCode</span>(&#123;</span><br><span class="line"><span class="attr">success</span>: <span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h1 id="小程序发布"><a href="#小程序发布" class="headerlink" title="小程序发布"></a>小程序发布</h1><h2 id="小程序发布多态"><a href="#小程序发布多态" class="headerlink" title="小程序发布多态"></a>小程序发布多态</h2><table><thead><tr><th>权限</th><th>说明</th></tr></thead><tbody><tr><td>开发版本</td><td>使用开发者工具，可将代码上传到开发版本中。 开发版本只保留每人最新的一份上传的代码。 点击提交审核，可将代码提交审核。开发版本可删除，不影响线上版本和审核中版本的代码。</td></tr><tr><td>体验版本</td><td>可以选择某个开发版本作为体验版，并且选取一份体验版。</td></tr><tr><td>审核中版本</td><td>只能有一份代码处于审核中。有审核结果后可以发布到线上，也可直接重新提交审核，覆盖原审核版本。</td></tr><tr><td>线上版本</td><td>线上所有用户使用的代码版本，该版本代码在新版本代码发布后被覆盖更新。</td></tr></tbody></table><h2 id="小程序发布过程"><a href="#小程序发布过程" class="headerlink" title="小程序发布过程"></a>小程序发布过程</h2><p>简而言之：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a.预览 --&gt; b.上传代码 --&gt; c.提交审核 --&gt; d.发布</span><br><span class="line"># （开发者工具a.b.）</span><br><span class="line">#（后台c.d.）</span><br></pre></td></tr></table></figure><p><a href="发布文档">https://developers.weixin.qq.com/miniprogram/dev/framework/quickstart/release.html#%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%89%88%E6%9C%AC</a></p><h1 id="小程序WXML的一些姿势"><a href="#小程序WXML的一些姿势" class="headerlink" title="小程序WXML的一些姿势"></a>小程序WXML的一些姿势</h1><h2 id="姿势们"><a href="#姿势们" class="headerlink" title="姿势们"></a>姿势们</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 简单用法 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">view</span>&gt;</span>hello world!<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 变量绑定 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">view</span>&gt;</span>&#123;&#123; variable &#125;&#125;<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 动态渲染 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">view</span>&gt;</span>&#123;&#123; areUOk ? &#x27;fine&#x27; : &#x27;bad&#x27; &#125;&#125;<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 条件渲染 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">wx:if</span>=<span class="string">&quot;&#123;&#123; people &gt; 6 &#125;&#125;&quot;</span>&gt;</span>拍皮球<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">wx:elif</span>=<span class="string">&quot;&#123;&#123; 2 &lt; people &lt; 6 &#125;&#125;&quot;</span>&gt;</span>撸串<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">wx:else</span>&gt;</span>加班<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 列表渲染 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">wx:for</span>=<span class="string">&quot;&#123;&#123; list &#125;&#125;&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 模板 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">name</span>=<span class="string">&quot;muban&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>引入<br>import<br>include 两种方法<br>！！！此处有大坑，import方法不具备递归功能， A import B ，B 中 import C，但是A就无法使用C辽！！！</p></blockquote><h2 id="属性们"><a href="#属性们" class="headerlink" title="属性们"></a>属性们</h2><table><thead><tr><th>属性名</th><th>类型</th><th>描述</th><th>注解</th></tr></thead><tbody><tr><td>id</td><td>String</td><td>组件的唯一标识</td><td>整个页面唯一</td></tr><tr><td>class</td><td>String</td><td>组件的样式类</td><td>在对应的 WXSS 中定义的样式类</td></tr><tr><td>style</td><td>String</td><td>组件的内联样式</td><td>可以动态设置的内联样式</td></tr><tr><td>hidden</td><td>Boolean</td><td>组件是否显示</td><td>所有组件默认显示</td></tr><tr><td>data-*</td><td>Any</td><td>自定义属性</td><td>组件上触发的事件时，会发送给事件处理函数</td></tr><tr><td>bind/catch</td><td>EventHandler</td><td>组件的事件</td><td>bind冒泡，catch不冒泡</td></tr></tbody></table><h1 id="小程序wxss的一些姿势"><a href="#小程序wxss的一些姿势" class="headerlink" title="小程序wxss的一些姿势"></a>小程序wxss的一些姿势</h1><h2 id="特殊的单位-rpx-（responsive-pixel）"><a href="#特殊的单位-rpx-（responsive-pixel）" class="headerlink" title="特殊的单位 rpx （responsive pixel）"></a>特殊的单位 rpx （responsive pixel）</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;目的是更多型号的手机屏幕可以展示差不多的样式，如果用了px，就可能在大屏幕下过多留白，小屏幕下过于拥挤。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;小程序编译后，rpx会做一次px换算。换算是以375个物理像素为基准，也就是在一个宽度为375物理像素的屏幕下，1rpx = 1px。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;举个栗子：iphone6是375px宽度，也就是750物理像素，这个时候对应的rpx就是<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1rpx = 375 / 750 = 0.5px</p><h2 id="微信rpx"><a href="#微信rpx" class="headerlink" title="微信rpx"></a>微信rpx</h2><h2 id="使用wxss"><a href="#使用wxss" class="headerlink" title="使用wxss"></a>使用wxss</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;常规：按照上面目录结构当中的方式，是无需重复引用style文件的，直接定义直接用；<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;骚操作：在wxss文件中使用@import</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.wxss</span></span><br><span class="line">@<span class="keyword">import</span> <span class="title function_">url</span>(<span class="string">&#x27;./logs.wxss&#x27;</span>)</span><br></pre></td></tr></table></figure><p>内联样式：不用多说的</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">textarea</span> <span class="attr">style</span>=<span class="string">&quot;&#123;&#123; font-size: 24rpx; &#125;&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="小程序Js的一些姿势"><a href="#小程序Js的一些姿势" class="headerlink" title="小程序Js的一些姿势"></a>小程序Js的一些姿势</h1><h2 id="闲话"><a href="#闲话" class="headerlink" title="闲话"></a>闲话</h2><p>可能在很多开发者的眼中，JavaScript 和 ECMAScript 是等价的，然而，其实这两者还是有很大不同的：<br>JavaScript是ECMAScript的实现形式。</p><h3 id="在浏览器中"><a href="#在浏览器中" class="headerlink" title="在浏览器中"></a>在浏览器中</h3><table><thead><tr><th>浏览器中的JavaScript</th><th>&nbsp;</th><th>&nbsp;</th></tr></thead><tbody><tr><td>ECMAScript</td><td>BOM</td><td>DOM</td></tr></tbody></table><h3 id="在node环境中"><a href="#在node环境中" class="headerlink" title="在node环境中"></a>在node环境中</h3><table><thead><tr><th>node中的JavaScript</th><th>&nbsp;</th><th>&nbsp;</th></tr></thead><tbody><tr><td>ECMAScript</td><td>NPM</td><td>NATIVE</td></tr></tbody></table><h3 id="在小程序中"><a href="#在小程序中" class="headerlink" title="在小程序中"></a>在小程序中</h3><table><thead><tr><th>小程序中的JavaScript</th><th>&nbsp;</th><th>&nbsp;</th></tr></thead><tbody><tr><td>ECMAScript</td><td>小程序的View</td><td>小程序的API</td></tr></tbody></table><h2 id="小提示"><a href="#小提示" class="headerlink" title="小提示"></a>小提示</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于小程序能够运行的环境较多，有IOS、安卓、小程序开发工具，在同一个平台上也会有不同的系统版本，这会导致部分ES6的代码不能够在机型上完美兼容，这个时候，只要在IDE中开启，ES6转ES5即可！</p>]]></content>
      
      
      
        <tags>
            
            <tag> 微信小程序 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
