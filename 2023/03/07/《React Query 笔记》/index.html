<!DOCTYPE html><html><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="《React Query 笔记》"><meta name="keywords" content="react-query"><meta name="author" content="张熠"><meta name="copyright" content="张熠"><title>《React Query 笔记》 | Codan's Blog</title><link rel="shortcut icon" href="/img/zhangyi.png"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"╥﹏╥木有找到: ${query}"}},
  copy: {
    success: '复制成功！',
    error: '复制失败了',
    noSupport: '当前浏览器并不支持~'
  }
} </script><meta name="generator" content="Hexo 6.3.0"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="文章信息">网站信息</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已阅读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E3%80%8AReact-Query-%E7%AC%94%E8%AE%B0%E3%80%8B"><span class="toc-number">1.</span> <span class="toc-text">《React Query 笔记》</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A6%81%E5%BC%80%E5%A7%8B%E5%81%9A%E8%AF%B7%E6%B1%82%E6%96%B9%E6%A1%88%E7%9A%84%E8%B0%83%E7%A0%94%EF%BC%8C%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%B7%B1%E5%85%A5%E7%9C%8B%E7%9A%84%E6%98%AF-React-Query%EF%BC%88%E4%B8%8B%E9%9D%A2%E7%AE%80%E7%A7%B0%E4%B8%BA-RQ%EF%BC%89%E3%80%82%E6%9C%AC%E6%96%87%E6%98%AF-Practical-React-Query-TkDodo%E2%80%99s-blog-%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0%E7%9A%84%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%E3%80%82"><span class="toc-number">1.0.1.</span> <span class="toc-text">要开始做请求方案的调研，第一个深入看的是 React Query（下面简称为 RQ）。本文是 Practical React Query | TkDodo’s blog 系列文章的阅读笔记。</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E4%B8%BA%E5%95%A5%E5%BE%88%E5%A4%9A%E4%BA%BA%E4%BC%9A%E8%AE%A4%E4%B8%BA-apollo-%E4%BC%9A%E5%8F%96%E4%BB%A3-redux%EF%BC%9F"><span class="toc-number">1.1.</span> <span class="toc-text">1. 为啥很多人会认为 apollo 会取代 redux？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E4%B8%80%E4%BA%9B%E6%96%87%E6%A1%A3%E5%A4%96%E7%9A%84%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7"><span class="toc-number">1.2.</span> <span class="toc-text">2. 一些文档外的使用技巧</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%A6%82%E6%9E%9C%E5%90%8E%E7%AB%AF%E6%B2%A1%E6%9C%89%E8%BF%94%E5%9B%9E%E6%9C%9F%E6%9C%9B%E7%9A%84%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F%EF%BC%8C%E9%82%A3%E5%B0%B1%E9%9C%80%E8%A6%81%E5%81%9A%E6%A0%BC%E5%BC%8F%E5%8C%96%E4%BA%86%E3%80%82%E8%BF%99%E6%97%B6%E6%9C%89%E5%A4%9A%E4%B8%AA%E9%80%89%E6%8B%A9%EF%BC%8C"><span class="toc-number">1.3.</span> <span class="toc-text">3. 如果后端没有返回期望的数据格式，那就需要做格式化了。这时有多个选择，</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-RQ-%E5%86%85%E7%BD%AE%E4%BA%86%E4%B8%80%E4%BA%9B%E6%B8%B2%E6%9F%93%E4%BC%98%E5%8C%96%E7%9A%84%E8%83%BD%E5%8A%9B%E3%80%82"><span class="toc-number">1.4.</span> <span class="toc-text">4. RQ 内置了一些渲染优化的能力。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-RQ-%E6%9C%89-3-%E7%A7%8D%E7%8A%B6%E6%80%81"><span class="toc-number">1.5.</span> <span class="toc-text">5. RQ 有 3 种状态:</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E5%A6%82%E4%BD%95%E5%81%9A%E6%B5%8B%E8%AF%95%EF%BC%9F"><span class="toc-number">1.6.</span> <span class="toc-text">6. 如何做测试？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E5%85%B3%E4%BA%8E%E7%B1%BB%E5%9E%8B%E3%80%82"><span class="toc-number">1.7.</span> <span class="toc-text">7. 关于类型。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-RQ-WebSocket-%E6%9C%89%E4%B8%A4%E7%A7%8D%E7%94%A8%E6%B3%95%E3%80%82"><span class="toc-number">1.8.</span> <span class="toc-text">8. RQ + WebSocket 有两种用法。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-query-key-%E5%BA%94%E8%AF%A5%E5%A6%82%E4%BD%95%E7%BB%84%E7%BB%87%EF%BC%9F"><span class="toc-number">1.9.</span> <span class="toc-text">9. query key 应该如何组织？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E4%BA%9B%E8%83%8C%E6%99%AF%E7%9F%A5%E8%AF%86%EF%BC%9A"><span class="toc-number">1.9.1.</span> <span class="toc-text">一些背景知识：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%82%A3%E4%B9%88%E5%A6%82%E4%BD%95%E9%AB%98%E6%95%88%E5%9C%B0%E7%BB%84%E7%BB%87-query-key%EF%BC%9F"><span class="toc-number">1.9.2.</span> <span class="toc-text">那么如何高效地组织 query key？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-%E5%92%8C-query-key-%E7%9B%B8%E5%85%B3%E7%9A%84%E6%98%AF%EF%BC%8CqueryFn-%E5%BA%94%E8%AF%A5%E6%80%8E%E4%B9%88%E5%86%99%EF%BC%9F"><span class="toc-number">1.10.</span> <span class="toc-text">10. 和 query key 相关的是，queryFn 应该怎么写？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-RQ-%E9%A2%84%E5%A1%AB%E5%85%85%E7%BC%93%E5%AD%98%E6%95%B0%E6%8D%AE%E6%9C%89%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%B3%95"><span class="toc-number">1.11.</span> <span class="toc-text">11. RQ 预填充缓存数据有两种方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E5%90%8C%E7%9A%84%E6%98%AF"><span class="toc-number">1.11.1.</span> <span class="toc-text">相同的是:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E5%90%8C%E7%9A%84%E6%98%AF"><span class="toc-number">1.11.2.</span> <span class="toc-text">不同的是:</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-RN-%E6%98%AF%E5%95%A5%EF%BC%9F"><span class="toc-number">1.12.</span> <span class="toc-text">12. RN 是啥？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-RN-%E5%A4%84%E7%90%86%E9%94%99%E8%AF%AF%E6%9C%89-3-%E7%A7%8D%E6%96%B9%E6%B3%95%E3%80%82"><span class="toc-number">1.13.</span> <span class="toc-text">13. RN 处理错误有 3 种方法。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-RN-%E9%80%9A%E8%BF%87-useMutation-%E5%AE%9E%E7%8E%B0%E7%AA%81%E5%8F%98%EF%BC%88%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE%EF%BC%89%E3%80%82"><span class="toc-number">1.14.</span> <span class="toc-text">14. RN 通过 useMutation 实现突变（更新数据）。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-%E5%85%B3%E4%BA%8E%E7%A6%BB%E7%BA%BF%E3%80%82"><span class="toc-number">1.15.</span> <span class="toc-text">15. 关于离线。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-%E5%85%B3%E4%BA%8E%E8%A1%A8%E5%8D%95%E3%80%82"><span class="toc-number">1.16.</span> <span class="toc-text">16. 关于表单。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17-RQ-%E5%92%8C-React-Router%EF%BC%88%E7%AE%80%E7%A7%B0-RR%EF%BC%896-4-%E7%9A%84%E5%85%B3%E7%B3%BB%E3%80%82"><span class="toc-number">1.17.</span> <span class="toc-text">17. RQ 和 React Router（简称 RR）6.4 的关系。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18-%E5%85%B3%E4%BA%8E%E8%AF%B7%E6%B1%82%E7%80%91%E5%B8%83%E6%B5%81%E3%80%82"><span class="toc-number">1.18.</span> <span class="toc-text">18. 关于请求瀑布流。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#FAQ%E3%80%82"><span class="toc-number">1.19.</span> <span class="toc-text">FAQ。</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%A6%82%E4%BD%95%E7%BB%99-refetch-%E4%BC%A0%E9%80%92%E5%8F%82%E6%95%B0%EF%BC%9F"><span class="toc-number">1.19.1.</span> <span class="toc-text">1. 如何给 refetch 传递参数？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%A6%82%E4%BD%95%E5%81%9A%E5%90%8C%E4%B8%80%E4%B8%AA-useQuery-%E4%BD%86-key-%E5%8F%98%E6%9B%B4%E6%97%B6%E7%9A%84%E8%BF%87%E6%B8%A1%EF%BC%9F"><span class="toc-number">1.19.2.</span> <span class="toc-text">2. 如何做同一个 useQuery 但 key 变更时的过渡？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%B8%BA%E5%95%A5%E6%B2%A1%E6%9C%89%E6%9B%B4%E6%96%B0%EF%BC%9F"><span class="toc-number">1.19.3.</span> <span class="toc-text">3. 为啥没有更新？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E4%B8%BA%E5%95%A5%E8%A6%81%E7%94%A8-useQueryClient-%E8%80%8C%E4%B8%8D%E6%98%AF-import-export-%E7%9A%84%E6%96%B9%E5%BC%8F%E5%BC%95%E7%94%A8-queryClient%EF%BC%9F%E5%9B%A0%E4%B8%BA%E6%9B%B4%E5%87%86%E7%A1%AE%EF%BC%88%E6%AF%94%E5%A6%82%E5%A4%9A-query-client-%E7%9A%84%E5%9C%BA%E6%99%AF%EF%BC%89"><span class="toc-number">1.19.4.</span> <span class="toc-text">4. 为啥要用 useQueryClient 而不是 import+export 的方式引用 queryClient？因为更准确（比如多 query client 的场景）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E4%B8%BA%E5%95%A5%E8%AF%B7%E6%B1%82%E5%A4%B1%E8%B4%A5%E8%80%8C%E6%B2%A1%E6%9C%89%E6%94%B6%E5%88%B0%E9%94%99%E8%AF%AF%E4%BF%A1%E6%81%AF%EF%BC%9F%E5%9B%A0%E4%B8%BA-queryFn-%E6%B2%A1%E6%9C%89%E8%BF%94%E5%9B%9E-reject-%E7%9A%84-Promise%EF%BC%88%E6%AF%94%E5%A6%82%E7%94%A8-fetch-%E6%97%B6%E9%9C%80%E5%9C%A8-res-ok-%E4%B8%8D-ok-%E6%97%B6%E4%B8%BB%E5%8A%A8%E6%8A%9B%E4%B8%AA%E9%94%99%EF%BC%89%E3%80%82"><span class="toc-number">1.19.5.</span> <span class="toc-text">5. 为啥请求失败而没有收到错误信息？因为 queryFn 没有返回 reject 的 Promise（比如用 fetch 时需在 res.ok 不 ok 时主动抛个错）。</span></a></li></ol></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="http://ww1.sinaimg.cn/large/006tNc79ly1g4mh0h5ecmj30uv0u0e82.jpg"></div><div class="author-info__name text-center">张熠</div><div class="author-info__description text-center">摸摸鱼</div><div class="follow-button"><a target="_blank" rel="noopener" href="https://github.com/crazyoctopusdan">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">20</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">15</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">友链</div><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://zcxb.github.io">陈小波</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://www.yongsheng.us">康师傅</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://wukong1995.github.io">悟空</a></div></div></div><div id="content-outer"><div class="no-bg" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Codan's Blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a><a class="site-page" href="/">主页</a><a class="site-page" href="/archives">归档</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">分类</a></span></div><div id="post-info"><div id="post-title">《React Query 笔记》</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2023-03-07</time><div class="post-meta-wordcount"><span>本文字数: </span><span class="word-count">3.3k</span><span class="post-meta__separator">|</span><span>阅读时间: 11 分钟</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h1 id="《React-Query-笔记》"><a href="#《React-Query-笔记》" class="headerlink" title="《React Query 笔记》"></a>《React Query 笔记》</h1><h3 id="要开始做请求方案的调研，第一个深入看的是-React-Query（下面简称为-RQ）。本文是-Practical-React-Query-TkDodo’s-blog-系列文章的阅读笔记。"><a href="#要开始做请求方案的调研，第一个深入看的是-React-Query（下面简称为-RQ）。本文是-Practical-React-Query-TkDodo’s-blog-系列文章的阅读笔记。" class="headerlink" title="要开始做请求方案的调研，第一个深入看的是 React Query（下面简称为 RQ）。本文是 Practical React Query | TkDodo’s blog 系列文章的阅读笔记。"></a>要开始做请求方案的调研，第一个深入看的是 React Query（下面简称为 RQ）。本文是 Practical React Query | TkDodo’s blog 系列文章的阅读笔记。</h3><h2 id="1-为啥很多人会认为-apollo-会取代-redux？"><a href="#1-为啥很多人会认为-apollo-会取代-redux？" class="headerlink" title="1. 为啥很多人会认为 apollo 会取代 redux？"></a>1. 为啥很多人会认为 apollo 会取代 redux？</h2><p><code>apollo</code> 是请求方案，而 <code>redux</code> 是全局状态库，看起来八竿子打不着，但如果我们能在客户端通过缓存的方式访问服务端的数据，那对于 80% 的应用来说，剩下需要处理的客户端状态其实很少。所以，<code>apollo</code> 会取代 <code>redux</code> 吗？It Depends。而 <code>apollo</code> 是处理 <code>graphql</code> 的，RQ 则把 apollo 的很多功能带到了 restful 的 api 场景（且不限于此）。</p>
<h2 id="2-一些文档外的使用技巧"><a href="#2-一些文档外的使用技巧" class="headerlink" title="2. 一些文档外的使用技巧"></a>2. 一些文档外的使用技巧</h2><ol>
<li>默认值的选择很好，但对于新手用户也会有时不时的措手不及，需要理解他们，</li>
<li>使用 <strong>React Query DevTools</strong>，会告诉你缓存的数据状态，同时也要结合 <strong>Chrome DevTool</strong> 的网络面板，因为开发模式请求通常比较快，</li>
<li>把 <code>query key</code> 当 <code>useEffect</code> 的依赖数组使用，两者非常相似，</li>
<li>通过传入 <code>initialData</code> 可以让切换状态时先用缓存中的数据做预填充，提升用户体验，比如 todo app 的 <code>filter</code> 从全部切换到完成时的场景，</li>
<li>保持服务端和客户端状态分离，<code>useQuery()</code> 得到的数据不要存本地 copy，以避免拿到老数据，</li>
<li><code>enable</code> 配置项非常强大，可以做很多事，比如依赖另一个查询的数据、modal 打开时关闭数据轮询、等待用户输入时禁用、用户输入信息后禁用默认数据的查询等，</li>
<li>不要尝试通过 <code>queryClient.setQueryData</code> 修改 <code>query cache</code> 使他成为本地状态管理器，因为每次后台重新获取都可能覆盖他们，</li>
<li>把 <code>useQuery</code> 包起来用会有额外好处，比如 ui 和逻辑分离等。</li>
</ol>
<h2 id="3-如果后端没有返回期望的数据格式，那就需要做格式化了。这时有多个选择，"><a href="#3-如果后端没有返回期望的数据格式，那就需要做格式化了。这时有多个选择，" class="headerlink" title="3. 如果后端没有返回期望的数据格式，那就需要做格式化了。这时有多个选择，"></a>3. 如果后端没有返回期望的数据格式，那就需要做格式化了。这时有多个选择，</h2><ol>
<li>后端转，缺点是不一定能实现，</li>
<li><code>queryFn</code> 里转，缺点是每次 fetch 时需要跑一遍，同时如果你有一个不能自由修改的 service 层可能行不通（不能通过 openapi 生成的），</li>
<li><code>render</code> 函数中转，缺点是语法复杂，需借助 useMemo 提升性能，同时数据可能 undefined，</li>
<li>用 <code>select option</code> 转，没啥明显缺点。所以，相对来说，方案 4 会更好，最佳优化（调用次数最少）、同时允许部分订阅。</li>
</ol>
<h2 id="4-RQ-内置了一些渲染优化的能力。"><a href="#4-RQ-内置了一些渲染优化的能力。" class="headerlink" title="4. RQ 内置了一些渲染优化的能力。"></a>4. RQ 内置了一些渲染优化的能力。</h2><ol>
<li><code>notifyOnChangeProps</code> 配置，从版本 4 起默认开启 <code>track</code> 模式，跟踪你使用了哪些 <code>props</code>，然后只在这些 <code>props</code> 变更后做 <code>notify</code>，可选配置是 <code>all</code> 或 <code>String 数组</code>，选 <code>String 数组</code> 要注意 <code>props</code> 的同步手动更新，避免出现该渲染没渲染然后使用过期数据的问题，</li>
<li>RQ 做了结构共享，比如 <code>[&#123;id:1,text:1&#125;,&#123;id:2,text:2&#125;]</code>，如果更新数据后只变更了 id 1，那通过 <code>useItems(/*id*/2)</code> 拿的数据会保持引用一致性，不会 notify 更新，详见 replaceEqualDeep 的测试。。</li>
</ol>
<h2 id="5-RQ-有-3-种状态"><a href="#5-RQ-有-3-种状态" class="headerlink" title="5. RQ 有 3 种状态:"></a>5. RQ 有 3 种状态:</h2><p><code>success</code>、<code>error</code> 和 <code>loading</code>（idle 在版本 4 里去掉了），以及另一个维度的 <code>isFetching</code>。<br>应该是怎样的状态检测顺序？通常大家会写 <code>loading</code>、<code>error</code>、<code>data</code>（即 success）这样的顺序，但这在 refetch 时，会导致的问题是，loading 或 error 状态时看不到数据。所以更推荐的判断顺序是 data、error、loading。</p>
<h2 id="6-如何做测试？"><a href="#6-如何做测试？" class="headerlink" title="6. 如何做测试？"></a>6. 如何做测试？</h2><p>这里有个例子这里有个例子。</p>
<ol>
<li>不要 <code>mock fetch</code>，用 MSW，</li>
<li>给每个测试一个 <code>QueryClientProvider</code> 并创建新的 <code>QueryClient</code>，好处是完全隔离（备选方案是每次测试完清 QueryClient 的缓存，缺点是并行运行测试时可能会出错），</li>
<li>自定义 hook 用 react-hooks-testing-library 做测试，</li>
<li>测试使用 <code>useQuery</code> 的组件时记得用 <code>QueryClientProvider</code> 包一下，参考 <code>react-query</code> 内部的测试用例，</li>
<li>设置 <code>retry</code> 为 <code>false</code>，否则可能会因为默认要做 3 次 <code>exponential backoff</code> 重试而导致超时，同时注意不要在 <code>useQuery</code> 里写死 <code>retry</code> 参数，改用 <code>queryClient.setQueryDefaults(&#39;todos&#39;, &#123; retry: 5 &#125;)</code> 会对测试更友好，</li>
<li>由于 <code>useQuery</code> 是异步的，记得要加 <code>await waitFor(() =&gt; result.current.isSuccess)</code> 等待请求完成，</li>
<li>如果命令行有太多日志，可以通过设置 <code>QueryClient</code> 的 <code>logger</code> 参数避免冗余报错，<code>logger: &#123; error: () =&gt; &#123;&#125;, log: console.log, warn: console.warn: console.warn &#125;</code></li>
</ol>
<h2 id="7-关于类型。"><a href="#7-关于类型。" class="headerlink" title="7. 关于类型。"></a>7. 关于类型。</h2><ol>
<li><code>useQuery</code> 有两种写法，泛型和类型推导，推荐后者，让 <code>queryFn</code> 返回正确的类型，剩下的全部走推导，注意这里会缺 <code>error</code> 的类型，写的时候可以用 <code>error instanceof Error</code> 确保下，</li>
<li><code>useQuery</code> 加上 <code>enabled</code> 参数时就可能是 undefined 了，需在 <code>queryFn</code> 里处理 undefined 时抛错，</li>
<li>使用 <code>useInfiniteQuery</code> 时记得给 <code>queryFn</code> 的 <code>pageParam</code> 加类型，</li>
<li>使用 <code>default queryFn</code> 时要注意 <code>queryKey</code> 的参数类型。</li>
</ol>
<h2 id="8-RQ-WebSocket-有两种用法。"><a href="#8-RQ-WebSocket-有两种用法。" class="headerlink" title="8. RQ + WebSocket 有两种用法。"></a>8. RQ + WebSocket 有两种用法。</h2><ol>
<li><p>推模式，服务端推送数据，客户端通过 <code>queryClient.setQueriesData</code> 更新数据，缺点是推送了并不需要的数据，比如你并不在需要数据的那个页面，</p>
</li>
<li><p>拉模式，服务端只发送事件，告知客户端哪些数据更新了，然后客户端通过 <code>queryClient.invalidateQueries</code> 让那些请求缓存失效，在需要的时候再去服务端拉数据。</p>
<p> ※个人建议无脑用第二种。同时要注意修改 <code>staleTime</code> 为 <code>Infinity</code>，WebSocket 会保证本地数据是最新的，无需通过 <code>staleTime</code> 设置过期时间。</p>
</li>
</ol>
<h2 id="9-query-key-应该如何组织？"><a href="#9-query-key-应该如何组织？" class="headerlink" title="9. query key 应该如何组织？"></a>9. query key 应该如何组织？</h2><h3 id="一些背景知识："><a href="#一些背景知识：" class="headerlink" title="一些背景知识："></a>一些背景知识：</h3><ol>
<li><code>useQuery</code> 和 <code>useInfiniteQuery</code> 共享同一个缓存，所以 key 不能重复，</li>
<li>重新获取不同参数的数据时，不能用 <code>refetch(xxx)</code>，<code>refetch</code> 不能重新获取相同 key 的数据，解法是给 <code>useQuery</code> 传不同的 key，</li>
<li>与查询缓存交互有多种方法，比如 <code>invalidateQueries</code> 和 <code>setQueriesData</code> 等。</li>
</ol>
<h3 id="那么如何高效地组织-query-key？"><a href="#那么如何高效地组织-query-key？" class="headerlink" title="那么如何高效地组织 query key？"></a>那么如何高效地组织 query key？</h3><ol>
<li>用比如 <code>[&#39;todos&#39;, &#39;list&#39;, &#123; filter: &#39;all&#39; &#125;]</code> 这样的结构，好处是在 <code>invalidate</code> 或突变操作时会更灵活，比如同时操作所有的 <code>todos &gt; list</code>，</li>
<li>使用 <code>query key factory</code>，避免手写容易导致的错误，比如 <code>todoKeys.all</code>、<code>todoKeys.detail(id)</code> 。</li>
</ol>
<h2 id="10-和-query-key-相关的是，queryFn-应该怎么写？"><a href="#10-和-query-key-相关的是，queryFn-应该怎么写？" class="headerlink" title="10. 和 query key 相关的是，queryFn 应该怎么写？"></a>10. 和 query key 相关的是，queryFn 应该怎么写？</h2><ol>
<li>内联，比如 <code>useQuery([&#39;todos&#39;, p1, p2], () =&gt; fetchXXX(p1, p2))</code>，缺点是 <code>key</code> 和 <code>fn</code> 里的参数必须同步更新，一旦遗漏比如忘记更新 <code>key</code> 里的参数，会导致请求数据不刷新，</li>
<li><code>QueryFunctionContext</code>，比如</li>
</ol>
<figure class="highlight plaintext"><figcaption><span>p1, p2]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(&#123; queryKey &#125;) =&gt; fetchXXX(queryKey[1], queryKey[2]))</span><br></pre></td></tr></table></figure>

<p>，只只需维护 <code>query key</code> 里的参数即可，缺点是内联函数才有类型，同时 <code>queryKey</code> 是数组格式，前面几项通常会用不到， 3. 在 2 的基础上，支持独立函数，<code>QueryFunctionContext&lt;ReturnType&lt;typeof queryKey&gt;&gt;</code>， 4. 在 3 的基础上，把 <code>key</code> 由数组改成 <code>object</code>，比如 <code>useQuery(&#123; scope: &#39;todos&#39;, entity: &#39;list&#39;, state, sorting &#125;, fn)</code> ，看起来是目前最完美的版本，类型也安全。</p>
<h2 id="11-RQ-预填充缓存数据有两种方法"><a href="#11-RQ-预填充缓存数据有两种方法" class="headerlink" title="11. RQ 预填充缓存数据有两种方法"></a>11. RQ 预填充缓存数据有两种方法</h2><p><code>placeholderData</code> 和 <code>initialData</code>。</p>
<h3 id="相同的是"><a href="#相同的是" class="headerlink" title="相同的是:"></a>相同的是:</h3><ol>
<li>都会直接跳过 <code>loading</code> 状态进入 <code>success</code> 状态，</li>
<li>都支持值或者返回值的函数两种类型。</li>
</ol>
<h3 id="不同的是"><a href="#不同的是" class="headerlink" title="不同的是:"></a>不同的是:</h3><ol>
<li><code>initialData</code> 在缓存层处理，直接放入缓存，尊重 <code>staleTime</code>，一个 <code>query key</code> 只能由一个 <code>initialData</code>，<code>refetch</code> 错误时数据还在，</li>
<li><code>placeholderData</code> 在观察者层处理，不放入缓存，用于临时占位，可以为相同的 <code>query key</code> 创建多个不同的 <code>placeholderData</code>，<code>refetch</code> 错误时数据消失。</li>
</ol>
<h2 id="12-RN-是啥？"><a href="#12-RN-是啥？" class="headerlink" title="12. RN 是啥？"></a>12. RN 是啥？</h2><p>他不是请求库，因为不内置 axios、fetch 之类的；他是异步的状态管理器，或者是服务端状态的同步工具。<br>在 RN 之前，通常有两种数据获取的方法:</p>
<ol>
<li>一次获取、全局分发、很少更新;</li>
<li>每次获取（比如每次 modal 打开时都请求一遍数据）。这两种都不太好，前者更新太少，后者更新太多。RN 通过 <code>Stale While Revalidate</code> 和机制的 <code>refetch</code> 机制来解这个问题。<code>refetch</code> 触发时机包括 <code>refetchOnMount</code>、<code>refetchOnWindowFocus</code>、<code>refetchOnReconnect</code>，以及手动的 <code>queryClient.invalidateQueries</code>。同时可针对不同场景设置不同的 staleTime 来控制 refetch 频率。</li>
</ol>
<h2 id="13-RN-处理错误有-3-种方法。"><a href="#13-RN-处理错误有-3-种方法。" class="headerlink" title="13. RN 处理错误有 3 种方法。"></a>13. RN 处理错误有 3 种方法。</h2><ol>
<li><code>useQuery</code> 返回值的 <code>isError</code> 或 <code>status === &#39;error&#39;</code> 判断;</li>
<li><code>onError</code> 回调，可以是 <code>query</code> 级，也可以是全局用 <code>queryCache</code> 配，<code>query</code> 级的要当心避免多次触发;</li>
<li>基于 <code>Error Boundary</code>，配置 <code>useErrorBoundary:true</code> 即可。</li>
</ol>
<p>三种方法可以搭配使用，作者建议针对 refetch 错误用全局 onError + toast 显示，其他的用 1 或 3 的方法处理。另外，如果有 fetch，要在 queryFn 里处理 4xx 和 5xx 请求，他不像 axios 一样会 reject。</p>
<h2 id="14-RN-通过-useMutation-实现突变（更新数据）。"><a href="#14-RN-通过-useMutation-实现突变（更新数据）。" class="headerlink" title="14. RN 通过 useMutation 实现突变（更新数据）。"></a>14. RN 通过 useMutation 实现突变（更新数据）。</h2><p>和 <code>useQuery</code> 相同的是都会提供 <code>loading</code>、<code>error</code>、<code>status</code> 数据，也支持 <code>onSuccess</code>、<code>onError</code> 和 <code>onSettled</code> 回调。和 <code>useQuery</code> 不同的是，<code>useQuery</code> 是声明式，而 <code>useMutation</code> 是命令式，同时 <code>useMutation</code> 也不会共享状态。突变后要更新数据有三种思路，</p>
<ol>
<li><code>invalidate query</code> 让他 <code>refetch</code>，注意只有活跃的 <code>query</code> 会 <code>refetch</code>;</li>
<li>通过 <code>queryClient.setQueryData</code> 直接更新，适用于知道全部数据的场景，但可能不安全，比如遇到排序、新增后新 id 数据时会变得很复杂;</li>
<li>乐观更新，适用于小交互。一些常见问题:</li>
</ol>
<ul>
<li><code>onSuccess</code> 回调支持 <code>Promise</code>，适用于比如你需要在 <code>invalidate</code> 操作完成前保持 <code>useMutation</code> 的 <code>loading</code> 状态时;</li>
<li><code>useMutation</code> 有 <code>mutate</code> 和 <code>mutateAsync</code> 两个方法，通常更推荐 <code>mutate</code>，因为 <code>mutateAsync</code> 要自行 <code>try...catch</code> 处理异常场景，<code>mutateAsync</code> 的场景是有多个并行或串行依赖性突变时;</li>
<li><code>useMutation fn</code> 只支持一个参数，可以用 <code>Object</code>;</li>
<li><code>useMutation</code> 和 <code>mutation</code> 都有回调，前者肯定会执行，适用于逻辑，后者组件销毁后不执行，适用于 UI。</li>
</ul>
<h2 id="15-关于离线。"><a href="#15-关于离线。" class="headerlink" title="15. 关于离线。"></a>15. 关于离线。</h2><ol>
<li>有一个 <code>networkMode</code> 设置，可以选择三种模式:</li>
</ol>
<ul>
<li><code>online</code>（默认模式，假设有网络时才能用，没网络会进入暂停状态）</li>
<li><code>always</code>（不关心网络状态，永远会启用查询，适用于数据获取以外的事）</li>
<li><code>offlineFirst</code>（总是会发出第一个请求，失败时进入暂停状态），</li>
</ul>
<ol start="2">
<li><code>useQuery()</code> 会返回 <code>fetchStatus</code>，包括 <code>fetching</code>、<code>paused</code>、<code>idle</code> 三种状态，可以和 <code>status</code> 结合使用，两者<strong>不互斥</strong>。</li>
</ol>
<h2 id="16-关于表单。"><a href="#16-关于表单。" class="headerlink" title="16. 关于表单。"></a>16. 关于表单。</h2><ol>
<li>作者推荐了 <code>react-hook-form</code> 和 RN 搭配使用，</li>
<li>最简方案是 <code>useQuery</code> 请求数据作为默认值然后 <code>useMutation</code> 突变更新，但存在两个问题，<code>data</code> 可能为空和没有后台更新，<code>data</code> 可能为空壳通过提取组件的方式解，没有后台更新可通过受控组件+优先用受控组件的值的方式解，</li>
<li>防止重复提交可基于 <code>useMutation()</code> 返回的 <code>isLoading</code>，给提交按钮加 <code>disabled=&#123;isLoading&#125;</code> 来解，</li>
<li>如果提交后没有跳转到其他页面，通常需要在 <code>mutate</code> 之后 <code>invalidate query</code>（更新数据）并 reset 表单。</li>
</ol>
<h2 id="17-RQ-和-React-Router（简称-RR）6-4-的关系。"><a href="#17-RQ-和-React-Router（简称-RR）6-4-的关系。" class="headerlink" title="17. RQ 和 React Router（简称 RR）6.4 的关系。"></a>17. RQ 和 React Router（简称 RR）6.4 的关系。</h2><ol>
<li>RR 没有做 <code>cache</code> 而 RQ 有，RR 是关于 when（时机）而 RQ 是关于 what（具体请求方案）;</li>
<li>只有 RR 可以做到提前获取，但问题是由于没有缓存从而会到请求过于频繁;</li>
<li>RQ 和 RR 可结合使用，在 <code>loader</code> 里通过 <code>queryClient.fetchQuery</code> 发起请求，组件里用 <code>useQuery</code> 正常拿数据即可，出于 ts 类型考虑默认值可以填 <code>useLoaderData</code> 的数据;</li>
<li>如果用 RR 的 <code>action</code> 做突变，<code>redirect</code> 之前记得 <code>invalidate</code> 相关的 <code>query</code>，同时 <code>invalidate</code> 可以根据场景选择是否 <code>await</code>。</li>
</ol>
<h2 id="18-关于请求瀑布流。"><a href="#18-关于请求瀑布流。" class="headerlink" title="18. 关于请求瀑布流。"></a>18. 关于请求瀑布流。</h2><ol>
<li>依赖类 <code>query</code> 的瀑布流是避免不了的，比如 <code>/user/1/project</code> 依赖 <code>/user</code> 的数据，非依赖的写多个 <code>useQuery</code> 或者用 <code>useQueries</code> 解效果相同;</li>
<li><code>Suspense</code> 会在 <code>Promise</code> 为 <code>pending</code> 状态时用 <code>fallback</code> 渲染，缺点是 <code>fallback</code> 时间过长从而影响渲染，渲染迟了进而影响子组件的数据请求，从而导致瀑布流;</li>
<li><code>queryClient.prefetchQuery</code> 可以缓解这个问题，一种用法是放在组件外，可以在代码下载解析时即执行;</li>
<li><code>useQueries</code> 暂不支持 <code>suspense</code>;</li>
<li>如果列表页包含详情页的所有数据，可以用列表页缓存的数据填充详情页缓存，这里也分拉和推两种方式。</li>
</ol>
<h2 id="FAQ。"><a href="#FAQ。" class="headerlink" title="FAQ。"></a>FAQ。</h2><h3 id="1-如何给-refetch-传递参数？"><a href="#1-如何给-refetch-传递参数？" class="headerlink" title="1. 如何给 refetch 传递参数？"></a>1. 如何给 <code>refetch</code> 传递参数？</h3><p>不能传递。</p>
<h3 id="2-如何做同一个-useQuery-但-key-变更时的过渡？"><a href="#2-如何做同一个-useQuery-但-key-变更时的过渡？" class="headerlink" title="2. 如何做同一个 useQuery 但 key 变更时的过渡？"></a>2. 如何做同一个 <code>useQuery</code> 但 <code>key</code> 变更时的过渡？</h3><p>用 <code>placeholderData</code> 或者配置 <code>keepPreviousData: true</code> 保留之前的数据</p>
<h3 id="3-为啥没有更新？"><a href="#3-为啥没有更新？" class="headerlink" title="3. 为啥没有更新？"></a>3. 为啥没有更新？</h3><p>query key 不匹配（比如 1 和 ‘1’ 是不一致的），或者 query client 引用不稳定（比如在 App 里创建的由于 re-render 或路由变更会导致引用不一致）</p>
<h3 id="4-为啥要用-useQueryClient-而不是-import-export-的方式引用-queryClient？因为更准确（比如多-query-client-的场景）"><a href="#4-为啥要用-useQueryClient-而不是-import-export-的方式引用-queryClient？因为更准确（比如多-query-client-的场景）" class="headerlink" title="4. 为啥要用 useQueryClient 而不是 import+export 的方式引用 queryClient？因为更准确（比如多 query client 的场景）"></a>4. 为啥要用 useQueryClient 而不是 import+export 的方式引用 queryClient？因为更准确（比如多 query client 的场景）</h3><h3 id="5-为啥请求失败而没有收到错误信息？因为-queryFn-没有返回-reject-的-Promise（比如用-fetch-时需在-res-ok-不-ok-时主动抛个错）。"><a href="#5-为啥请求失败而没有收到错误信息？因为-queryFn-没有返回-reject-的-Promise（比如用-fetch-时需在-res-ok-不-ok-时主动抛个错）。" class="headerlink" title="5. 为啥请求失败而没有收到错误信息？因为 queryFn 没有返回 reject 的 Promise（比如用 fetch 时需在 res.ok 不 ok 时主动抛个错）。"></a>5. 为啥请求失败而没有收到错误信息？因为 queryFn 没有返回 reject 的 Promise（比如用 fetch 时需在 res.ok 不 ok 时主动抛个错）。</h3><p>参考：<br>Practical React Query | TkDodo’s blog</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">作者: </span><span class="post-copyright-info"><a href="mailto:undefined">张熠</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://crazyoctopusdan.github.io/2023/03/07/%E3%80%8AReact%20Query%20%E7%AC%94%E8%AE%B0%E3%80%8B/">https://crazyoctopusdan.github.io/2023/03/07/%E3%80%8AReact%20Query%20%E7%AC%94%E8%AE%B0%E3%80%8B/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/react-query/">react-query</a></div><div class="addthis_inline_share_toolbox pull-right"></div><script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=undefined" async></script><nav id="pagination"><div class="prev-post pull-left"><a href="/2023/03/08/%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86React%E4%B8%AD%E7%9A%84Errors/"><i class="fa fa-chevron-left">  </i><span>怎么处理React中的Errors</span></a></div><div class="next-post pull-right"><a href="/2021/03/04/gitflow%20%E6%93%8D%E4%BD%9C%E6%80%9D%E8%80%83/"><span>gitflow 操作思考</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2018 - 2023 By 张熠</div><div class="framework-info"></div><div class="footer_custom_text">欢迎来到Codan的博客 | <i class="fa fa-envelope-o" aria-hidden="true"></i><a href="mailto:contactcodan@163.com">contactcodan@163.com</a> | <i class="fa fa-weixin" aria-hidden="true"></i>zy840271360</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script src="/js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">文章搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索封面标题(-^〇^-)"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>