<!DOCTYPE html><html><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="怎么处理React中的Errors"><meta name="keywords" content="React"><meta name="author" content="张熠"><meta name="copyright" content="张熠"><title>怎么处理React中的Errors | Codan's Blog</title><link rel="shortcut icon" href="/img/zhangyi.png"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"╥﹏╥木有找到: ${query}"}},
  copy: {
    success: '复制成功！',
    error: '复制失败了',
    noSupport: '当前浏览器并不支持~'
  }
} </script><meta name="generator" content="Hexo 6.3.0"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="文章信息">网站信息</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已阅读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86-React-%E4%B8%AD%E7%9A%84-Errors"><span class="toc-number">1.</span> <span class="toc-text">怎么处理 React 中的 Errors</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%83%8C%E6%99%AF"><span class="toc-number">1.1.</span> <span class="toc-text">背景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E4%BB%AC%E8%A6%81%E6%8D%95%E8%8E%B7%E9%94%99%E8%AF%AF%EF%BC%9F"><span class="toc-number">1.2.</span> <span class="toc-text">为什么我们要捕获错误？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E9%A1%BE%E4%B8%80%E4%B8%8B%EF%BC%9A%E5%A6%82%E4%BD%95%E5%9C%A8-Javascript-%E4%B8%AD%E6%8D%95%E6%8D%89%E9%94%99%E8%AF%AF"><span class="toc-number">1.3.</span> <span class="toc-text">回顾一下：如何在 Javascript 中捕捉错误</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%A8-React-%E4%B8%AD-%E7%AE%80%E5%8D%95%E7%9A%84-try-catch%EF%BC%9A%E5%A6%82%E4%BD%95%E5%81%9A-%E4%BB%A5%E5%8F%8A-%E5%A6%82%E4%BD%95%E8%AD%A6%E5%91%8A"><span class="toc-number">1.4.</span> <span class="toc-text">在 React 中 简单的 try&#x2F;catch：如何做 以及 如何警告</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%99%90%E5%88%B6-1%EF%BC%9A%E4%BD%BF%E7%94%A8-useEffect-%E9%92%A9%E5%AD%90%E4%BC%9A%E9%81%87%E5%88%B0%E9%BA%BB%E7%83%A6%E3%80%82"><span class="toc-number">1.4.1.</span> <span class="toc-text">限制 1：使用 useEffect 钩子会遇到麻烦。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%99%90%E5%88%B6-2%EF%BC%9A%E5%AD%90%E7%BB%84%E4%BB%B6"><span class="toc-number">1.4.2.</span> <span class="toc-text">限制 2：子组件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%99%90%E5%88%B6-3%EF%BC%9A%E5%9C%A8-Render-%E6%9C%9F%E9%97%B4-setting-state-%E6%98%AF%E4%B8%8D%E5%85%81%E8%AE%B8%E7%9A%84"><span class="toc-number">1.4.3.</span> <span class="toc-text">限制 3：在 Render 期间 setting state 是不允许的</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#React-ErrorBoundary-%E7%BB%84%E4%BB%B6"><span class="toc-number">1.5.</span> <span class="toc-text">React ErrorBoundary 组件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ErrorBoundary-%E7%BB%84%E4%BB%B6%E7%9A%84%E9%99%90%E5%88%B6"><span class="toc-number">1.6.</span> <span class="toc-text">ErrorBoundary 组件的限制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-ErrorBoundary-%E6%8D%95%E8%8E%B7%E5%BC%82%E6%AD%A5%E9%94%99%E8%AF%AF"><span class="toc-number">1.7.</span> <span class="toc-text">使用 ErrorBoundary 捕获异步错误</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%83%BD%E7%94%A8-react-error-boundary-%E4%BB%A3%E6%9B%BF%E5%90%97"><span class="toc-number">1.8.</span> <span class="toc-text">能用 react-error-boundary 代替吗?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.9.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="http://ww1.sinaimg.cn/large/006tNc79ly1g4mh0h5ecmj30uv0u0e82.jpg"></div><div class="author-info__name text-center">张熠</div><div class="author-info__description text-center">摸摸鱼</div><div class="follow-button"><a target="_blank" rel="noopener" href="https://github.com/crazyoctopusdan">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">20</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">15</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">友链</div><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://zcxb.github.io">陈小波</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://www.yongsheng.us">康师傅</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://wukong1995.github.io">悟空</a></div></div></div><div id="content-outer"><div class="no-bg" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Codan's Blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a><a class="site-page" href="/">主页</a><a class="site-page" href="/archives">归档</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">分类</a></span></div><div id="post-info"><div id="post-title">怎么处理React中的Errors</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2023-03-08</time><div class="post-meta-wordcount"><span>本文字数: </span><span class="word-count">4.3k</span><span class="post-meta__separator">|</span><span>阅读时间: 15 分钟</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h1 id="怎么处理-React-中的-Errors"><a href="#怎么处理-React-中的-Errors" class="headerlink" title="怎么处理 React 中的 Errors"></a>怎么处理 React 中的 Errors</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近在研究如何在 React 中捕获和处理错误，<br><code>try/catch</code>和<code>ErrorBoundary</code>的用法、模式和警告，什么时候是可行的，什么时候是不行的，以及如何用<code>ErrorBoundary</code>捕获所有错误，包括<code>async</code>错误和来自事件处理程序的错误。</p>
<p>我们都希望我们的应用能够稳定，能够完美地运行，并且能够满足所有可以想象到的情况，但可悲的现实是，我们都是人类(至少我是这么认为的)，我们都会犯错误，不存在没有错误的代码。无论我们多么小心，或者我们编写了多少自动化测试，测试同学多么仔细的覆盖，总会出现一些严重错误的情况。当涉及到用户体验时，重要的事情是预测这种可怕的现象（如白屏等），尽可能地明确展示出它，并以一种优雅的方式处理它，直到它真正被修复。</p>
<p>所以今天，让我们来看看<code>React</code>中的错误处理：如果发生错误，我们可以做什么，不同的错误捕捉方法有什么注意事项，以及如何减轻它们产生的影响。</p>
<hr>
<h2 id="为什么我们要捕获错误？"><a href="#为什么我们要捕获错误？" class="headerlink" title="为什么我们要捕获错误？"></a>为什么我们要捕获错误？</h2><p>但是首先，为什么在 React 中有一些错误捕捉解决方案是至关重要的?</p>
<p>答案很简单：从版本 16 开始，在 React 生命周期中抛出的错误如果没有停止，将导致整个应用程序自行卸载。在此之前，组件将被保留在屏幕上，即使是畸形或者错误的。但是现在（React16 之后），在 UI 的某个无关紧要的部分，甚至是一些您无法控制的外部库中，一个未捕获的错误可能会破坏整个页面，并为所有人呈现一个空白屏幕。</p>
<p>这是以前从来没有前端开发人员能带来的毁灭性打击 😅</p>
<hr>
<h2 id="回顾一下：如何在-Javascript-中捕捉错误"><a href="#回顾一下：如何在-Javascript-中捕捉错误" class="headerlink" title="回顾一下：如何在 Javascript 中捕捉错误"></a>回顾一下：如何在 Javascript 中捕捉错误</h2><p>当涉及到在常规 Javascript 中捕获这些令人讨厌的意外时，这些工具非常简单：</p>
<p>我们有一个很好的传统的<code>try/catch</code>语句，它的作用不言自明：<br>尝试<code>try</code>做一些事情，如果他们失败了 —— 捕获错误<code>catch</code>并做一些事情来处理它:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 如果这里产生了错误，会throw一个错误</span></span><br><span class="line">    <span class="title function_">doSomething</span>();</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="comment">// 如果错误发生了，catch它并做一些事情，而不停止应用程序</span></span><br><span class="line">    <span class="comment">// 就像服务端接口出点什么小问题</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这也适用于具有相同语法的 async 函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">&#x27;/jiekou&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="comment">// 接口报错啦</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者，如果我们要遵循古早的<code>promise</code>，同样也有专门针对它们的捕获方法。因此，如果我们用基于<code>promise</code>的 API 重写之前的获取示例，它将像这样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">fetch</span>(<span class="string">&#x27;/jiekou&#x27;</span>).<span class="title function_">then</span>(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 接口成功返回</span></span><br><span class="line">  <span class="comment">// 做点什么处理</span></span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 接口报错，来兜兜底</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>这是相同的概念，只有一些不同的实现，因此在本文的其余部分中，我将仅对所有错误使用<code>try/catch</code>语法。</p>
<h2 id="在-React-中-简单的-try-catch：如何做-以及-如何警告"><a href="#在-React-中-简单的-try-catch：如何做-以及-如何警告" class="headerlink" title="在 React 中 简单的 try/catch：如何做 以及 如何警告"></a>在 React 中 简单的 try/catch：如何做 以及 如何警告</h2><p>当捕获错误时，我们需要对此做些事情。那么，除了在某个地方记录它，我们还能做什么？或者，更确切地说：我们能为用户做什么？只要将它们留下一个空白屏幕或报错的界面就完全不是对用户友好的。</p>
<p>最明显，最直观的答案是在我们等待修复程序时渲染一些东西。幸运的是，我们可以在<code>catch</code>声明中做任何我们想做的事情，包括设置<code>state</code>。因此，我们可以做这样的事情：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">SomeComponent</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> [hasError, setHasError] = <span class="title function_">useState</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 可能在获取数据啥啥的</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">            <span class="comment">// 获取失败，没数据展示了~</span></span><br><span class="line">            <span class="title function_">setHasError</span>(<span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发生了错误 =&gt; 那就展示一些报错提示页</span></span><br><span class="line">    <span class="keyword">if</span> (hasError) <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">SomeErrorScreen</span> /&gt;</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 无事发生~ =&gt; 那就正常展示</span></span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">SomeComponentContent</span> &#123;<span class="attr">...dataSomething</span>&#125; /&gt;</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们发送一个请求，如果它失败-设置错误状态，如果<code>hasError</code>为<code>true</code>，那么我们呈现一个错误组件浮层，为用户提供一些额外的信息，如支持联系号码、联系我司 xxx。</p>
<p>这种方法非常直接，适用于简单、可预测和小部分的组件，如捕获失败的获取请求。但是，如果开发人员希望捕获组件中所有可能发生的错误，那么将面临一些<strong>严格的限制</strong>：</p>
<h3 id="限制-1：使用-useEffect-钩子会遇到麻烦。"><a href="#限制-1：使用-useEffect-钩子会遇到麻烦。" class="headerlink" title="限制 1：使用 useEffect 钩子会遇到麻烦。"></a>限制 1：使用 useEffect 钩子会遇到麻烦。</h3><p>如果我们在<code>try/catch</code>中使用<code>useEffect</code>，会完全不生效：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;妈呀错啦！&#x27;</span>);</span><br><span class="line">  &#125;, [])</span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">  <span class="comment">// useEffect 抛出错误, 这里永远不会被调用到</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之所以发生这种情况，是因为使用<code>useEffect</code>在呈现后被异步调用，因此从<code>try/catch</code>的角度来看，好像一切都会正常发生。<br>这与任何<code>Promise</code>都是一样的:如果我们不等待结果，那么 javascript 将继续它的业务，当<code>Promise</code>完成时返回它，只执行<code>useEffect</code>(或<code>Promise</code>的)内部的内容。<code>try /catch</code>块将被执行，并且在那时早就消失了。</p>
<p>所以为了捕捉<code>useEffect</code>中的错误，<code>try/catch</code>也应该放在里面：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line">   <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;妈呀错啦！&#x27;</span>);</span><br><span class="line"> &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">   <span class="comment">// 这就能捕获到了</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;, [])</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://codesandbox.io/embed/try-catch-and-useeffect-28h3ux?file=/src/App.tsx?codemirror=1&hidedevtools=0&view=preview">玩一下这个例子，戳戳</a></p>
<p>这适用于任何使用<code>useEffect</code>的<code>hook</code>或任何异步的东西。因此，不是仅仅一个<code>try/catch</code>就可以包装所有内容，而是必须将其分割成多个块：每个<code>hook</code>一个。</p>
<h3 id="限制-2：子组件"><a href="#限制-2：子组件" class="headerlink" title="限制 2：子组件"></a>限制 2：子组件</h3><p><code>try / catch</code>将无法捕获子组件内发生的任何事情。<br>你不能这样做:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">Component</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> child;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    child = <span class="language-xml"><span class="tag">&lt;<span class="name">Child</span> /&gt;</span></span></span><br><span class="line">  &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">    <span class="comment">// 对于捕获子组件内的错误无用，不会被触发</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> child;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 或者这样也不行</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Component</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Child</span> /&gt;</span></span></span><br><span class="line">  &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">    <span class="comment">// 对于捕获子组件内的错误还是无用，不会被触发</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://codesandbox.io/embed/try-catch-for-children-doesnt-work-5elto1?file=/src/App.tsx?codemirror=1&hidedevtools=0&view=preview">玩一下这个例子，戳戳</a></p>
<p>这是因为当我们写入<code>&lt;Child /&gt;</code>时，我们实际上并没有呈现这个组件。我们正在做的是创建一个<code>Component Element</code>，它只不过是一个组件的定义，只是一个包含必要信息的对象，如组件<code>type</code>和<code>props</code>，这些信息稍后将被 React 本身使用(指触发该组件的渲染)。它会在<code>try/catch</code> block 成功执行后发生，与<code>promises</code>和<code>useEffect hook</code>的情况完全相同。</p>
<p>如果想了解更详细的元素和组件是如何工作的，下面是这篇文章的链接：<a target="_blank" rel="noopener" href="https://www.developerway.com/posts/react-elements-children-parents">The mystery of React Element, children, parents and re-renders</a></p>
<h3 id="限制-3：在-Render-期间-setting-state-是不允许的"><a href="#限制-3：在-Render-期间-setting-state-是不允许的" class="headerlink" title="限制 3：在 Render 期间 setting state 是不允许的"></a>限制 3：在 Render 期间 setting state 是不允许的</h3><p>如果你试图捕获<code>useEffect</code>和各种回调之外的错误(即在组件的渲染期间)，那么正确地处理它们不再那么简单：<code>render</code>期间不允许状态更新。</p>
<p>例如，如果发生错误，像这样的简单代码只会导致重新渲染的无限循环：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">Component</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> [hasError, setHasError] = <span class="title function_">useState</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="title function_">doSomethingWrong</span>();</span><br><span class="line">  &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">    <span class="comment">// 这么做就会出现死循环哦</span></span><br><span class="line">    <span class="comment">// 不信的话，下面就可以试试</span></span><br><span class="line">    <span class="title function_">setHasError</span>(<span class="literal">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>i&#x27;m good<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://codesandbox.io/s/vibrant-wilbur-02c4fc?file=/src/App.tsx">试试就逝世</a></p>
<p>当然，我们可以在这里返回错误组件，而不是设置状态：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">Component</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="title function_">doSomethingWrong</span>();</span><br><span class="line">  &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">    <span class="comment">// 这是木有问题的</span></span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">SomeErrorScreen</span> /&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是，正如大家感觉的那样，这有点麻烦，并且将迫使我们以不同的方式处理同一个组件中的错误：<code>useEffect</code>的状态、<code>callback</code>，以及直接返回其他的所有内容。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 虽然它可以工作，但它非常麻烦，很难维护，不推荐这么写</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">SomeComponent</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> [hasError, setHasError] = <span class="title function_">useState</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 处理一些逻辑，如 发送请求</span></span><br><span class="line">    &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">      <span class="comment">// 不能只是在useEffect或回调错误的情况下返回</span></span><br><span class="line">      <span class="comment">// 所以必须使用state</span></span><br><span class="line">      <span class="title function_">setHasError</span>(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 渲染时候的一些逻辑</span></span><br><span class="line">  &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">    <span class="comment">// 但这里我们不能使用state，所以必须直接返回一些组件以防出现错误</span></span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">SomeErrorScreen</span> /&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在错误状态的情况下仍然需要返回</span></span><br><span class="line">  <span class="keyword">if</span> (hasError) <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">SomeErrorScreen</span> /&gt;</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">SomeComponentContent</span> &#123;<span class="attr">...dataSomething</span>&#125; /&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结一下：如果我们在 React 中仅仅依赖<code>try/catch</code>，我们要么会错过大部分错误，要么会把每个组件都变成一堆无法理解的代码，这些代码本身可能会导致错误。</p>
<p>幸运的是，还有另一种方法。</p>
<h2 id="React-ErrorBoundary-组件"><a href="#React-ErrorBoundary-组件" class="headerlink" title="React ErrorBoundary 组件"></a>React ErrorBoundary 组件</h2><p>为了减轻上述限制，React 为我们提供了所谓的“错误边界”：一个特殊的 API，以某种方式将常规组件转换为<code>try/catch</code>语句，仅适用于 React 声明性代码。你可以在每个例子中看到的典型用法，包括 React 文档，是这样的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">Component</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">ErrorBoundary</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">SomeChildComponent</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">AnotherChildComponent</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">ErrorBoundary</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，如果这些组件或它们的子组件在<code>render</code>期间出现错误，错误将被捕获并处理。</p>
<p>但是 React 并没有给我们组件本身，它只是给了我们一个实现它的工具。最简单的实现是这样的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ErrorBoundary</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line">    <span class="comment">// 初始化错误状态</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123; <span class="attr">hasError</span>: <span class="literal">false</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 有错误发生则转换状态</span></span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">getDerivedStateFromError</span>(<span class="params">error</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">hasError</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 如果错误发生了，返回一个 fallback component</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">hasError</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;&gt;</span>哎妈呀吗，组件出错了!<span class="tag">&lt;/&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">children</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们创建一个常规的类组件(这里是老式的写法，没有用于<code>ErrorBoundary</code>的钩子)，并实现<code>getDerivedStateFromError</code>方法：它将组件转换为适当的<code>ErrorBoundary</code>。</p>
<p>处理错误时要做的另一件重要的事情是将错误信息发送到可以提醒到开发人员的地方。为此，错误边界提供了<code>componentDidCatch</code>方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ErrorBoundary</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="comment">// 其他都一样</span></span><br><span class="line"></span><br><span class="line">  <span class="title function_">componentDidCatch</span>(<span class="params">error, errorInfo</span>) &#123;</span><br><span class="line">    <span class="comment">// 这里向外暴露错误</span></span><br><span class="line">    <span class="title function_">log</span>(error, errorInfo);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在设置了<code>ErrorBoundary</code>之后，我们可以对它做任何我们想做的事情，就像任何其他组件一样。例如，我们可以使它更具可复用性，并将<code>fallback</code>作为<code>props</code>传递：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 如果又错误发生，返回 fallback component</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">hasError</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">fallback</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">children</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用法如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">Component</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">ErrorBoundary</span> <span class="attr">fallback</span>=<span class="string">&#123;</span>&lt;&gt;</span>艾玛，组件出错了!<span class="tag">&lt;/&gt;</span></span>&#125;&gt;</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">SomeChildComponent</span> /&gt;</span></span></span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">AnotherChildComponent</span> /&gt;</span></span></span><br><span class="line">    &lt;/<span class="title class_">ErrorBoundary</span>&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者加上我们可能需要的任何其他东西，比如：</p>
<ul>
<li>重置单击按钮时的状态；</li>
<li>区分错误类型；</li>
<li>将错误推到某个上下文。</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://codesandbox.io/embed/simple-error-boundary-component-4ldsun?file=/src/App.tsx?codemirror=1&hidedevtools=0&view=preview">看看大概的例子</a></p>
<p>不过，在这个捕获错误自由的世界中有一个问题：它不能捕获所有内容。</p>
<h2 id="ErrorBoundary-组件的限制"><a href="#ErrorBoundary-组件的限制" class="headerlink" title="ErrorBoundary 组件的限制"></a>ErrorBoundary 组件的限制</h2><p><code>ErrorBoundary</code>只捕捉 React 生命周期中发生的错误。发生在它之外的事情，如<code>Promise</code>的<code>resolve</code>，带 setTimeout 的异步代码，各种回调和事件处理程序，如果不显式地处理，就会被彻底忽略。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">Component</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 这个报错会被 ErrorBoundary component 捕获</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Destroy everything!&#x27;</span>);</span><br><span class="line">  &#125;, [])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">onClick</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 但是这个没了就没了</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;我自由了！&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 如果这个接口失败了，也不会被发现</span></span><br><span class="line">    <span class="title function_">fetch</span>(<span class="string">&#x27;/jiekou&#x27;</span>)</span><br><span class="line">  &#125;, [])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;onClick&#125;</span>&gt;</span>点我<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">ComponentWithBoundary</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">ErrorBoundary</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Component</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">ErrorBoundary</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里常见的建议是使用常规的<code>try/catch</code>来处理这类错误。至少在这里我们可以安全地使用 state：事件处理程序的回调正是我们通常<code>setting state</code>的地方。所以从技术上讲，我们可以把两种方法结合起来，做这样的事情：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">Component</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> [hasError, setHasError] = <span class="title function_">useState</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这个组件和子组件中的大多数错误都将被ErrorBoundary捕获</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">onClick</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 这个会被catch捕获</span></span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;我不自由了!&#x27;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">      <span class="title function_">setHasError</span>(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (hasError) <span class="keyword">return</span> <span class="string">&#x27;something went wrong&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;onClick&#125;</span>&gt;</span>点我<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">ComponentWithBoundary</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">ErrorBoundary</span> <span class="attr">fallback</span>=<span class="string">&#123;</span>&quot;<span class="attr">艾玛粗戳了</span>！&quot;&#125;&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Component</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">ErrorBoundary</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是，我们又回到了原点：每个组件都需要保持它的“错误”状态？更重要的是，怎么决定如何处理它。</p>
<p>当然，我们可以不在组件级别上处理这些错误，只是通过<code>props</code>或<code>Context</code>将它们传递到具有<code>ErrorBoundary</code>的父类,这样至少我们可以在一个地方有一个“<code>fallback</code>”组件：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">Component</span> = (<span class="params">&#123; onError &#125;</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">onClick</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;坏了坏了!&#x27;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">      <span class="comment">// 这里就调用props，而不需要自己维护一个state</span></span><br><span class="line">      <span class="title function_">onError</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;onClick&#125;</span>&gt;</span>点我<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">ComponentWithBoundary</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> [hasError, setHasError] = <span class="title function_">useState</span>();</span><br><span class="line">  <span class="keyword">const</span> fallback = <span class="string">&quot;艾玛！出错了呀！&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (hasError) <span class="keyword">return</span> fallback;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">ErrorBoundary</span> <span class="attr">fallback</span>=<span class="string">&#123;fallback&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Component</span> <span class="attr">onError</span>=<span class="string">&#123;()</span> =&gt;</span> setHasError(true)&#125; /&gt;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">ErrorBoundary</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是！但是它有太多额外的代码！我们必须对渲染树中的每个子组件都这样做，更不用说我们现在基本上在维护两个错误状态：</p>
<ul>
<li>在父组件中；</li>
<li>在 ErrorBoundary 本身中。</li>
</ul>
<p><code>ErrorBoundary</code>已经有了所有的机制来将错误传播到树上，我们在这里做了双重工作。<br>难道我们不能用<code>ErrorBoundary</code>从异步代码和事件处理程序中捕获这些错误吗?</p>
<h2 id="使用-ErrorBoundary-捕获异步错误"><a href="#使用-ErrorBoundary-捕获异步错误" class="headerlink" title="使用 ErrorBoundary 捕获异步错误"></a>使用 ErrorBoundary 捕获异步错误</h2><p>有趣的是，我们可以用<code>ErrorBoundary</code>来捕获它们!国外大佬 Dan Abramov 分享了一个很酷的 hack 来实现这一点：<a target="_blank" rel="noopener" href="https://github.com/facebook/react/issues/14981#issuecomment-468460187"> Throwing Error from hook not caught in error boundary · Issue #14981 · facebook/react.</a>。</p>
<p>这里的技巧是先用<code>try/catch</code>捕获这些错误，然后在<code>catch</code>语句中触发正常的<code>React re-render</code>，然后重新将这些错误扔回<code>re-render</code>生命周期。这样<code>ErrorBoundary</code>就可以像捕获其他错误一样捕获它们。由于状态更新是触发重新呈现的方式，而<a target="_blank" rel="noopener" href="https://beta.reactjs.org/reference/react/useState#updating-state-based-on-the-previous-state"><code>state set函数</code>实际上可以接受一个<code>updater函数</code>作为参数</a>，解决方案真的让人喊一声大佬牛*：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">Component</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">// create some random state that we&#x27;ll use to throw errors</span></span><br><span class="line">  <span class="keyword">const</span> [state, setState] = <span class="title function_">useState</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">onClick</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// something bad happened</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="comment">// trigger state update, with updater function as an argument</span></span><br><span class="line">      <span class="title function_">setState</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// re-throw this error within the updater function</span></span><br><span class="line">        <span class="comment">// it will be triggered during state update</span></span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://codesandbox.io/embed/simple-async-error-in-error-boundary-r8l22g?file=/src/App.tsx?codemirror=1&hidedevtools=0&view=preview">省流版示例，戳戳</a></p>
<p>这里的最后一步是将<code>hack</code>抽象出来，这样我们就不必在每个组件中创建<code>state</code>。我们可以在这里发挥创意，创建一个<code>hook</code>，作为一个异步错误抛出器：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">useThrowAsyncError</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> [state, setState] = <span class="title function_">useState</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">setState</span>(<span class="function">() =&gt;</span> <span class="keyword">throw</span> error)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用法如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">Component</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> throwAsyncError = <span class="title function_">useThrowAsyncError</span>();</span><br><span class="line"></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">fetch</span>(<span class="string">&#x27;/jieou&#x27;</span>).<span class="title function_">then</span>().<span class="title function_">catch</span>(<span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 异步抛出错误</span></span><br><span class="line">      <span class="title function_">throwAsyncError</span>(e)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者，我们可以像这样包裹一下回调：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">useCallbackWithErrorHandling</span> = (<span class="params">callback</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> [state, setState] = <span class="title function_">useState</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="title function_">callback</span>(...args);</span><br><span class="line">    &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">      <span class="title function_">setState</span>(<span class="function">() =&gt;</span> <span class="keyword">throw</span> e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样的用法如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">Component</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">onClick</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 触发一个报错</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;毁灭吧！&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> onClickWithErrorHandler = <span class="title function_">useCallbackWithErrorHandling</span>(onClick);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;onClickWithErrorHandler&#125;</span>&gt;</span>点我!<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者任何你内心想要的和 app 要求的东西，没有限制!<br>我从事前端这么多年<br>我写 bug 赔了这么多钱<br>不就……<br>就不会再有错误了。</p>
<p><a target="_blank" rel="noopener" href="https://codesandbox.io/s/fzg5zv">完整例子在这，戳戳</a></p>
<h2 id="能用-react-error-boundary-代替吗"><a href="#能用-react-error-boundary-代替吗" class="headerlink" title="能用 react-error-boundary 代替吗?"></a>能用 react-error-boundary 代替吗?</h2><p>对于那些讨厌重新发明轮子或者只是喜欢用库来解决已经解决的问题的人来说，有一个很好的实现了一个灵活的<code>ErrorBoundary</code>组件，并有一些类似于上面描述的有用的 utils：<a target="_blank" rel="noopener" href="https://github.com/bvaughn/react-error-boundary">GitHub - bvaughn/react-error-boundary</a><br>是否使用它只是个人偏好、编码风格和组件中的独特情况的问题。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>写代码就是为了优雅，这篇文章希望对大家处理 Error 的时候能有所帮助。<br>省流小知识点：</p>
<ul>
<li><code>try/catch</code>块不会捕获<code>useEffect</code>等钩子和任何子组件内部的错误</li>
<li><code>ErrorBoundary</code>可以捕获它们，但它不会捕获<strong>异步代码</strong>和<strong>事件处理程序中</strong>的错误</li>
<li>尽管如此，你可以让<code>ErrorBoundary</code>捕获它们，你只需要先用<code>try/catch</code>捕获它们，然后<strong>重新</strong>将它们扔回 React 生命周期</li>
</ul>
<p>希望永无事件发生！</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">作者: </span><span class="post-copyright-info"><a href="mailto:undefined">张熠</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://crazyoctopusdan.github.io/2023/03/08/%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86React%E4%B8%AD%E7%9A%84Errors/">https://crazyoctopusdan.github.io/2023/03/08/%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86React%E4%B8%AD%E7%9A%84Errors/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/React/">React</a></div><div class="addthis_inline_share_toolbox pull-right"></div><script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=undefined" async></script><nav id="pagination"><div class="prev-post pull-left"><a href="/2023/03/27/%E5%A5%BD%E7%94%A8%E7%9A%84Vscode/"><i class="fa fa-chevron-left">  </i><span>好用的Vscode</span></a></div><div class="next-post pull-right"><a href="/2023/03/07/%E3%80%8AReact%20Query%20%E7%AC%94%E8%AE%B0%E3%80%8B/"><span>《React Query 笔记》</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2018 - 2023 By 张熠</div><div class="framework-info"></div><div class="footer_custom_text">欢迎来到Codan的博客 | <i class="fa fa-envelope-o" aria-hidden="true"></i><a href="mailto:contactcodan@163.com">contactcodan@163.com</a> | <i class="fa fa-weixin" aria-hidden="true"></i>zy840271360</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script src="/js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">文章搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索封面标题(-^〇^-)"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>