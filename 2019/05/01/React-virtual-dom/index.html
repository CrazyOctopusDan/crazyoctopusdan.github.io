<!DOCTYPE html><html><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="React虚拟DOM 深入学习"><meta name="keywords" content="React"><meta name="author" content="张熠"><meta name="copyright" content="张熠"><title>React虚拟DOM 深入学习 | Codan's Blog</title><link rel="shortcut icon" href="/img/zhangyi.png"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"╥﹏╥木有找到: ${query}"}},
  copy: {
    success: '复制成功！',
    error: '复制失败了',
    noSupport: '当前浏览器并不支持~'
  }
} </script><meta name="generator" content="Hexo 6.3.0"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="文章信息">网站信息</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已阅读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E9%9C%80%E8%A6%81%EF%BC%88React-virtual-dom%EF%BC%89%EF%BC%9F"><span class="toc-number">1.</span> <span class="toc-text">为什么我需要（React-virtual-dom）？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%83%BD9102%E5%B9%B4%E4%BA%86%EF%BC%8C%E4%BD%A0%E5%87%AD%E4%BB%80%E4%B9%88%E8%BF%98%E8%AF%B4%E6%88%91%E4%BB%AC%E6%B5%8F%E8%A7%88%E5%99%A8%E6%85%A2%EF%BC%9F"><span class="toc-number">2.</span> <span class="toc-text">都9102年了，你凭什么还说我们浏览器慢？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%99%9A%E6%8B%9FDom%E5%91%A2%EF%BC%9F"><span class="toc-number">3.</span> <span class="toc-text">什么是虚拟Dom呢？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%A5%9E%E7%A7%98%E7%9A%84Diff%E7%AE%97%E6%B3%95"><span class="toc-number">4.</span> <span class="toc-text">神秘的Diff算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%97%E8%A1%A8%E6%B8%B2%E6%9F%93%E7%9A%84%E5%85%83%E7%B4%A0%EF%BC%8C%E4%BD%A0%E5%A6%82%E6%9E%9C%E4%B8%8D%E5%8A%A0key%EF%BC%8C%E6%88%91%E5%B0%B1%E5%97%B7%E5%97%B7%E5%8F%AB%E2%80%A6%E2%80%A6"><span class="toc-number">4.1.</span> <span class="toc-text">列表渲染的元素，你如果不加key，我就嗷嗷叫……</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E7%BB%88%E6%98%A0%E5%B0%84%E5%88%B0%E7%9C%9F%E5%AE%9EDOM%E4%B8%AD"><span class="toc-number">4.2.</span> <span class="toc-text">最终映射到真实DOM中</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#React-Fiber"><span class="toc-number">5.</span> <span class="toc-text">React Fiber</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE"><span class="toc-number">6.</span> <span class="toc-text">参考文献</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="http://ww1.sinaimg.cn/large/006tNc79ly1g4mh0h5ecmj30uv0u0e82.jpg"></div><div class="author-info__name text-center">张熠</div><div class="author-info__description text-center">摸摸鱼</div><div class="follow-button"><a target="_blank" rel="noopener" href="https://github.com/crazyoctopusdan">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">20</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">15</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">友链</div><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://zcxb.github.io">陈小波</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://www.yongsheng.us">康师傅</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://wukong1995.github.io">悟空</a></div></div></div><div id="content-outer"><div class="no-bg" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Codan's Blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a><a class="site-page" href="/">主页</a><a class="site-page" href="/archives">归档</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">分类</a></span></div><div id="post-info"><div id="post-title">React虚拟DOM 深入学习</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-05-01</time><div class="post-meta-wordcount"><span>本文字数: </span><span class="word-count">3.1k</span><span class="post-meta__separator">|</span><span>阅读时间: 11 分钟</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h1 id="为什么我需要（React-virtual-dom）？"><a href="#为什么我需要（React-virtual-dom）？" class="headerlink" title="为什么我需要（React-virtual-dom）？"></a>为什么我需要（React-virtual-dom）？</h1><p>产品的功能源自需求，react 作为一个成功的UI库也是如此。</p>
<p>假象我们有这种需求：</p>
<blockquote>
<p>我需要自己撸一个轮子，能够在数据改变的时候，及时相应在页面上面，怎么做？</p>
</blockquote>
<p>一个工作两年左右的工程师就会思考：</p>
<ol>
<li>state改变监听</li>
<li>拥有一个JSX模板</li>
<li>state改变被监听+模板变化 = 生成一个DOM展示；</li>
<li>state又变了；</li>
<li>state改变被监听+模板变化 = 生成一个新的DOM展示；</li>
</ol>
<p>问题存在吗？</p>
<p>问题很大：</p>
<ul>
<li>第一次生成了一整个DOM；</li>
<li>第二次有生成了一整个DOM;</li>
<li>第二次的DOM完整替换了第一次生成的DOM;</li>
</ul>
<p>重绘很耗费性能的好嘛。</p>
<p>粗略地改进：<br>…4</p>
<ol start="5">
<li>在替换旧的DOM之前进行对比，不一样的再替换之（实际上就是DocumentFragment）;</li>
<li>展示新的DOM;</li>
</ol>
<p>提升如何？<br>其实并不明显</p>
<p>React方案改进<br>…2</p>
<ol start="3">
<li>state改变被监听+模板变化 =&gt; 生成虚拟DOM，用以描述真实DOM；</li>
<li>用虚拟DOM生成真实DOM；</li>
<li>state又变了；</li>
<li>state改变被监听+模板变化 =&gt; 生成新的虚拟DOM，比较旧的虚拟DOM和新鲜的虚拟DOM，找到区别，直接修改；</li>
</ol>
<p>终于：</p>
<ul>
<li>性能提升一截；</li>
<li>甚至使得跨端应用成为现实，RN（React Native）得到广泛使用。为什么呢？因为原生应用里不存在DOM这个概念，<br>但是虚拟DOM这个思想，这个简单的js对象是完全可以正常跑通的，因此，只需要在执行环境中判断出是在Browser还是App中，就可以使React开发多端应用。</li>
</ul>
<h1 id="都9102年了，你凭什么还说我们浏览器慢？"><a href="#都9102年了，你凭什么还说我们浏览器慢？" class="headerlink" title="都9102年了，你凭什么还说我们浏览器慢？"></a>都9102年了，你凭什么还说我们浏览器慢？</h1><p>先来看一看浏览器加载HTML文件都需要做什么：<br><img src="http://ww3.sinaimg.cn/large/006tNc79ly1g4evhx81ttj30ho089dgf.jpg" alt="BrowserPaint"></p>
<p>虽然每个浏览器有自己的引擎，但是大致工作流程都差不多，如图所示分为5步：</p>
<ol>
<li>用HTML分析器（解析器），分析HTML元素，构建一棵<strong>DOM 树</strong>；</li>
<li>用CSS分析器（解析器），分析CSS文件和元素的inline样式，生成<strong>页面样式表</strong>；</li>
<li>将前面的<strong>DOM树</strong>和<strong>样式表</strong>结合，构建一棵<strong>Render树</strong>。这个过程被称为Attachment，每一个DOM节点都拥有attach方法，接收样式信息，返回一个render对象（renderer)。通过这些render对象(renderer)构成一棵<strong>Render树</strong>；</li>
<li>浏览器对着<strong>Render树</strong>开始布局，为每一个存在于Render树上的节点确定一个精确的坐标；</li>
<li>Render树有了，节点显示的位置坐标也有了，最后一步就是调用每个节点的<strong>paint</strong>方法，让他们现出原形！</li>
</ol>
<p>那么，当你在撸代码的时候，使用了原生的api，或者是JQuery（老夫不管……）去操作DOM时，浏览器就会按照以上5个步骤重新走一遍，而且更加恐怖的是，假设你在写代码时，“我要一次性更新10个DOM节点”，那在浏览器眼中，它收到第一个更新请求后并不知道后面还有九个，因此立刻执行（1.2.3.4.5.），最终执行了10遍流程。<br>假如说每一次新的更新都会对前一个DOM节点的坐标值发生影响，那么也就是说，只有最后一次计算节点的坐标才是有用的，前面9次白算！<br>所以说，虽然随着时代的变迁，计算机硬件不停地升级，Mac电脑都卖到2W了，但是操作DOM的代价依然非常昂贵，频繁地操作更会出现卡顿等奇奇怪怪の现象，严重影响用户体验。<br>不要反驳说，我一个小小的简单的DOM节点能有多少玩意儿啊？<br>给你看看<br><img src="http://ww2.sinaimg.cn/large/006tNc79ly1g4ew0zde6ej32740jganl.jpg" alt=""></p>
<p>那怕是一个小小的div，都有如此多的属性，那么整个DOM树有多少，想想都害怕。</p>
<h1 id="什么是虚拟Dom呢？"><a href="#什么是虚拟Dom呢？" class="headerlink" title="什么是虚拟Dom呢？"></a>什么是虚拟Dom呢？</h1><p>虚拟DOM是一个描述真实DOM的简单js对象</p>
<p>回到上面那个问题中，加入一次操作中有10个更新DOM的操作，那么我虚拟DOM不会像普通浏览器那样傻傻的立即操作，而是将10次更新内容的diff保存到本地的一个js对象中，最终将这个js对象一次性attach到DOM树上，通知浏览器，你好去paint了，这样就可以极大程度上节约计算成本，避免无谓的计算，好钢要用在刀刃上。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">VirtualDomTree</span> = <span class="title class_">Element</span>(<span class="string">&#x27;div&#x27;</span>, &#123; <span class="attr">id</span>: <span class="string">&#x27;virtual-container&#x27;</span> &#125;, [</span><br><span class="line">    <span class="title class_">Element</span>(<span class="string">&#x27;p&#x27;</span>, &#123;&#125;, [<span class="string">&#x27;Virtual DOM&#x27;</span>]),</span><br><span class="line">    <span class="title class_">Element</span>(<span class="string">&#x27;div&#x27;</span>, &#123;&#125;, [<span class="string">&#x27;before update&#x27;</span>]),</span><br><span class="line">    <span class="title class_">Element</span>(<span class="string">&#x27;ul&#x27;</span>, &#123;&#125;, [</span><br><span class="line">        <span class="title class_">Element</span>(<span class="string">&#x27;li&#x27;</span>, &#123; <span class="attr">class</span>: <span class="string">&#x27;list-item&#x27;</span> &#125;, [<span class="string">&#x27;Item 1&#x27;</span>]),</span><br><span class="line">        <span class="title class_">Element</span>(<span class="string">&#x27;li&#x27;</span>, &#123; <span class="attr">class</span>: <span class="string">&#x27;list-item&#x27;</span> &#125;, [<span class="string">&#x27;Item 2&#x27;</span>]),</span><br><span class="line">        <span class="title class_">Element</span>(<span class="string">&#x27;li&#x27;</span>, &#123; <span class="attr">class</span>: <span class="string">&#x27;list-item&#x27;</span> &#125;, [<span class="string">&#x27;Item 3&#x27;</span>]),</span><br><span class="line">    ])</span><br><span class="line">])</span><br></pre></td></tr></table></figure>

<p>好处很明显，数据的更新第一步反映在<strong>js对象</strong>上，在内存中对<strong>js对象</strong>的操作速度肯定比浏览器慢悠悠跑来的快得多，等到更新完毕，再交由浏览器去绘制，完美。</p>
<p>那再具体一点，到底是怎么实现的呢？</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> tagName 节点名</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> props 节点的属性</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> children 子节点</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Element</span>(<span class="params">tagName, props, children</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!(<span class="variable language_">this</span> <span class="keyword">instanceof</span> <span class="title class_">Element</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Element</span>(tagName, props, children);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">tagName</span> = tagName;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">props</span> = props || &#123;&#125;;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">children</span> = children || [];</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">key</span> = props ? props.<span class="property">key</span> : <span class="literal">undefined</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">children</span>.<span class="title function_">forEach</span>(<span class="function">(<span class="params">child</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (child <span class="keyword">instanceof</span> <span class="title class_">Element</span>) &#123;</span><br><span class="line">            count += child.<span class="property">count</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">count</span> = count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>除了以上三个参数之外还会保存key和count</p>
</blockquote>
<p>OK，到了这一步还没有结束，等到有了js对象之后，还需要将其映射成为真实的DOM：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Element</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">render</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> el = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="variable language_">this</span>.<span class="property">tagName</span>);</span><br><span class="line">    <span class="keyword">const</span> props = <span class="variable language_">this</span>.<span class="property">props</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> propName <span class="keyword">in</span> props) &#123;</span><br><span class="line">        <span class="title function_">setAttr</span>(el, propName, props[propName]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">children</span>.<span class="title function_">forEach</span>(<span class="function">(<span class="params">child</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> childEl = (child <span class="keyword">instanceof</span> <span class="title class_">Element</span>) ?</span><br><span class="line">                        child.<span class="title function_">render</span>() : <span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(child);</span><br><span class="line">        el.<span class="title function_">appendChild</span>(childEl);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> el;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>根据DOM名调用源生的createElement创建真实DOM，将DOM的属性全都加到这个DOM元素上，如果有子元素继续递归调用创建子元素，并appendChild挂到该DOM元素上。这样就完成了从创建虚拟DOM到将其映射成真实DOM的全部工作。</p>
<h1 id="神秘的Diff算法"><a href="#神秘的Diff算法" class="headerlink" title="神秘的Diff算法"></a>神秘的Diff算法</h1><p>这个玩意儿算是面试总会问到的。</p>
<p>两棵树如果进行完全的比较，那么时间复杂度是O(n^3 );<br>但是通过《深入浅出React和Redux》这本书的介绍，Diff算法的时间复杂度只有O(n)！</p>
<p>要实现如此低的时间复杂度，那么就要牺牲一些东西，比如，深度遍历、精确性。<br>但是，在现实的前端开发中，跨层级的DOM元素的操作不是占据大多数情形的，因此，这么选择的Diff算法是最优的。</p>
<p><img src="http://ww4.sinaimg.cn/large/006tNc79ly1g4eyqxkkccj31g00gmwh0.jpg" alt=""></p>
<p>diff算法中只会比较同层级的元素，一旦发现某一级之间有所不同，则会弃置其子级，直接用从新的差异的一级以及其下的所有子级替换旧的。我们会有个疑问，这样做那子级中相同的元素不是无法复用了吗，那怎么还能提高比对性能？这无疑是一种缺陷，但也带来了好处就是算法实现简单，也就提高了比对速度，因此最后也是能够提升性能的。</p>
<p>现在，某张小熠又新创建了一棵树，用于和上文中的树比较：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> newVirtualDomTree = <span class="title class_">Element</span>(<span class="string">&#x27;div&#x27;</span>, &#123; <span class="attr">id</span>: <span class="string">&#x27;virtual-container&#x27;</span> &#125;, [</span><br><span class="line">    <span class="title class_">Element</span>(<span class="string">&#x27;h3&#x27;</span>, &#123;&#125;, [<span class="string">&#x27;Virtual DOM&#x27;</span>]),                     <span class="comment">// REPLACE</span></span><br><span class="line">    <span class="title class_">Element</span>(<span class="string">&#x27;div&#x27;</span>, &#123;&#125;, [<span class="string">&#x27;after update&#x27;</span>]),                   <span class="comment">// TEXT</span></span><br><span class="line">    <span class="title class_">Element</span>(<span class="string">&#x27;ul&#x27;</span>, &#123; <span class="attr">class</span>: <span class="string">&#x27;newList&#x27;</span> &#125;, [              <span class="comment">// PROPS</span></span><br><span class="line">        <span class="title class_">Element</span>(<span class="string">&#x27;li&#x27;</span>, &#123; <span class="attr">class</span>: <span class="string">&#x27;item&#x27;</span> &#125;, [<span class="string">&#x27;Item 1&#x27;</span>]),</span><br><span class="line">        <span class="comment">// Element(&#x27;li&#x27;, &#123; class: &#x27;item&#x27; &#125;, [&#x27;Item 2&#x27;]),    // REORDER remove</span></span><br><span class="line">        <span class="title class_">Element</span>(<span class="string">&#x27;li&#x27;</span>, &#123; <span class="attr">class</span>: <span class="string">&#x27;item&#x27;</span> &#125;, [<span class="string">&#x27;Item 3&#x27;</span>]),</span><br><span class="line">    ]),</span><br><span class="line">]);</span><br></pre></td></tr></table></figure>
<p><img src="http://ww3.sinaimg.cn/large/006tNc79ly1g4ez87s2x1j30z409i75b.jpg" alt=""><br>花里胡哨的线，但是也大概表达了Diff了些什么：</p>
<ul>
<li>第一种（蓝色）是最简单的，如图中的p标签变成了H3标签，这个过程被称之为 <strong><em><em>REPLACE</em></em></strong> 旧节点包括下面的子节点都将被卸载，如果新节点和旧节点仅仅是类型不同，但下面的所有子节点都一样时，这样做显得效率不高。但为了避免O(n^3 )的时间复杂度，这样做是值得的。这也提醒了React开发者，应该避免无谓的节点类型的变化，例如运行时将div变成p就没什么太大意义。</li>
<li>第二种（紫色）也比较简单，节点类型一样，仅仅属性或属性值变了。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">renderA</span>: &lt;ul&gt;</span><br><span class="line"><span class="attr">renderB</span>: <span class="language-xml"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">class:</span> &#x27;<span class="attr">newList</span>&#x27;&gt;</span></span></span><br><span class="line"><span class="language-xml">=&gt; [addAttribute class &quot;newList&quot;]</span></span><br></pre></td></tr></table></figure>
<p>这个过程被称为 <strong><em><em>PROPS</em></em></strong><br>这个时候不会触发节点的卸载（componentWillUnmounted）和装载（componentWillMount）生命周期，而是执行了 <strong>节点更新</strong> （shouldComponentUpdated =&gt; componentDidUpdated 系列方法）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">diffProps</span>(<span class="params">oldNode, newNode</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> oldProps = oldNode.<span class="property">props</span>;</span><br><span class="line">    <span class="keyword">const</span> newProps = newNode.<span class="property">props</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> key;</span><br><span class="line">    <span class="keyword">const</span> propsPatches = &#123;&#125;;</span><br><span class="line">    <span class="keyword">let</span> isSame = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// find out different props</span></span><br><span class="line">    <span class="keyword">for</span> (key <span class="keyword">in</span> oldProps) &#123;</span><br><span class="line">        <span class="keyword">if</span> (newProps[key] !== oldProps[key]) &#123;</span><br><span class="line">            isSame = <span class="literal">false</span>;</span><br><span class="line">            propsPatches[key] = newProps[key];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// find out new props</span></span><br><span class="line">    <span class="keyword">for</span> (key <span class="keyword">in</span> newProps) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!oldProps.<span class="title function_">hasOwnProperty</span>(key)) &#123;</span><br><span class="line">            isSame = <span class="literal">false</span>;</span><br><span class="line">            propsPatches[key] = newProps[key];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> isSame ? <span class="literal">null</span> : propsPatches;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>第三种（绿色）就只是文本变化了，文本其实也是一个Text Node，这个简单，直接修改文字内容即可，被称之为 <strong><em><em>TEXT</em></em></strong></li>
<li>第四种是 移动、增加、删除子节点，这个过程被称之为 <strong><em><em>REORDER</em></em></strong></li>
</ul>
<p>具体可以看 <a target="_blank" rel="noopener" href="https://www.infoq.cn/article/react-dom-diff/">虚拟DOM 算法解析</a></p>
<h2 id="列表渲染的元素，你如果不加key，我就嗷嗷叫……"><a href="#列表渲染的元素，你如果不加key，我就嗷嗷叫……" class="headerlink" title="列表渲染的元素，你如果不加key，我就嗷嗷叫……"></a>列表渲染的元素，你如果不加key，我就嗷嗷叫……</h2><p><img src="http://ww3.sinaimg.cn/large/006tNc79ly1g4ezut9k77j310a02uwfs.jpg" alt=""><br>这个warning，vue和react都会报。他们强烈建议开发者，拜托你在写通过数组循环渲染item的时候，一定要加上key，不然我们在虚拟DOM比较的时候就只能进行两层循环，才知道什么发生改变了，你们开发者如果加上了key，那我们就可以非常快速且清晰地比较出新增和删除了什么东西！</p>
<p>比如⤵️</p>
<p>A B 【F】 C D E</p>
<p>我想要插入一个F元素，那么简单粗暴的方法就出现了：<br>卸载C，装载F，卸载D，装载C，卸载E，装载D，装载E<br><img src="http://ww1.sinaimg.cn/large/006tNc79ly1g4f02dkxxcj30su09w757.jpg" alt=""></p>
<p>如果我们在JSX里为数组或枚举型元素增加上key后，React就能根据key，直接找到具体的位置进行操作，效率比较高。</p>
<blockquote>
<p> Keys should be “stable, predictable, and unique.” 所以不建议在使用key的时候，简单地使用上数组的index属性，那个玩意儿会带来巨大的坑。</p>
</blockquote>
<p><img src="http://ww1.sinaimg.cn/large/006tNc79ly1g4f08h182lj30s609ejsa.jpg" alt=""></p>
<blockquote>
<p>因此就变成了最小编辑距离问题，可以用Levenshtein Distance算法来实现，时间复杂度是O(M*N)，但通常我们只要一些简单的移动就能满足需要，降低点精确性，将时间复杂度降低到O(max(M, N)即可。</p>
</blockquote>
<p>最终Diff出来的结果</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="number">1</span>: [ &#123;<span class="attr">type</span>: <span class="variable constant_">REPLACE</span>, <span class="attr">node</span>: <span class="title class_">Element</span>&#125; ],</span><br><span class="line">    <span class="number">4</span>: [ &#123;<span class="attr">type</span>: <span class="variable constant_">TEXT</span>, <span class="attr">content</span>: <span class="string">&quot;after update&quot;</span>&#125; ],</span><br><span class="line">    <span class="number">5</span>: [ &#123;<span class="attr">type</span>: <span class="variable constant_">PROPS</span>, <span class="attr">props</span>: &#123;<span class="attr">class</span>: <span class="string">&quot;newList&quot;</span>&#125;&#125;, &#123;<span class="attr">type</span>: <span class="variable constant_">REORDER</span>, <span class="attr">moves</span>: [&#123;<span class="attr">index</span>: <span class="number">2</span>, <span class="attr">type</span>: <span class="number">0</span>&#125;]&#125; ],</span><br><span class="line">    <span class="number">6</span>: [ &#123;<span class="attr">type</span>: <span class="variable constant_">REORDER</span>, <span class="attr">moves</span>: [&#123;<span class="attr">index</span>: <span class="number">2</span>, <span class="attr">type</span>: <span class="number">0</span>&#125;]&#125; ],</span><br><span class="line">    <span class="number">8</span>: [ &#123;<span class="attr">type</span>: <span class="variable constant_">REORDER</span>, <span class="attr">moves</span>: [&#123;<span class="attr">index</span>: <span class="number">2</span>, <span class="attr">type</span>: <span class="number">0</span>&#125;]&#125; ],</span><br><span class="line">    <span class="number">9</span>: [ &#123;<span class="attr">type</span>: <span class="variable constant_">TEXT</span>, <span class="attr">content</span>: <span class="string">&quot;Item 3&quot;</span>&#125; ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="最终映射到真实DOM中"><a href="#最终映射到真实DOM中" class="headerlink" title="最终映射到真实DOM中"></a>最终映射到真实DOM中</h2><p>深度遍历DOM将Diff的内容更新进去：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">dfsWalk</span>(<span class="params">node, walker, patches</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> currentPatches = patches[walker.<span class="property">index</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> len = node.<span class="property">childNodes</span> ? node.<span class="property">childNodes</span>.<span class="property">length</span> : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        walker.<span class="property">index</span>++;</span><br><span class="line">        <span class="title function_">dfsWalk</span>(node.<span class="property">childNodes</span>[i], walker, patches);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (currentPatches) &#123;</span><br><span class="line">        <span class="title function_">applyPatches</span>(node, currentPatches);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体的更新代码如下<br>其实就是根据Diff信息调用源生API操作DOM：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">applyPatches</span>(<span class="params">node, currentPatches</span>) &#123;</span><br><span class="line">    currentPatches.<span class="title function_">forEach</span>(<span class="function">(<span class="params">currentPatch</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> (currentPatch.<span class="property">type</span>) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="attr">REPLACE</span>: &#123;</span><br><span class="line">                <span class="keyword">const</span> newNode = (<span class="keyword">typeof</span> currentPatch.<span class="property">node</span> === <span class="string">&#x27;string&#x27;</span>)</span><br><span class="line">                    ? <span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(currentPatch.<span class="property">node</span>)</span><br><span class="line">                    : currentPatch.<span class="property">node</span>.<span class="title function_">render</span>();</span><br><span class="line">                node.<span class="property">parentNode</span>.<span class="title function_">replaceChild</span>(newNode, node);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="attr">REORDER</span>:</span><br><span class="line">                <span class="title function_">reorderChildren</span>(node, currentPatch.<span class="property">moves</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="attr">PROPS</span>:</span><br><span class="line">                <span class="title function_">setProps</span>(node, currentPatch.<span class="property">props</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="attr">TEXT</span>:</span><br><span class="line">                <span class="keyword">if</span> (node.<span class="property">textContent</span>) &#123;</span><br><span class="line">                    node.<span class="property">textContent</span> = currentPatch.<span class="property">content</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// ie</span></span><br><span class="line">                    node.<span class="property">nodeValue</span> = currentPatch.<span class="property">content</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="attr">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">`Unknown patch type <span class="subst">$&#123;currentPatch.type&#125;</span>`</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个时候呼应开头了，虚拟DOM的目的是将所有操作累加起来，统计计算出所有的变化后，统一更新一次DOM，以上大概就是全部解析内容了。</p>
<h1 id="React-Fiber"><a href="#React-Fiber" class="headerlink" title="React Fiber"></a>React Fiber</h1><p>请看下一篇我的博客《React-Fiber学习笔记》</p>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a target="_blank" rel="noopener" href="https://reactjs.org/docs/faq-internals.html#what-is-the-virtual-dom">What is the Virtual DOM?「React官网」</a><br><a target="_blank" rel="noopener" href="https://www.infoq.cn/article/react-dom-diff/">深入浅出React： 虚拟DOM Diff 算法解析</a><br>链接挂掉了几个<br>深度剖析：如何实现一个 Virtual DOM 算法</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">作者: </span><span class="post-copyright-info"><a href="mailto:undefined">张熠</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://crazyoctopusdan.github.io/2019/05/01/React-virtual-dom/">https://crazyoctopusdan.github.io/2019/05/01/React-virtual-dom/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/React/">React</a></div><div class="addthis_inline_share_toolbox pull-right"></div><script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=undefined" async></script><nav id="pagination"><div class="prev-post pull-left"><a href="/2019/06/27/GMTC%E5%A4%A7%E4%BC%9A%E8%AE%B0/"><i class="fa fa-chevron-left">  </i><span>GMTC大会记</span></a></div><div class="next-post pull-right"><a href="/2019/04/08/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/"><span>微信小程序开发指南</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2018 - 2023 By 张熠</div><div class="framework-info"></div><div class="footer_custom_text">欢迎来到Codan的博客 | <i class="fa fa-envelope-o" aria-hidden="true"></i><a href="mailto:contactcodan@163.com">contactcodan@163.com</a> | <i class="fa fa-weixin" aria-hidden="true"></i>zy840271360</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script src="/js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">文章搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索封面标题(-^〇^-)"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>