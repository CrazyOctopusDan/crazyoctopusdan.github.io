<!DOCTYPE html><html><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="吾来-画布功能要点汇总"><meta name="keywords" content="React Redux JsPlumb Dom"><meta name="author" content="张熠"><meta name="copyright" content="张熠"><title>吾来-画布功能要点汇总 | Codan's Blog</title><link rel="shortcut icon" href="/img/zhangyi.png"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"╥﹏╥木有找到: ${query}"}},
  copy: {
    success: '复制成功！',
    error: '复制失败了',
    noSupport: '当前浏览器并不支持~'
  }
} </script><meta name="generator" content="Hexo 6.3.0"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="文章信息">网站信息</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已阅读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%A6%81%E7%82%B9%E6%B1%87%E6%80%BB"><span class="toc-number">1.</span> <span class="toc-text">要点汇总</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%BB%E5%B8%83%E7%9A%84%E5%89%8D%E8%BA%AB%E4%BB%8A%E4%B8%96"><span class="toc-number">1.1.</span> <span class="toc-text">画布的前身今世</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#DM1%E6%97%B6%E4%BB%A3"><span class="toc-number">1.1.1.</span> <span class="toc-text">DM1时代</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DM1-8%E6%97%B6%E4%BB%A3"><span class="toc-number">1.1.2.</span> <span class="toc-text">DM1.8时代</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DM2%E6%97%B6%E4%BB%A3"><span class="toc-number">1.1.3.</span> <span class="toc-text">DM2时代</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%80%E6%9C%AF%E9%80%89%E6%8B%A9"><span class="toc-number">1.2.</span> <span class="toc-text">技术选择</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#D3-js"><span class="toc-number">1.2.1.</span> <span class="toc-text">D3.js</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Canvas"><span class="toc-number">1.2.2.</span> <span class="toc-text">2. Canvas</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-JSPlumb"><span class="toc-number">1.2.3.</span> <span class="toc-text">3. JSPlumb</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%80%E6%9C%AF%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.3.</span> <span class="toc-text">技术实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E7%AB%AF%E5%89%8D%E6%8A%80%E6%9C%AF"><span class="toc-number">1.3.1.</span> <span class="toc-text">前端前技术</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF"><span class="toc-number">1.3.2.</span> <span class="toc-text">前后端技术</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#MongoDB"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">MongoDB</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E7%BB%86%E8%8A%82"><span class="toc-number">1.4.</span> <span class="toc-text">代码细节</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84"><span class="toc-number">1.4.1.</span> <span class="toc-text">目录结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#block"><span class="toc-number">1.4.2.</span> <span class="toc-text">block</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#common"><span class="toc-number">1.4.3.</span> <span class="toc-text">common</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#configs"><span class="toc-number">1.4.4.</span> <span class="toc-text">configs</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#forms"><span class="toc-number">1.4.5.</span> <span class="toc-text">forms</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#hoc%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6"><span class="toc-number">1.4.6.</span> <span class="toc-text">hoc高阶组件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%85%8D%E5%90%88%E6%93%8D%E4%BD%9C"><span class="toc-number">1.5.</span> <span class="toc-text">配合操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%9A%E5%8A%A1%E8%BF%B7%E6%83%91%E8%A1%8C%E4%B8%BA%E5%AD%A6%E5%A4%A7%E8%B5%8F"><span class="toc-number">1.6.</span> <span class="toc-text">业务迷惑行为学大赏</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%A1%AB%E6%A7%BD%E9%A1%BA%E5%BA%8F%E8%B0%83%E6%95%B4"><span class="toc-number">1.6.1.</span> <span class="toc-text">1. 填槽顺序调整</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E4%BB%A3%E7%A0%81%E5%B1%82%E9%9D%A2%EF%BC%9A"><span class="toc-number">1.6.2.</span> <span class="toc-text">1.2 代码层面：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#FAQ"><span class="toc-number">1.7.</span> <span class="toc-text">FAQ</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9E%E7%BA%BF%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9F"><span class="toc-number">1.7.1.</span> <span class="toc-text">连线的数据结构？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%96%E6%8B%BD%E5%90%8E%E5%9D%97%E7%BB%93%E6%9E%84%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BF%9E%E7%BA%BF%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F"><span class="toc-number">1.7.2.</span> <span class="toc-text">拖拽后块结构之间的连线是怎么实现的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%AF%E5%90%A6%E6%9C%89%E7%94%BB%E5%B8%83%E8%83%BD%E6%89%BF%E8%BD%BD%E7%9A%84%E6%9C%80%E5%A4%A7%E5%8D%95%E5%85%83%E6%95%B0%EF%BC%9F"><span class="toc-number">1.7.3.</span> <span class="toc-text">是否有画布能承载的最大单元数？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E5%85%83%E8%BE%B9%E4%B8%8A%E7%9A%84%E7%AB%AF%E7%82%B9%E6%98%AF%E5%A6%82%E4%BD%95%E8%AE%BE%E7%BD%AE%E7%9A%84%EF%BC%9F"><span class="toc-number">1.7.4.</span> <span class="toc-text">单元边上的端点是如何设置的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9E%E7%BA%BF%E4%B8%8A%E7%9A%84%E5%88%A0%E9%99%A4icon%E6%98%AF%E6%80%8E%E4%B9%88%E6%94%BE%E4%B8%8A%E5%8E%BB%E7%9A%84"><span class="toc-number">1.7.5.</span> <span class="toc-text">连线上的删除icon是怎么放上去的?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AF%8F%E6%AC%A1%E6%94%B9%E5%8F%98%E6%97%B6%E5%80%99%E8%8D%89%E7%A8%BF%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%96%B0%EF%BC%8C%E6%98%AF%E5%81%9A%E7%9A%84%E5%B7%AE%E9%87%8F%E8%AE%A1%E7%AE%97%E5%90%97%EF%BC%8C%E9%83%BD%E4%BF%9D%E5%AD%98%E4%BA%86%E9%82%A3%E4%BA%9B%E5%80%BC%E6%9D%A5%E5%AF%B9%E6%AF%94%E6%98%AF%E5%90%A6%E6%94%B9%E5%8F%98%E4%BA%86%E5%B9%B6%E5%AD%98%E5%9C%A8%E5%93%AA%E9%87%8C%E4%BA%86%EF%BC%9F"><span class="toc-number">1.7.6.</span> <span class="toc-text">每次改变时候草稿自动更新，是做的差量计算吗，都保存了那些值来对比是否改变了并存在哪里了？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%96%E5%8A%A8%E6%97%B6%EF%BC%8C%E8%BF%9E%E6%8E%A5%E7%BA%BF%E7%9A%84%E5%8F%98%E5%8C%96%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F"><span class="toc-number">1.7.7.</span> <span class="toc-text">拖动时，连接线的变化是如何实现的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A6%E4%BE%A7%E6%8B%96%E6%8B%BD%E7%BB%84%E4%BB%B6%E6%98%AF%E7%94%BB%E5%B8%83%E8%87%AA%E5%B8%A6%E7%9A%84%E5%90%97%EF%BC%9F%E6%8B%96%E6%8B%BD%E6%98%AF%E4%BB%80%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F%E5%B7%A6%E4%BE%A7%E7%9A%84%E5%B1%95%E7%A4%BA%E5%8C%BA%E5%9F%9F%E4%B8%AD%E7%9A%84%E5%AF%B9%E8%AF%9D%E5%8D%95%E5%85%83%E6%98%AF%E6%80%8E%E4%B9%88%E5%81%9A%E5%88%B0%E6%8B%96%E5%8A%A8%E5%88%B0%E7%94%BB%E5%B8%83%E4%B8%AD%E7%9A%84%EF%BC%9F"><span class="toc-number">1.7.8.</span> <span class="toc-text">左侧拖拽组件是画布自带的吗？拖拽是什么实现的？左侧的展示区域中的对话单元是怎么做到拖动到画布中的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%96%E6%8B%BD%E6%98%AF%E7%BB%99-div-%E5%A2%9E%E5%8A%A0%E4%BA%86-draggable%E5%B1%9E%E6%80%A7%EF%BC%9B"><span class="toc-number">1.7.9.</span> <span class="toc-text">拖拽是给 div 增加了 draggable属性；</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#hover%E5%A4%9A%E7%AB%AF%E7%82%B9%E7%9A%84%E5%AF%B9%E5%BA%94%E9%A1%B9%E6%97%B6%E5%80%99%EF%BC%8C%E5%A6%82%E4%BD%95%E5%81%9A%E5%88%B0%E5%AF%B9%E5%BA%94%E9%A1%B9%E7%9A%84%E8%BF%9E%E6%8E%A5%E7%BA%BF%E4%B9%9F%E5%90%8C%E6%A0%B7%E5%8F%98%E5%8C%96%EF%BC%9F"><span class="toc-number">1.7.10.</span> <span class="toc-text">hover多端点的对应项时候，如何做到对应项的连接线也同样变化？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%95%E9%83%A8%E7%BC%A9%E7%95%A5%E5%9B%BE%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F"><span class="toc-number">1.7.11.</span> <span class="toc-text">底部缩略图如何实现的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%82%B9%E5%87%BB%E8%BF%98%E5%8E%9F%E6%97%B6%EF%BC%8C%E6%8E%A5%E5%8F%A3%E8%BF%94%E5%9B%9E%E7%9A%84%E5%80%BC%E5%A6%82%E4%BD%95%E5%AF%B9%E5%BA%94%E7%9A%84%EF%BC%8C%E8%BF%98%E5%8E%9F%E5%87%BA%E4%B9%8B%E5%89%8D%E7%9A%84%E7%94%BB%E5%B8%83%EF%BC%9F"><span class="toc-number">1.7.12.</span> <span class="toc-text">点击还原时，接口返回的值如何对应的，还原出之前的画布？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%BB%E5%B8%83%E5%86%85%E5%9D%97%E7%BB%93%E6%9E%84%E4%BD%8D%E7%BD%AE%E6%98%AF%E6%80%8E%E4%B9%88%E4%BF%9D%E5%AD%98%E7%9A%84%EF%BC%9F"><span class="toc-number">1.7.13.</span> <span class="toc-text">画布内块结构位置是怎么保存的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E9%87%8D%E6%96%B0%E6%89%93%E5%BC%80%E7%94%BB%E5%B8%83%E7%9A%84%E6%97%B6%E5%80%99%E4%BC%9A%E6%81%A2%E5%A4%8D%E4%B9%8B%E5%89%8D%E7%9A%84%E4%BD%8D%E7%BD%AE%EF%BC%8C%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%EF%BC%9F"><span class="toc-number">1.7.14.</span> <span class="toc-text">在重新打开画布的时候会恢复之前的位置，如何实现？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#redux%E9%83%BD%E5%AD%98%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.7.15.</span> <span class="toc-text">redux都存了什么？</span></a></li></ol></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="http://ww1.sinaimg.cn/large/006tNc79ly1g4mh0h5ecmj30uv0u0e82.jpg"></div><div class="author-info__name text-center">张熠</div><div class="author-info__description text-center">摸摸鱼</div><div class="follow-button"><a target="_blank" rel="noopener" href="https://github.com/crazyoctopusdan">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">20</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">15</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">友链</div><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://zcxb.github.io">陈小波</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://www.yongsheng.us">康师傅</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://wukong1995.github.io">悟空</a></div></div></div><div id="content-outer"><div class="no-bg" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Codan's Blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a><a class="site-page" href="/">主页</a><a class="site-page" href="/archives">归档</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">分类</a></span></div><div id="post-info"><div id="post-title">吾来-画布功能要点汇总</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-04-09</time><div class="post-meta-wordcount"><span>本文字数: </span><span class="word-count">4k</span><span class="post-meta__separator">|</span><span>阅读时间: 12 分钟</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h1 id="要点汇总"><a href="#要点汇总" class="headerlink" title="要点汇总"></a>要点汇总</h1><ul>
<li>画布的前身今世</li>
<li>技术选择</li>
<li>技术实现</li>
</ul>
<h2 id="画布的前身今世"><a href="#画布的前身今世" class="headerlink" title="画布的前身今世"></a>画布的前身今世</h2><blockquote>
<p>画布是任务场景中对于对话单元的设置以及排布的区域，以下介绍对比了画布的演进历史。</p>
</blockquote>
<h3 id="DM1时代"><a href="#DM1时代" class="headerlink" title="DM1时代"></a>DM1时代</h3><p>DM1（Dialog Manage 1st version）对话管理 即 任务对话管理第一版本;</p>
<p>现在（2019.11.25）依然呈现在项目中-任务对话-场景列表-「旧版」场景;</p>
<p>里面的触发器和对话单元呈现y轴排布，编辑场景对于对话单元的排布要求编辑人员有较高的水准，界面较为简陋，使用起来不是特别得心应手。</p>
<h3 id="DM1-8时代"><a href="#DM1-8时代" class="headerlink" title="DM1.8时代"></a>DM1.8时代</h3><p>DM1.8 这个数字非常有趣，它不是1也不是2，是一个中间版本;<br>它属于DM2数据的前身，现在已经下线。<br>那为什么会出现这个版本呢？<br>想法来源 : 界面采用了和DM1一模一样的配置，不同点在于，算法团队领先于迭代2个月升级了数据库，升级了算法结构，在非常紧急的情况下需要兼容到DM2的数据结构以及DM1的用户交互，花费1个迭代 + 10.1黄金周的时间完成。</p>
<h3 id="DM2时代"><a href="#DM2时代" class="headerlink" title="DM2时代"></a>DM2时代</h3><p>DM2（Dialog Manage 2nd version）任务对话管理第二版本<br>现在项目中的主流场景，也是现在维护的重心所在。</p>
<pre><code>从十月中旬到11.22日上线，由乔岳领衔，张熠、康永胜通力合作，实际开发时间 为（10.27-11.22），胜利上线。</code></pre><h2 id="技术选择"><a href="#技术选择" class="headerlink" title="技术选择"></a>技术选择</h2><p>在DM1的时期，就有非常多的抱怨声音：</p>
<pre><code>对话单元排布不够直观；

找不到自己需要的对话单元；

流程必须脑子想；

顺序调整麻烦；

……</code></pre><p>CEO做出指示</p>
<blockquote>
<p>“ 我们要打造一款市面上与众不同的对话编辑产品 ”</p>
</blockquote>
<p>于是，DM2的需求就这么拍下来了……</p>
<p>CEO再指示 “ 我们要在11.22日顺利上线 ”</p>
<p>于是，DM2需求的截止日期也拍下来了……</p>
<blockquote>
<p>鲁迅先生说过：“ 调研技术方案很复杂 ”</p>
</blockquote>
<p>的确是这样，按照惯例，我或许想要去扒一扒类似产品的技术栈，然而现实很残酷，我没找到类似产品。</p>
<p>好的，这难不倒我，我想了别的方法——在谷歌搜索中敲入「可视化操作 js 前端 模块拖拽」等的关键词。</p>
<p>结果非常喜人，D3.js 作为最高的推荐进入了我的选择。</p>
<h3 id="D3-js"><a href="#D3-js" class="headerlink" title="D3.js"></a>D3.js</h3><p><a target="_blank" rel="noopener" href="https://d3js.org/">https://d3js.org/</a></p>
<p>D3js作为行业内非常受人关注的可视化工具，里面提供了大量的实例，沉浸在大家开发的各(hua)式(li)各(hu)样(shao)的工具中，我感到异常欣喜——或许调研工作就这么完成了！</p>
<p>我太天真了</p>
<p>D3js 它并不是一个开箱即用的工具，丰富的画布操作、酷炫的物理引擎，在他们的背后是一个又一个的数学函数在支撑。尽管我能找到在界面上有95%相近的模板，但是剩下的5%却可能遥不可及。</p>
<p>在处理了第三个DEMO转换失败之后，我放弃了选用D3js。</p>
<h3 id="2-Canvas"><a href="#2-Canvas" class="headerlink" title="2. Canvas"></a>2. Canvas</h3><p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API">https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API</a></p>
<p>几乎相同的理由，相比于D3js， Canvas 似乎更加原始，通过丰富的API去展示画布中的信息，但是操纵画布怎么返回信息到前端？</p>
<p>‘That really makes me confused !’</p>
<p>闪电般的速度，我就放弃了</p>
<h3 id="3-JSPlumb"><a href="#3-JSPlumb" class="headerlink" title="3. JSPlumb"></a>3. JSPlumb</h3><p><a target="_blank" rel="noopener" href="https://jsplumbtoolkit.com/">https://jsplumbtoolkit.com/</a></p>
<p>社区版的文档地址</p>
<p>感叹着 我太南了 的时候，不经意间进入了这个网站。</p>
<p>哦吼！</p>
<p>这看似一般的界面下，隐藏四个大字（就是他了）</p>
<p>那么好处都有啥？</p>
<ul>
<li><p>看起来就是个编辑流程的玩意儿；</p>
</li>
<li><p>封装了足够多的拖拽连线的事件；</p>
</li>
<li><p>提供了足够的API在社区版本中；</p>
</li>
</ul>
<p>澳大利亚的团队好说话，写了个邮件人家就让我免费使用开发版（一个月）；</p>
<p>距离截止日期又近了几天，要来不及了；</p>
<p>用简单的DEMO证明了从数据到画布是可行的，在画布中自定义单元的样式也是可行的，免费的，可以在React技术栈中使用可行的，连线的效果设计师看了都👏是可行的……</p>
<p>没错，最后我选择的技术栈就是使用JSPlumb。</p>
<h2 id="技术实现"><a href="#技术实现" class="headerlink" title="技术实现"></a>技术实现</h2><p>这是重点，这是重点，这是……</p>
<h3 id="前端前技术"><a href="#前端前技术" class="headerlink" title="前端前技术"></a>前端前技术</h3><p>框架确定好了，那么根据框架特性，我们要确定一个总体的思想——数据流向问题。</p>
<p>需求为 做一个可以多版本的可视化的能拖拽的能连线的 画布，细节自己琢磨。</p>
<p>前端的目光先聚集在“多版本”之后：</p>
<ul>
<li><p>可视化：框架已经帮忙做好了；</p>
</li>
<li><p>能拖拽：框架也帮忙了；</p>
</li>
<li><p>能连线：框架也做好了；</p>
</li>
</ul>
<p>收工！</p>
<p>然而真的是这样吗？</p>
<p>我们做一些对话单元的div放在那里，拖进画布中，画布返回结构，如果需要保存那就再做一次映射？</p>
<p>错，那样的产品不可能免费</p>
<p>实际上JSPlumb的行为完全是由我们操纵的：</p>
<p>渲染画布：从数据库中读取数据，按照JSPlumb官网的要求生成所需的数据结构，传递到画布实例中，渲染生成；</p>
<p>对话单元拖入画布中，放下： 画布监听鼠标放置的位置，返回位置信息（画布左上角为（0,0）向左向下递增），我们修改画布数据，渲染单元；</p>
<p>对话单元连线：连线需要知道两个端点，数据结构为</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">from</span>: id1, <span class="attr">to</span>: id2&#125;</span><br></pre></td></tr></table></figure>

<p>相应的，每个对话单元块会有一个自己的block_id，（如果有多种跳转关系）那么每个单元块内部的关系会有自己的relation_id，通过这些id，就能定义好数据结构，修改画布数据，渲染连线。</p>
<p>由此可见，实际上我们的数据流向是单向的，不必担心画布还会生成一份数据进行糅合处理，永远是外层监听画布内的事件，通过修改渲染画布的数据结构来达到修改画布信息的目的。</p>
<h3 id="前后端技术"><a href="#前后端技术" class="headerlink" title="前后端技术"></a>前后端技术</h3><h4 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h4><blockquote>
<p>“画布内要多版本”-产品经理如是说</p>
</blockquote>
<p>MySQL的操作过于繁重，不适合做版本的管理。</p>
<p>经验丰富的康永胜同志果断的学习并且采用MongoDB的技术栈。</p>
<p>MongoDB拥有轻量的特性，读写速度快，用于画布内的数据存储和版本管理再好不过了，只有在发布画布内信息的时候，MongoDB才会把数据跟MySQL进行一次同步，更新到MySQL当中。</p>
<h2 id="代码细节"><a href="#代码细节" class="headerlink" title="代码细节"></a>代码细节</h2><h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><p>└── Visual<br>├── block<br>│ ├── ask.block.tsx<br>│ ├── …<br>│ ├── collect.block.tsx<br>│ ├── …<br>│ └── block.tsx<br>├── common<br>│ ├── bounce.tsx<br>│ ├── dimension.tsx<br>│ ├── header.tsx<br>│ ├── lemma.tsx<br>│ ├── option.tsx<br>│ └── topbar.tsx<br>├── configs<br>│ ├── block.config.ts<br>│ ├── instance.config.ts<br>│ └── jsplumb.config.ts<br>├── forms<br>│ ├── test.form.tsx<br>│ ├── test.style.ts<br>│ ├── trigger.form.tsx<br>│ └── trigger.style.ts<br>├── hoc<br>│ ├── drag.hoc.tsx<br>│ └── endpoint.hoc.tsx<br>├── canvasView.tsx<br>├── controlsView.tsx<br>├── index.tsx<br>├── visual.data.ts<br>└── visual.style.ts</p>
<h3 id="block"><a href="#block" class="headerlink" title="block"></a>block</h3><p>画布中的对话单元模块，使用的时候有两种模式：</p>
<ol>
<li>简单模式：如同询问单元</li>
</ol>
<p>只需要传递block的种类</p>
<ol start="2">
<li>复杂模式：如同收集单元<br>如果需要自己画出来，那就得自己render。</li>
</ol>
<p>区分简单复杂模式有一个简单的方法，如果这个单元需要填槽，那么大概率他就是一个复杂模式，如果不需要，对话流只需要简单地通过单元，那就是简单模式。</p>
<h3 id="common"><a href="#common" class="headerlink" title="common"></a>common</h3><p>该目录下放置了一些通用的组件:</p>
<ul>
<li><p>bounce.tsx 左侧的抽屉（点击打开关闭）</p>
</li>
<li><p>dimension.tsx 下方的缩略图（minimap）</p>
</li>
<li><p>header.tsx 画布上方的顶栏（意图名称、设置、发布等等）</p>
</li>
<li><p>topbar.tsx 对话单元模块的顶部（对话单元的icon，编辑按钮，删除按钮x）</p>
</li>
<li><p>option.tsx 对话单元模块的区域（跳转关系等，使用endpoint.hoc.tsx包裹生成端点间连接能力）</p>
</li>
<li><p>lemma.tsx 对话单元模块的区域（默认文案、添加关系等）</p>
</li>
</ul>
<h3 id="configs"><a href="#configs" class="headerlink" title="configs"></a>configs</h3><ul>
<li><p>block.config.ts 处理对话单元数据（格式化，一些ENUM定义，提取数据中有关单元信息等的文件）</p>
</li>
<li><p>instance.config.ts 画布实例配置（全局加锁，用于打开编辑框时）</p>
</li>
<li><p>jsplumb.config.ts 画布相关配置（点、线、画布等）</p>
</li>
</ul>
<h3 id="forms"><a href="#forms" class="headerlink" title="forms"></a>forms</h3><p>表单类信息</p>
<p>test.form(style).ts 编辑对话单元详情的文件，非常非常大，希望以后有谁来拆分出来！</p>
<p>trigger.form.ts 以前用来编辑触发器的文件</p>
<h3 id="hoc高阶组件"><a href="#hoc高阶组件" class="headerlink" title="hoc高阶组件"></a>hoc高阶组件</h3><p>drag.hoc.tsx 赋予组件拖动能力，设置对话单元的初始位置（top left），新增端点</p>
<p>endpoint.hoc.tsx 赋予对话单元模块中的端点能力，包括鼠标进出的效果。</p>
<h2 id="配合操作"><a href="#配合操作" class="headerlink" title="配合操作"></a>配合操作</h2><p><strong>index.tsx</strong> 作为画布的入口文件，是输出和渲染画布的主要文件。当路由解析到对应画布的路由的时候，index.tsx就被激活了！</p>
<p>首先会经历一段生命周期，在即将装载的时候会获取一部分数据，以及注册一些方法（展示自动保存）。</p>
<p>装载完成后有个监听和 pushState 操作，这一步操作是为了防止mac用户在操作电脑的时候「左滑 移动 画布」直接触发历史回退，做了拦截。</p>
<p>其他都比较常规，属于看看注释就能看懂的。</p>
<p><strong>visual.data.ts</strong> 是定义了画布内所有接口的文件，基本上在书写画布内代码的时候想要找的接口在这里都能找的！</p>
<p><strong>visual.style.ts</strong> 画布内的大部分样式都在这里，除了对话单元编辑抽屉 和 触发器编辑抽屉</p>
<p><strong>controlsView.tsx</strong> 画布页面左侧的对话单元陈列区域，拥有点击添加、拖拽（拖拽起点监听）添加等的能力。</p>
<p><strong>canvasView.tsx</strong> 画布区域！实例化画布，渲染画布所需要的各种数据结构， 绑定所有建立关联的事件：</p>
<ul>
<li><p>鼠标移入；</p>
</li>
<li><p>鼠标移出；</p>
</li>
<li><p>删除连接；</p>
</li>
<li><p>建立连接（分为触发器-对话单元，对话单元-对话单元）；</p>
</li>
<li><p>拖拽放置新建(onDrop监听nativeEvent , 通过layerX\Y来确定放置位置等)；</p>
</li>
</ul>
<h2 id="业务迷惑行为学大赏"><a href="#业务迷惑行为学大赏" class="headerlink" title="业务迷惑行为学大赏"></a>业务迷惑行为学大赏</h2><h3 id="1-填槽顺序调整"><a href="#1-填槽顺序调整" class="headerlink" title="1. 填槽顺序调整"></a>1. 填槽顺序调整</h3><p>1.1 什么是填槽顺序？</p>
<p>如果一个意图中有多个询问单元或多个隐藏单元，在两种情况下，任务机器人需要用户手动进行流程校准才可以保证机器人跳转正常：</p>
<p>第一种情况：用户的消息可以同时填入多个对话单元对应的槽，这时优先填哪个槽？</p>
<p>第二种情况：用户的消息能更新意图下的某个词槽，这个词槽没有跟当前停留的单元绑定。这时应该：</p>
<p>让当前单元处理这条消息，还是：</p>
<p>让这条消息去填充能够填充的那个词槽，再让流程跳回重新判断</p>
<p>我们通过规定绑定了词槽的单元顺序（询问单元、隐藏单元）来解决这个问题。对于以上两个问题，只要根据这个顺序确定就可以了。</p>
<p>对于case A：按照单元顺序，排在前面的优先填</p>
<p>对于case B：按照单元顺序，如果被更新的词槽在当前词槽前面，就更新词槽；如果在后面，就让当前单元处理这条消息；</p>
<p>拖动单元前的 “把手” 进行排序；</p>
<h3 id="1-2-代码层面："><a href="#1-2-代码层面：" class="headerlink" title="1.2 代码层面："></a>1.2 代码层面：</h3><p>在这个功能当中，发挥作用的字段为 <code>first_order</code></p>
<p>如图中所示，自上而下，降序排列；</p>
<p>不同于对话单元生成时候增长的 order_id，一开始所有单元的 first_order 都是0，只有 type === ‘BLOCK-ASK’ || type === ‘BLOCK-HIDE’的单元在第一次保存校准值之后才会拥有自己的first_order，而且是递减的降序排列；</p>
<h2 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h2><h3 id="连线的数据结构？"><a href="#连线的数据结构？" class="headerlink" title="连线的数据结构？"></a>连线的数据结构？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A: [&#123; from: relation_id, to: block_id &#125;......] 从 id 到 id。</span><br></pre></td></tr></table></figure>


<h3 id="拖拽后块结构之间的连线是怎么实现的？"><a href="#拖拽后块结构之间的连线是怎么实现的？" class="headerlink" title="拖拽后块结构之间的连线是怎么实现的？"></a>拖拽后块结构之间的连线是怎么实现的？</h3><p>A: 连线分为两种模式：1. 画布中拖拽连接；2. 编辑器中设置跳转关系；</p>
<p>方式不同，但是最后都是通过改变渲染画布中连接关系的数据结构来实现连\删线的。</p>
<h3 id="是否有画布能承载的最大单元数？"><a href="#是否有画布能承载的最大单元数？" class="headerlink" title="是否有画布能承载的最大单元数？"></a>是否有画布能承载的最大单元数？</h3><p>A: 前端没有做限制，在数据层似乎有个最大数的限制，🎙康师傅？</p>
<h3 id="单元边上的端点是如何设置的？"><a href="#单元边上的端点是如何设置的？" class="headerlink" title="单元边上的端点是如何设置的？"></a>单元边上的端点是如何设置的？</h3><p>A: JSPlumb提供了方法 jsp.addEndpoint;</p>
<h3 id="连线上的删除icon是怎么放上去的"><a href="#连线上的删除icon是怎么放上去的" class="headerlink" title="连线上的删除icon是怎么放上去的?"></a>连线上的删除icon是怎么放上去的?</h3><p>A: JSPlumb提供了方法 getInstance().onConnectionOver 去设置;</p>
<h3 id="每次改变时候草稿自动更新，是做的差量计算吗，都保存了那些值来对比是否改变了并存在哪里了？"><a href="#每次改变时候草稿自动更新，是做的差量计算吗，都保存了那些值来对比是否改变了并存在哪里了？" class="headerlink" title="每次改变时候草稿自动更新，是做的差量计算吗，都保存了那些值来对比是否改变了并存在哪里了？"></a>每次改变时候草稿自动更新，是做的差量计算吗，都保存了那些值来对比是否改变了并存在哪里了？</h3><p>A: 不是。更新的时候就是各自对应的接口的调用、传递、保存，只不过是全局做了一个动画来表示我们刚刚调用过接口；</p>
<h3 id="拖动时，连接线的变化是如何实现的？"><a href="#拖动时，连接线的变化是如何实现的？" class="headerlink" title="拖动时，连接线的变化是如何实现的？"></a>拖动时，连接线的变化是如何实现的？</h3><p>A: JSPlumb 工具实现好了，只要线连接上，移动对话单元，连接线也可以自己跟着跑；</p>
<h3 id="左侧拖拽组件是画布自带的吗？拖拽是什么实现的？左侧的展示区域中的对话单元是怎么做到拖动到画布中的？"><a href="#左侧拖拽组件是画布自带的吗？拖拽是什么实现的？左侧的展示区域中的对话单元是怎么做到拖动到画布中的？" class="headerlink" title="左侧拖拽组件是画布自带的吗？拖拽是什么实现的？左侧的展示区域中的对话单元是怎么做到拖动到画布中的？"></a>左侧拖拽组件是画布自带的吗？拖拽是什么实现的？左侧的展示区域中的对话单元是怎么做到拖动到画布中的？</h3><p>A: 左侧展示区域并不是画布内的功能，参照 controlsView.tsx;</p>
<h3 id="拖拽是给-div-增加了-draggable属性；"><a href="#拖拽是给-div-增加了-draggable属性；" class="headerlink" title="拖拽是给 div 增加了 draggable属性；"></a>拖拽是给 div 增加了 draggable属性；</h3><p>参照canvasView.tsx文件所述，监听了画布区域中的onDrop事件，触发了一个方法</p>
<p>dropHandle，记录了（新的单元，位置信息，名字，种类等），调用新增对话单元的接口，同时更新树，渲染到画布中，等到接口返回数据，再更新redux中的block-list；</p>
<h3 id="hover多端点的对应项时候，如何做到对应项的连接线也同样变化？"><a href="#hover多端点的对应项时候，如何做到对应项的连接线也同样变化？" class="headerlink" title="hover多端点的对应项时候，如何做到对应项的连接线也同样变化？"></a>hover多端点的对应项时候，如何做到对应项的连接线也同样变化？</h3><p>A: 参照 block.tsx 中的 option.tsx ，他使用 endpoint.hoc.tsx 高阶组件包裹了每一个跳转关系选项，再联合上 jsplumb.config.tsx 中hover线变色的配置，达成了这个效果；</p>
<h3 id="底部缩略图如何实现的？"><a href="#底部缩略图如何实现的？" class="headerlink" title="底部缩略图如何实现的？"></a>底部缩略图如何实现的？</h3><p>A: 参照 dimension.tsx 下方的缩略图（minimap）；</p>
<h3 id="点击还原时，接口返回的值如何对应的，还原出之前的画布？"><a href="#点击还原时，接口返回的值如何对应的，还原出之前的画布？" class="headerlink" title="点击还原时，接口返回的值如何对应的，还原出之前的画布？"></a>点击还原时，接口返回的值如何对应的，还原出之前的画布？</h3><p>A: 返回的数据就和初始拿到的一样即可，就是一次重新打开（渲染）的过程而已；</p>
<h3 id="画布内块结构位置是怎么保存的？"><a href="#画布内块结构位置是怎么保存的？" class="headerlink" title="画布内块结构位置是怎么保存的？"></a>画布内块结构位置是怎么保存的？</h3><p>A: 画布内的对话单元的位置的改变有三种情况：</p>
<p>点击左侧展示区对应的对话单元生成；</p>
<p>拖拽左侧展示区相应的对话单元生成；</p>
<p>挪动画布中的对话单元；</p>
<p>画布中还有一个特殊单位：触发器，他的位置只有挪动改变；</p>
<p><strong>点击</strong>生成的时候，直接按照规则给出当前的pos（x, y），存储到数据中；</p>
<p><strong>拖拽</strong>生成的时候，通过监听事件onDrop，触发了dropHandle，记录pos（event.layerX, event.layerY）;</p>
<p><strong>挪动</strong>对话单元、触发器的时候，参照 drag.hoc.tsx JSPlumb 提供了 getInstance().jsp.draggable的api，监听了拖拽的始末时刻，得到数值，调用接口存储；</p>
<h3 id="在重新打开画布的时候会恢复之前的位置，如何实现？"><a href="#在重新打开画布的时候会恢复之前的位置，如何实现？" class="headerlink" title="在重新打开画布的时候会恢复之前的位置，如何实现？"></a>在重新打开画布的时候会恢复之前的位置，如何实现？</h3><p>A: 拿到数据之后，通过 drag.hoc.tsx 文件中的 render 中的 style，告诉每个对话单元的位置，利用DOM的能力放置每一个对话单元；</p>
<h3 id="redux都存了什么？"><a href="#redux都存了什么？" class="headerlink" title="redux都存了什么？"></a>redux都存了什么？</h3><p>A: 存了好多东西。</p>
<p>画布的redux存储的是画布相关操作引起的变化：</p>
<p>增\删\改对话单元</p>
<p>初始化跳转关系连接</p>
<p>增\删\改 跳转关系</p>
<p>开\关抽屉</p>
<p>画布加锁</p>
<p>简而言之分成3类，画布中 对话单元 （block）、画布中 跳转关系 （connection）、界面 UI。</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">作者: </span><span class="post-copyright-info"><a href="mailto:undefined">张熠</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://crazyoctopusdan.github.io/2020/04/09/%E5%90%BE%E6%9D%A5-%E7%94%BB%E5%B8%83%E5%8A%9F%E8%83%BD%E8%A6%81%E7%82%B9%E6%B1%87%E6%80%BB/">https://crazyoctopusdan.github.io/2020/04/09/%E5%90%BE%E6%9D%A5-%E7%94%BB%E5%B8%83%E5%8A%9F%E8%83%BD%E8%A6%81%E7%82%B9%E6%B1%87%E6%80%BB/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/React-Redux-JsPlumb-Dom/">React Redux JsPlumb Dom</a></div><div class="addthis_inline_share_toolbox pull-right"></div><script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=undefined" async></script><nav id="pagination"><div class="prev-post pull-left"><a href="/2020/06/01/%E4%BD%BF%E7%94%A8UMI3%E6%90%AD%E5%BB%BA%E9%A1%B9%E7%9B%AE%E6%96%B0%E7%9A%84/"><i class="fa fa-chevron-left">  </i><span>使用UMI3搭建项目心得</span></a></div><div class="next-post pull-right"><a href="/2020/04/05/%E5%88%92%E8%AF%8D%E6%A0%87%E6%B3%A8%E7%BC%96%E8%BE%91%E5%99%A8%E5%BC%80%E5%8F%91%E4%B9%8B%E6%97%85/"><span>划词标注编辑器开发之旅</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2018 - 2023 By 张熠</div><div class="framework-info"></div><div class="footer_custom_text">欢迎来到Codan的博客 | <i class="fa fa-envelope-o" aria-hidden="true"></i><a href="mailto:contactcodan@163.com">contactcodan@163.com</a> | <i class="fa fa-weixin" aria-hidden="true"></i>zy840271360</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script src="/js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">文章搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索封面标题(-^〇^-)"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>